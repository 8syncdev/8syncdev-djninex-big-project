{
    "detail": "Lessons API",
    "data": [
        {
            "title": "Chương 1 Giới thiệu",
            "param": "chap-0-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " Giới thiệu về C++",
                    "param": "chap-0-0",
                    "level": "beginner",
                    "code": "# Giới thiệu về C++\nC ++ là ngôn ngữ lập trình hiệu suất cao, có mục đích chung. Nó được phát triển bởi Bjarne Stroustrup tại Bell Labs bắt đầu từ năm 1979. C++ là phần mở rộng của ngôn ngữ lập trình C, bổ sung thêm các tính năng như lớp, đối tượng và ngoại lệ.\n\n## Khái niệm cơ bản về lập trình C++\nDưới đây là một số thành phần và khái niệm cơ bản trong lập trình C++:\n\n## Thư viện include\nVới C++, chúng ta sử dụng chỉ thị #include bao hàm các tệp tiêu đề và thư viện vào chương trình của chúng ta. Ví dụ: để thêm thư viện đầu vào/đầu ra tiêu chuẩn, chúng ta viết:\n\n```cpp\n\n#include <iostream>\n\n```\n\n## Hàm chính\nĐiểm vào của một chương trình C++ là hàm chính. Mọi chương trình C++ đều phải có hàm chính:\n\n```cpp\n\nint main() {\n    // Mã code của bạn ở đây\n    return 0;\n}\n\n```\n\n## Thuật toán đầu vào và đầu ra\nĐể thực hiện các thuật toán đầu vào và đầu ra trong C++, chúng ta có thể sử dụng các đối tượng tích hợp sẵn std::cin cho đầu vào và std::cout cho đầu ra, có sẵn trong thư viện iostream. Đây là một ví dụ về cách đọc một số nguyên và in ra giá trị của nó:\n\n```cpp\n\n#include <iostream>\nint main() {\n    int number;\n    std::cout << \"Enter an integer: \";\n    std::cin >> number;\n    std::cout << \"You entered: \" << number << std::endl;\n    return 0;\n}\n\n```\n\n## Biến và kiểu dữ liệu\nC++ có một số kiểu dữ liệu cơ bản để biểu diễn các giá trị số nguyên, dấu chấm động:\nint: giá trị số nguyên\nfloat: giá trị dấu chấm động độ chính xác đơn\ndouble: giá trị dấu chấm động \nchar: ký tự đơn\nCác biến phải được khai báo với một kiểu dữ liệu trước khi chúng có thể được sử dụng:\n\n```cpp\n\nint x;\nfloat y;\ndouble z;\nchar c;\n\n```\n\n## Cấu trúc điều khiển\nC++ cung cấp các cấu trúc điều khiển để thực thi và lặp lại có điều kiện, chẳng hạn như các lệnh if, else, while, for, và switch các câu lệnh.\n\n## Câu lệnh If-Else\n\n```cpp\n\nif (condition) {\n    // Mã code để thực hiện nếu điều kiện là đúng\n} else {\n    // Mã code để thực hiện nếu điều kiện là sai\n}\n\n```\n\n## Vòng lặp While\n\n```cpp\n\nwhile (condition) {\n    // Mã code để thực thi trong khi điều kiện là đúng\n}\n\n```\n\n## Vòng lặp For\n\n```cpp\n\nfor (initialization; condition; update) {\n    // Mã code để thực thi trong khi điều kiện là đúng\n}\n\n```\n\n## Câu lệnh Switch\n\n```cpp\n\nswitch (variable) {\n    case value1:\n        // Đoạn mã code thực thi nếu biến == value1\n         phá vỡ;\n     trường hợp giá trị2:\n         // Đoạn mã code thực thi nếu biến == value2\n         phá vỡ;\n     // Các trường hợp khác...\n     mặc định:\n         // Mã code để thực thi nếu biến không khớp với bất kỳ giá trị trường hợp nào\n}\n\n```\n\n## Các hàm\nCác hàm là các khối mã có thể tái sử dụng được gọi bằng các đối số để thực hiện một tác vụ cụ thể. Các hàm được định nghĩa với kiểu trả về, tên, danh sách tham số và phần thân.\n\n```cpp\n\nReturnType functionName(ParameterType1 parameter1, ParameterType2 parameter2) {\n    // Hàm body\n    // ...\n    return returnValue;\n}\n\n```\nVí dụ, đây là một hàm cộng hai số nguyên và trả về kết quả:\n\n```cpp\n\nint add(int a, int b) {\n    return a + b;\n}\nint main() {\n    int result = add(3, 4);\n    std::cout << \"3 + 4 = \" << result << std::endl;\n    return 0;\n}\n\n```\nPhần giới thiệu cơ bản về C++ này sẽ cung cấp cho bạn nền tảng tốt để học thêm. Khám phá thêm các chủ đề như lớp, đối tượng, thừa kế, đa hình, mẫu và Thư viện temple chuẩn (STL) để hiểu sâu hơn về C++ và bắt đầu viết các chương trình nâng cao hơn."
                },
                {
                    "author": "Dev Alex",
                    "title": " C++ là gì?",
                    "param": "chap-0-1",
                    "level": "beginner",
                    "code": "# C++ là gì?\nC++ là ngôn ngữ lập trình đa năng do Bjarne Stroustrup tạo ra như một phần mở rộng của ngôn ngữ lập trình C. Nó được giới thiệu lần đầu tiên vào năm 1985 và cung cấp các tính năng hướng đối tượng như lớp và kế thừa. C++ được sử dụng rộng rãi trong các ứng dụng khác nhau như phát triển trò chơi, lập trình hệ thống, hệ thống nhúng và tính toán hiệu năng cao.\n\nC++ là ngôn ngữ được nhập tĩnh, nghĩa là loại biến được xác định trong quá trình biên dịch và có một thư viện mở rộng được gọi là Thư viện chuẩn C++, cung cấp một tập hợp phong phú các hàm, thuật toán và cấu trúc dữ liệu cho các tác vụ khác nhau.\n\nC++ xây dựng dựa trên các tính năng của C, và do đó, hầu hết các chương trình C có thể được biên dịch và chạy bằng trình biên dịch C++.\n\n## Ví dụ mã code\nĐây là một ví dụ đơn giản về chương trình C++ thể hiện một số tính năng thiết yếu của ngôn ngữ:\n\n```cpp\n\n#include <iostream>\n\n// Một chức năng đơn giản để thêm hai số\nint add(int a, int b) {\n    return a + b;\n}\n\nclass Calculator {\npublic:\n    //Một hàm thành viên để nhân hai số\n    int multiply(int a, int b) {\n        return a * b;\n    }\n};\nint main() {\n    int x = 5;\n    int y = 3;\n    // Sử dụng chức năng độc lập 'thêm'\n    int sum = add(x, y);\n    std::cout << \"Sum: \" << sum << std::endl;\n    // Sử dụng một lớp và hàm thành viên\n    Calculator calc;\n    int product = calc.multiply(x, y);\n    std::cout << \"Product: \" << product << std::endl;\n    return 0;\n}\n\n```\nTrong chương trình trên, chúng ta định nghĩa một hàm đơn giản add và một lớp Calculator với một hàm thành viên là multiple. Hàm main  trình bày cách sử dụng chúng để thực hiện số học cơ bản."
                },
                {
                    "author": "Dev Alex",
                    "title": " Tại sao C++",
                    "param": "chap-0-2",
                    "level": "beginner",
                    "code": "# Tại sao C++\nC ++ là ngôn ngữ lập trình phổ biến và được sử dụng rộng rãi vì nhiều lý do. Dưới đây là một số lý do tại sao bạn có thể chọn sử dụng C++:\n\n## Hiệu suất\nC ++ được thiết kế để cung cấp hiệu suất và hiệu quả cao. Nó cung cấp khả năng kiểm soát chi tiết đối với tài nguyên hệ thống, giúp tối ưu hóa phần mềm của bạn dễ dàng hơn.\n\n## Tính di động\nC++ được hỗ trợ trên các kiến trúc máy tính và hệ điều hành khác nhau, cho phép bạn viết mã code di động chạy trên nhiều nền tảng khác nhau mà không cần thực hiện các sửa đổi lớn.\n\n## Lập trình hướng đối tượng\nC++ hỗ trợ lập trình hướng đối tượng (OOP) - một mô hình cho phép bạn thiết kế chương trình bằng cách sử dụng các lớp và đối tượng, dẫn đến khả năng sử dụng lại và tổ chức mã code tốt hơn.\n\n```cpp\n\nclass MyClass {\n    public:\n        void myFunction() {\n            // mã Code ở đây\n        }\n};\n\nint main() {\n    MyClass obj;\n    obj.myFunction();\n}\n\n```\n\n## Hỗ trợ lập trình cấp thấp và cấp cao\nC++ cho phép bạn viết cả mã code cấp thấp, như thao tác bộ nhớ, cũng như mã code trừu tượng, như tạo lớp và sử dụng Thư viện mẫu tiêu chuẩn (STL).\n\n```cpp\n\n#include <iostream>\n#include <vector>\n\nint main() {\n    // Lập trình cấp thấp\n    int number = 42;\n    int* ptr_number = &number;\n\n    // Lập trình cấp cao\n    std::vector<int> myVector = {1, 2, 3};\n    for(const auto &i: myVector) {\n        std::cout << i << std::endl;\n    }\n}\n\n```\n\n## Thư viện mở rộng\nC++ cung cấp nhiều loại thư viện và công cụ, chẳng hạn như Thư viện mẫu tiêu chuẩn (STL), Boost và Qt giữa những thư viện khác, có thể hỗ trợ phát triển dự án của bạn và làm cho dự án hiệu quả hơn.\n\n## Kết hợp với ngôn ngữ C\nC++ có thể được kết hợp với C, cung cấp khả năng của cả hai ngôn ngữ và cho phép bạn sử dụng lại mã C hiện có của mình. Bằng cách kết hợp các tính năng của C++, bạn có thể nâng cao mã của mình và cải thiện chức năng của nó.\n\n## Cộng đồng tích cực\nC++ đã xuất hiện từ lâu và có một cộng đồng người dùng lớn, tích cực, những người đóng góp vào sự phát triển của ngôn ngữ, thể hiện những ý tưởng mới và tham gia vào các cuộc thảo luận giúp phát triển ngôn ngữ hơn nữa. Điều này làm cho việc tìm giải pháp cho bất kỳ vấn đề nào bạn gặp phải dễ dàng hơn nhiều.\n\nTóm lại, C++ cung cấp một sự cân bằng tuyệt vời về hiệu suất, tính di động và bộ tính năng, làm cho nó trở thành ngôn ngữ lập trình linh hoạt và mạnh mẽ phù hợp với nhiều ứng dụng. Với các thư viện phong phú, cộng đồng tích cực và sự phát triển liên tục, C++ là một lựa chọn tuyệt vời cho bất kỳ dự án phát triển phần mềm nào."
                },
                {
                    "author": "Dev Alex",
                    "title": " C vs C++",
                    "param": "chap-0-3",
                    "level": "beginner",
                    "code": "# C vs C++\nC và C++ là hai ngôn ngữ lập trình phổ biến với một số điểm tương đồng, nhưng chúng cũng có những điểm khác biệt chính. C++ là phần mở rộng của ngôn ngữ lập trình C, với các tính năng bổ sung như lập trình hướng đối tượng, lớp và xử lý ngoại lệ. Mặc dù cả hai ngôn ngữ đều được sử dụng cho các nhiệm vụ tương tự nhau, nhưng chúng có cú pháp và ngữ nghĩa riêng khiến chúng khác biệt với nhau.\n\n## Cú pháp và ngữ nghĩa\n\n## C\n- C là một ngôn ngữ lập trình thủ tục.\n- Tập trung vào các hàm và lập trình cấu trúc.\n- Không hỗ trợ đối tượng hoặc lớp.\n- Quản lý bộ nhớ thủ công, sử dụng các hàm như malloc và free.\n\n```cpp\n\n#include <stdio.h>\nvoid printHello() {\n    printf(\"Hello, World!\\n\");\n}\nint main() {\n    printHello();\n    return 0;\n}\n\n```\n\n## C++\n- C++ vừa hướng thủ tục vừa hướng đối tượng.\n- Hỗ trợ cả hàm và lớp.\n- Kết hợp các mô hình lập trình khác nhau.\n- Quản lý bộ nhớ có thể là thủ công (như C) hoặc dựa vào hàm tạo/hàm hủy và con trỏ thông minh.\n\n```cpp\n\n#include <iostream>\nclass HelloWorld {\npublic:\n    void printHello() {\n        std::cout << \"Hello, World!\" << std::endl;\n    }\n};\nint main() {\n    HelloWorld obj;\n    obj.printHello();\n    return 0;\n}\n\n```\n\n## Khả năng sử dụng lại mã code và tính mô đun\n\n## C\n- Khả năng sử dụng lại mã code đạt được thông qua các hàm và lập trình mô-đun.\n- Độ gắn kết cao và khớp nối thấp đạt được thông qua thiết kế có cấu trúc.\n- Các thư viện hàm có thể được tạo và đưa vào thông qua các tiêu đề.\n\n## C++\n- Cung cấp khả năng sử dụng lại mã code tốt hơn với các lớp, kế thừa và đa hình.\n- Tính mô đun của mã code được tăng cường thông qua các không gian tên và hệ thống phân cấp hướng đối tượng được thiết kế tốt.\n\n## Xử lý lỗi\n\n## C\n- Xử lý lỗi trong C được thực hiện chủ yếu thông qua mã trả về.\n- Thiếu hỗ trợ cho các ngoại lệ hoặc bất kỳ cơ chế xử lý lỗi tích hợp nào.\n\n## C++\n- Cung cấp khả năng xử lý ngoại lệ, có thể được sử dụng để xử lý các lỗi có thể xảy ra trong quá trình thực thi chương trình.\n- Cho phép nắm bắt và xử lý các trường hợp ngoại lệ với các từ khóa try, catch và throw, cung cấp nhiều quyền kiểm soát hơn đối với việc xử lý lỗi.\n\n## Phần kết luận\nCả C và C++ đều là những ngôn ngữ mạnh mẽ với các tính năng và khả năng độc đáo. Trong khi C đơn giản hơn và tập trung vào lập trình thủ tục, C++ cung cấp tính linh hoạt của việc sử dụng các mô hình lập trình khác nhau và tổ chức mã code được cải thiện.\n\nHiểu được sự khác biệt giữa hai ngôn ngữ này có thể giúp bạn quyết định ngôn ngữ nào phù hợp hơn với nhu cầu cụ thể và phong cách lập trình của bạn."
                }
            ]
        },
        {
            "title": "Chương 2 Cài đặt môi trường",
            "param": "chap-1-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " Cài đặt C++",
                    "param": "chap-1-0",
                    "level": "beginner",
                    "code": "# Cài đặt C++\nViệc cài đặt C++ yêu cầu một số bước, bao gồm cài đặt trình biên dịch, định cấu hình Môi trường phát triển tích hợp (IDE) và tạo một dự án C++ mới.\n\n## Cài đặt trình biên dịch\nCần có trình biên dịch để chuyển mã code C++ sang ngôn ngữ máy. Một số trình biên dịch C++ phổ biến bao gồm:\n- GCC (Bộ sưu tập trình biên dịch GNU) cho Linux và macOS\n- MinGW (GNU tối giản cho Windows) cho Windows\n- Microsoft Visual C ++ cho Windows\n  \nĐể cài đặt trình biên dịch, chỉ cần làm theo hướng dẫn được cung cấp bởi các trang web tương ứng.\n\n## Cấu hình một IDE\nIDE là một ứng dụng phần mềm cung cấp các phương tiện để lập trình, chẳng hạn như chỉnh sửa mã code, gỡ lỗi và xây dựng. Một số IDE C++ phổ biến bao gồm:\n- Visual Studio (Windows, macOS)\n- Eclipse (Windows, macOS, Linux)\n- Mã Code::Blocks (Windows, macOS, Linux)\n  \nSau khi tải xuống và cài đặt một IDE, bạn có thể cần định cấu hình nó để sử dụng trình biên dịch đã cài đặt. Kiểm tra tài liệu của IDE tương ứng để biết hướng dẫn về cách thực hiện việc này.\n\n## Tạo một dự án C++ mới\nKhi bạn đã thiết lập IDE và trình biên dịch, bạn có thể tạo một dự án C++ mới và bắt đầu viết mã code. Nói chung, hãy làm theo các bước sau để tạo một dự án C++ mới:\n- Mở IDE và tạo một dự án mới.\n- Chọn loại dự án (Ứng dụng C++ hoặc Ứng dụng bảng điều khiển).\n- Chỉ định tên dự án và vị trí.\n- Hãy để IDE tạo các tệp main.cpp và xây dựng (chẳng hạn như Makefile hoặc CMakeLists.txt) cho bạn.\n\n## Ví dụ: Hello World in C++\nTạo một tệp mới có tên main.cpp trong dự án của bạn và bao gồm mã này:\n\n```cpp\n\n#include <iostream>\n\nint main() {\n    std::cout << \"Hello, World!\" << std::endl;\n    return 0;\n}\n\n```\nSau đó, làm theo hướng dẫn của IDE để xây dựng và chạy chương trình của bạn. Bạn sẽ thấy “Hello, world!” hiển thị trong bảng điều khiển.\n\n##  Tóm tắt\nCài đặt C++ bao gồm:\n- Cài đặt trình biên dịch (ví dụ: GCC, MinGW hoặc MSVC)\n- Định cấu hình IDE (ví dụ: Visual Studio, Eclipse hoặc mã Code::Blocks)\n- Tạo một dự án C++ mới và viết mã code\n  \nBằng cách làm theo các bước này, bạn sẽ sẵn sàng bắt đầu phát triển các ứng dụng C++!"
                },
                {
                    "author": "Dev Alex",
                    "title": " Chương trình đầu tiên trong C++",
                    "param": "chap-1-1",
                    "level": "beginner",
                    "code": "# Chương trình đầu tiên trong C++\nTrong phần này, chúng ta sẽ thảo luận về cấu trúc cơ bản của một chương trình C++, hướng dẫn bạn qua chương trình đầu tiên của bạn (ví dụ “Hello, world!”) và cung cấp các giải thích bổ sung về cú pháp của nó.\n\n## Hello world!\nChương trình đầu tiên mà hầu hết mọi người học viết bằng bất kỳ ngôn ngữ lập trình nào thường là một chương trình đơn giản hiển thị thông báo “Hello, world!” trên màn hình. Đây là trương chình “Hello, world!” cổ điển trong C++:\n\n```cpp\n\n#include <iostream>\n\nint main() {\n  std::cout << \"Hello, World!\" << std::endl;\n  return 0;\n}\n\n```\nHãy chia nhỏ các thành phần khác nhau của chương trình này:\n\n## File header & Chỉ thị tiền xử lý\nDòng đầu tiên của chương trình #include <iostream> là một chỉ thị tiền xử lý yêu cầu trình biên dịch bao hàm file header iostream. Các file header cung cấp các khai báo hàm và lớp mà chúng ta có thể sử dụng trong các chương trình C++ của mình.\n\n```cpp\n\n#include <iostream>\n\n```\n\n## Hàm main()\nTrong C++, hàm main() đóng vai trò là điểm vào của chương trình của bạn. Hệ điều hành chạy chương trình của bạn bằng cách gọi hàm main() này. Nó chỉ được xác định một lần trong chương trình của bạn và phải trả về một số nguyên.\n\n```cpp\n\nint main() {\n  // Mã code ở đây.\n}\n\n```\n\n## Xuất ra bảng điều khiển\nĐể xuất văn bản ra bảng điều khiển, chúng ta sử dụng đối tượng std::cout và toán tử chèn <<. Trong \"Hello, world!\" ví dụ, chúng tôi đã sử dụng dòng sau để in “Hello, world!” đến bảng điều khiển:\n\n```cpp\n\nstd::cout << \"Hello, World!\" << std::endl;\n\n```\n- std::cout: Luồng \"đầu ra ký tự\" tiêu chuẩn ghi vào bảng điều khiển\n- \"Hello, World!\": Chuỗi ký tự để in\n- std::endl: Trình điều khiển “dòng kết thúc” chèn một ký tự xuống dòng và xóa bộ đệm đầu ra\n\n## Câu lệnh return\nCuối cùng, return 0; câu lệnh thông báo cho hệ điều hành rằng chương trình đã thực hiện thành công. Trả về bất kỳ giá trị số nguyên nào khác cho biết đã xảy ra lỗi:\n\n```cpp\n\nreturn 0;\n\n```\nBây giờ bạn đã hiểu các thành phần cơ bản của một chương trình C++, bạn có thể viết chương trình đầu tiên của mình, biên dịch nó và chạy nó để xem thông báo “Hello, world!” thông báo hiển thị trên màn hình."
                },
                {
                    "author": "Dev Alex",
                    "title": " Trình chỉnh sửa mã code",
                    "param": "chap-1-2",
                    "level": "beginner",
                    "code": "# Trình chỉnh sửa mã code\nTrình chỉnh sửa mã code là các chương trình được thiết kế đặc biệt để chỉnh sửa, quản lý và viết mã code nguồn. Chúng cung cấp một loạt các tính năng giúp quá trình phát triển dễ dàng và nhanh hơn. Dưới đây là phần giới thiệu ngắn gọn về một số trình soạn thảo mã code phổ biến nhất cho C++:\n- **Visual Studio Code (VSCode):** Visual Studio Code là trình soạn thảo mã code nhẹ nhàng, miễn phí, mã nguồn mở và phổ biến do Microsoft phát triển. Nó có hỗ trợ tích hợp sẵn cho C++, cùng với một thư viện mở rộng và plugin phong phú.\n- **Sublime Text:** Sublime Text là trình soạn thảo văn bản đa nền tảng khá phổ biến đối với các nhà phát triển do tốc độ và thiết kế tối giản. Nó hỗ trợ C++ với sự trợ giúp của các plugin và có nhiều chủ đề và gói có sẵn để tùy chỉnh.\n- **CLion:** CLion là một Môi trường Phát triển Tích hợp (IDE) do JetBrains phát triển dành riêng cho các nhà phát triển C và C++. Nó cung cấp các tính năng nâng cao như hoàn thành mã, hỗ trợ tái cấu trúc, gỡ lỗi, v.v.\n\nĐây chỉ là một vài ví dụ và có rất nhiều trình soạn thảo mã code khác có sẵn, bao gồm Atom, Notepad++ và Geany. Tất cả chúng đều có các tính năng của chúng và có thể phù hợp với nhu cầu của các nhà phát triển khác nhau. Tìm trình chỉnh sửa mã code phù hợp thường là vấn đề sở thích cá nhân và quy trình làm việc.\n\nĐể làm việc với C++ trong trình soạn thảo mã code đã chọn, bạn thường cần cài đặt một số công cụ và tiện ích bổ sung, chẳng hạn như trình biên dịch, linters và hỗ trợ trình gỡ lỗi. Đảm bảo làm theo hướng dẫn do tài liệu của người biên tập cung cấp để thiết lập C++ đúng cách.\n"
                },
                {
                    "author": "Dev Alex",
                    "title": " Cài đặt C++",
                    "param": "chap-1-3",
                    "level": "beginner",
                    "code": "# Cài đặt C++\nTrước khi bạn có thể bắt đầu lập trình bằng C++, bạn cần cài đặt một trình biên dịch trên hệ thống của mình. Trình biên dịch là một chương trình chuyển đổi mã code C++ mà bạn viết thành tệp thực thi mà máy tính của bạn có thể chạy. Có một số trình biên dịch C++ phổ biến để lựa chọn, tùy thuộc vào hệ điều hành và sở thích của bạn.\n\n## Windows\nĐối với Windows, một tùy chọn phổ biến là cài đặt Microsoft Visual Studio IDE, bao gồm trình biên dịch Microsoft Visual C++.\nNgoài ra, bạn cũng có thể cài đặt trình biên dịch MinGW-w64, đây là cổng Windows của tập hợp trình biên dịch GNU (GCC). Để cài đặt MinGW-w64, hãy làm theo các bước sau:\n- Tải xuống trình cài đặt từ đây.\n- Chạy trình cài đặt và chọn cấu trúc, phiên bản và vị trí cài đặt mong muốn của bạn.\n- Thêm thư mục bin bên trong thư mục cài đặt vào biến môi trường PATH của hệ thống.\n\n## Hệ điều hành macOS\nĐối với macOS, bạn có thể cài đặt trình biên dịch clang LLVM của Apple, đây là một phần của Công cụ dòng lệnh Xcode. Để làm điều này, hãy mở một thiết bị đầu cuối và nhập:\n\n```cpp\n\nxcode-select --install\n\n```\nThao tác này sẽ nhắc hộp thoại cài đặt Công cụ dòng lệnh, bao gồm trình biên dịch clang.\n\n## Linux\nTrên Linux, bạn có thể cài đặt Bộ sưu tập trình biên dịch GNU (GCC) thông qua trình quản lý gói của bản phân phối. Dưới đây là một số ví dụ về các bản phân phối Linux phổ biến:\n- Ubuntu, Debian và các dẫn xuất:\n\n```cpp\n\nsudo apt-get install g++ build-essential\n\n```\n- Fedora, CentOS, RHEL và các dẫn xuất:\n\n```cpp\n\nsudo dnf install gcc-c++ make\n\n```\n- Arch Linux và các dẫn xuất:\n\n```cpp\n\nsudo pacman -S gcc make\n\n```\n\n## Kiểm tra cài đặt\nĐể xác nhận rằng trình biên dịch đã được cài đặt và có sẵn trên hệ thống của bạn, hãy mở dấu nhắc lệnh/thiết bị đầu cuối và nhập lệnh sau:\n\n```cpp\n\ng++ --version\n\n```\nBạn sẽ thấy đầu ra hiển thị phiên bản của trình biên dịch C++ đã cài đặt.\nBây giờ bạn đã sẵn sàng bắt đầu viết và biên dịch mã code C++ của mình!\n"
                }
            ]
        },
        {
            "title": "Chương 3 Toán tử",
            "param": "chap-2-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " Các thao tác cơ bản trong C++",
                    "param": "chap-2-0",
                    "level": "beginner",
                    "code": "# Các thao tác cơ bản trong C++\nCác phép toán cơ bản trong C++ đề cập đến các phép toán số học, quan hệ và logic cơ bản có thể được thực hiện bằng ngôn ngữ lập trình C++, vốn rất cần thiết cho bất kỳ loại chương trình hoặc tính toán nào trong tình huống thực tế.\nDưới đây là tóm tắt các thao tác cơ bản trong C++\n\n## Các phép tính toán học\nCác thao tác này được sử dụng để thực hiện các phép tính trong C++ và bao gồm:\n- Phép cộng (+): Thêm hai số. \n\n```cpp\n\nint a = 5;\nint b = 6;\nint sum = a + b; // Tổng là 11\n\n```\n- Phép trừ (-): Trừ một số cho số kia.\n\n```cpp\n\nint a = 10;\nint b = 6;\nint diff = a - b; // chênh lệch là 4\n\n```\n- Phép nhân (*): Nhân hai số.\n\n```cpp\n\nint a = 3;\nint b = 4;\nint product = a * b; // Kết quả là 12\n\n```\n- Phép chia (/): Chia một số cho một số khác, mang lại thương số.\n\n```cpp\n\nint a = 12;\nint b = 4;\nint quotient = a / b; // Thương là 3\n\n```\n- Mô đun (%): Chia một số cho một số khác, mang lại phần còn lại.\n\n```cpp\n\nint a = 15;\nint b = 4;\nint remainder = a % b; // Số dư là 3\n\n```\n\n## Toán tử quan hệ\nCác thao tác này so sánh hai giá trị và trả về giá trị boolean (true/false) tùy thuộc vào phép so sánh. Các toán tử quan hệ là:\n- Bằng (==): Trả về giá trị đúng nếu cả hai toán hạng đều bằng nhau.\n\n```cpp\n\n5 == 5 // đúng\n3 == 4 // sai\n\n```\n- Không bằng (!=): Trả về true nếu các toán hạng không bằng nhau.\n\n```cpp\n\n5 != 2 // đúng\n1 != 1 // sai\n\n```\n- Lớn hơn (>): Trả về true nếu toán hạng thứ nhất lớn hơn toán hạng thứ hai.\n\n```cpp\n\n5 > 3 // đúng\n2 > 3 // sai\n\n```\n- Nhỏ hơn (<): Trả về true nếu toán hạng đầu tiên nhỏ hơn toán hạng thứ hai.\n\n```cpp\n\n3 < 5 // đúng\n6 < 5 // sai\n\n```\n- Lớn hơn hoặc bằng (>=): Trả về true nếu toán hạng thứ nhất lớn hơn hoặc bằng toán hạng thứ hai.\n\n```cpp\n\n5 >= 5 // đúng\n6 >= 2 // đúng\n3 >= 4 // sai\n\n```\n- Nhỏ hơn hoặc bằng (<=): Trả về true nếu toán hạng thứ nhất nhỏ hơn hoặc bằng toán hạng thứ hai.\n\n```cpp\n\n4 <= 4 // đúng\n2 <= 3 // đúng\n5 <= 4 // sai\n\n```\n\n## Toán tử logic\nToán tử logic được sử dụng để kết hợp nhiều điều kiện hoặc giá trị boolean.\n- AND (&&): Trả về true nếu cả hai toán hạng đều true.\n\n```cpp\n\ntrue && true // đúng\ntrue && false // sai\n\n```\n- OR (||): Trả về true nếu bất kỳ một trong các toán hạng là true.\n\n```cpp\n\ntrue || false // đúng\nfalse || false // sai\n\n```\n- NOT (!): Trả về true nếu toán hạng là false và ngược lại.\n\n```cpp\n\n!true // sai\n!false // đúng\n\n```"
                },
                {
                    "author": "Dev Alex",
                    "title": " Toán tử bitwise",
                    "param": "chap-2-1",
                    "level": "beginner",
                    "code": "# Toán tử bitwise\nPhép toán thao tác bit là các hoạt động thao tác trực tiếp các bit của một số. Toán tử bitwise hữu ích cho các mục đích khác nhau, chẳng hạn như tối ưu hóa thuật toán, thực hiện các phép tính nhất định và thao tác bộ nhớ trong các ngôn ngữ lập trình cấp thấp hơn như C và C++.\nDưới đây là tóm tắt nhanh về các thao tác bitwise phổ biến trong C++:\n\n## Bitwise VÀ (‘&’)\nPhép toán AND theo bit (&) là phép toán nhị phân lấy hai số, so sánh chúng từng bit và trả về một số mới trong đó mỗi bit được đặt (1) nếu các bit tương ứng trong cả hai số đầu vào được đặt (1); mặt khác, bit không được đặt (0).\nVí dụ:\n\n```cpp\n\nint result = 5 & 3; // kết quả là 1 (0000 0101 & 0000 0011 = 0000 0001)\n\n```\n\n## Bitwise HOẶC (|)\nPhép toán OR theo bit (|) là phép toán nhị phân lấy hai số, so sánh chúng từng bit và trả về một số mới trong đó mỗi bit được đặt (1) nếu ít nhất một trong các bit tương ứng trong một trong hai số đầu vào được đặt (1); mặt khác, bit không được đặt (0).\nVí dụ:\n\n```cpp\n\nint result = 5 | 3; // result will be 7 (0000 0101 | 0000 0011 = 0000 0111)\n\n```\n\n## Bitwise XOR (^)\nPhép toán XOR theo bit (OR loại từ) (^) là phép toán nhị phân lấy hai số, so sánh chúng từng bit và trả về một số mới trong đó mỗi bit được đặt (1) nếu các bit tương ứng trong các số đầu vào khác nhau; mặt khác, bit không được đặt (0).\nVí dụ:\n\n```cpp\n\nint result = 5 ^ 3; // result will be 6 (0000 0101 ^ 0000 0011 = 0000 0110)\n\n```\n\n## Bitwise NOT (~)\nPhép toán NOT theo chiều bit (~) là phép toán đơn nguyên lấy một số duy nhất và trả về một số mới trong đó mỗi bit được đảo ngược (1 trở thành 0 và 0 trở thành 1).\nVí dụ:\n\n```cpp\n\nint result = ~5; // kết quả là -6 (1111 1010)\n\n```\n\n## Bitwise shift trái (<<)\nHoạt động dịch chuyển trái theo chiều bit (<<) là một hoạt động nhị phân lấy hai số, một giá trị và một lượng dịch chuyển, đồng thời trả về một số mới bằng cách dịch chuyển các bit của giá trị sang trái theo lượng dịch chuyển đã chỉ định. Các bit trống được lấp đầy bằng số không.\n\nVí dụ:\n\n```cpp\n\nint result = 5 << 1; // kết quả là 10 (0000 0101 << 1 = 0000 1010)\n\n```\n\n## Bitwise shift phải (>>)\nThao tác dịch chuyển phải theo chiều bit (>>) là một thao tác nhị phân lấy hai số, một giá trị và một lượng dịch chuyển, đồng thời trả về một số mới bằng cách dịch chuyển các bit của giá trị sang phải theo lượng dịch chuyển đã chỉ định. Các bit bị bỏ trống được lấp đầy bằng số 0 hoặc bit dấu tùy thuộc vào giá trị đầu vào được ký hoặc không dấu.\n\nVí dụ:\n\n```cpp\n\nint result = 5 >> 1; // kết quả là 2 (0000 0101 >> 1 = 0000 0010)\n\n```\nĐây là những hoạt động bitwise phổ biến nhất trong C++. Hãy nhớ sử dụng chúng một cách cẩn thận và hiểu hành vi của chúng khi áp dụng cho các loại dữ liệu và tình huống cụ thể.\n"
                },
                {
                    "author": "Dev Alex",
                    "title": " Vòng lặp trong C++ ",
                    "param": "chap-2-2",
                    "level": "beginner",
                    "code": "# Vòng lặp trong C++ \nVòng lặp là một khái niệm thiết yếu trong lập trình cho phép bạn thực thi lặp đi lặp lại một khối mã cho đến khi đáp ứng một điều kiện cụ thể. Trong C++, có ba loại vòng lặp chính: for, while và do-while.\n\n##  Vòng lặp For\nVòng lặp for được sử dụng khi bạn biết số lần bạn muốn duyệt qua một khối code. Nó bao gồm một câu lệnh khởi tạo, một điều kiện và một phép toán tăng/giảm.\n\nĐây là cú pháp cho vòng lặp for:\n\n```cpp\n\nfor (initialization; condition; increment/decrement) {\n    // khối mã code để thực thi\n}\n\n```\nVí dụ:\n\n```cpp\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    for (int i = 0; i < 5; i++) {\n        cout << \"Iteration: \" << i << endl;\n    }\n    return 0;\n}\n\n```\n\n## Vòng lặp While\nMột vòng lặp while chạy miễn là một điều kiện được chỉ định là True. Vòng lặp kiểm tra điều kiện trước khi vào phần thân của vòng lặp.\n\nĐây là cú pháp của vòng lặp while:\n\n```cpp\n\nwhile (condition) {\n    // khối mã code để thực thi\n}\n\n```\nVí dụ:\n\n```cpp\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int i = 0;\n    while (i < 5) {\n        cout << \"Iteration: \" << i << endl;\n        i++;\n    }\n    return 0;\n}\n\n```\n\n## Vòng lặp Do-While\nVòng lặp do-while tương tự như vòng lặp while, với điểm khác biệt chính là thân vòng lặp được thực hiện ít nhất một lần, ngay cả khi điều kiện false.\n\nĐây là cú pháp của vòng lặp do-while:\n\n```cpp\n\ndo {\n    // khối mã code để thực thi\n} while (condition);\n\n```\nVí dụ:\n\n```cpp\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int i = 0;\n    do {\n        cout << \"Iteration: \" << i << endl;\n        i++;\n    } while (i < 5);\n    return 0;\n}\n\n```\nTóm lại, các vòng lặp là một phần không thể thiếu trong lập trình C++ cho phép bạn thực thi một khối mã code nhiều lần. Ba loại vòng lặp trong C++ là for, while và do-while. Mỗi loại có trường hợp sử dụng cụ thể của riêng nó và có thể được chọn tùy thuộc vào hành vi mong muốn. \n"
                },
                {
                    "author": "Dev Alex",
                    "title": " Toán tử logic trong C++",
                    "param": "chap-2-3",
                    "level": "beginner",
                    "code": "# Toán tử logic trong C++\nCác toán tử logic được sử dụng để thực hiện các phép toán logic trên các biểu thức đã cho, chủ yếu để kiểm tra mối quan hệ giữa các biến hoặc giá trị khác nhau. Chúng trả về một giá trị boolean tức là đúng (1) hoặc sai (0) dựa trên kết quả đánh giá.\nC++ cung cấp các toán tử logic sau:\n- **Toán tử AND (&&):**  Toán tử AND kiểm tra nếu cả hai toán hạng/điều kiện đều đúng, thì biểu thức là đúng. Nếu bất kỳ một trong các điều kiện là sai, toàn bộ biểu thức sẽ sai.\n\n```cpp\n\n(expression1 && expression2)\n\n```\nVí dụ:\n\n```cpp\n\nint a = 5, b = 10;\nif (a > 0 && b > 0) {\n    cout << \"Both values are positive.\" << endl;\n}\n\n```\n- **Toán tử OR (||):**  Toán tử OR kiểm tra nếu một trong hai toán hạng/điều kiện là đúng, thì biểu thức là đúng. Nếu cả hai điều kiện là sai, nó sẽ sai.\n\n```cpp\n\n(expression1 || expression2)\n\n```\nVí dụ: \n\n```cpp\n\nint a = 5, b = -10;\nif (a > 0 || b > 0) {\n    cout << \"At least one value is positive.\" << endl;\n}\n\n```\n- **Toán tử NOT (!):**  Toán tử NOT đảo ngược kết quả của điều kiện/biểu thức mà nó được áp dụng. Nếu điều kiện là đúng, toán tử NOT sẽ biến nó thành sai và ngược lại.\n\n```cpp\n\n!(expression)\n\n```\nVí dụ: \n\n```cpp\n\nint a = 5;\nif (!(a < 0)) {\n    cout << \"The value is not negative.\" << endl;\n}\n\n```\nSử dụng các toán tử này, bạn có thể tạo các biểu thức logic phức tạp hơn, ví dụ:\n\n```cpp\n\nint a = 5, b = -10, c = 15;\n\nif (a > 0 && (b > 0 || c > 0)) {\n    cout << \"At least two values are positive.\" << endl;\n}\n\n```\nTrên đây bao gồm các thông tin cần thiết về các toán tử logic trong C++."
                },
                {
                    "author": "Dev Alex",
                    "title": " Toán tử số học trong C++",
                    "param": "chap-2-4",
                    "level": "beginner",
                    "code": "# Toán tử số học trong C++\nCác toán tử số học được sử dụng để thực hiện các phép toán với các biến cơ bản như số nguyên và số dấu phẩy động. Dưới đây là tóm tắt ngắn gọn về các toán tử số học khác nhau trong C++:\n\n## 1. Toán tử cộng (+)\nNó cộng hai số lại với nhau.\n\n```cpp\n\nint sum = a + b;\n\n```\n\n## 2. Toán tử trừ (-)\nNó trừ một số từ một số khác.\n\n```cpp\n\nint difference = a - b;\n\n```\n\n## 3. Toán tử nhân (*)\nNó nhân hai số với nhau.\n\n```cpp\n\nint product = a * b;\n\n```\n\n## 4. Toán tử bộ phận (/)\nNó chia một số cho một số khác. Lưu ý rằng nếu cả hai toán hạng đều là số nguyên, nó sẽ thực hiện phép chia số nguyên và kết quả sẽ là một số nguyên.\n\n```cpp\n\nint quotient = a / b; // phép chia số nguyên\nfloat quotient = float(a) / float(b); // Phép chia dấu chấm động\n\n```\n\n## 5. Toán tử mô đun (%)\nNó tính toán phần còn lại của một phép chia số nguyên.\n\n```cpp\n\nint remainder = a % b;\n\n```\n\n## 6. Toán tử tăng (++)\nNó tăng giá trị của một biến lên 1. Có hai cách để sử dụng toán tử này: tiền tố (++x) và hậu tố (x++). Tiền tố tăng giá trị trước khi trả lại giá trị đó, trong khi hậu tố trả về giá trị trước rồi mới tăng giá trị đó.\n\n```cpp\n\nint x = 5;\nint y = ++x; // x = 6, y = 6\nint z = x++; // x = 7, z = 6\n\n```\n\n## 7. Toán tử giảm (--)\nNó giảm giá trị của một biến đi 1. Nó cũng có thể được sử dụng ở dạng tiền tố (--x) và hậu tố (x--).\n\n```cpp\n\nint x = 5;\nint y = --x; // x = 4, y = 4\nint z = x--; // x = 3, z = 4\n\n```\nĐây là những toán tử số học cơ bản trong C++ cho phép bạn thực hiện các phép toán trên các biến của mình. Sử dụng chúng kết hợp với các cấu trúc điều khiển khác, chẳng hạn như vòng lặp và điều kiện, để xây dựng các chương trình phức tạp hơn."
                }
            ]
        },
        {
            "title": "Chương 4 Hàm chức năng",
            "param": "chap-3-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " Hàm trong C++",
                    "param": "chap-3-0",
                    "level": "beginner",
                    "code": "# Hàm trong C++\nHàm là một nhóm các câu lệnh thực hiện một nhiệm vụ cụ thể, được tổ chức như một đơn vị riêng biệt trong một chương trình. Các hàm giúp chia mã code thành các khối nhỏ hơn, dễ quản lý và có thể tái sử dụng.\n\nChủ yếu có hai loại hàm trong C++:\n- **Các hàm thư viện chuẩn:**  Các hàm được xác định trước có sẵn trong thư viện chuẩn C++, chẳng hạn như printf(), scanf(), sqrt(), v.v. Các hàm này là một phần của thư viện tiêu chuẩn, vì vậy bạn cần thêm tệp tiêu đề thích hợp để sử dụng chúng.\n- **Các hàm do người dùng định nghĩa:**  Các hàm do người lập trình tạo ra để thực hiện một tác vụ cụ thể. Để tạo một hàm do người dùng xác định, bạn cần xác định hàm đó và gọi hàm đó trong mã code của mình.\n\n## Định nghĩa của một hàm\nĐịnh dạng chung để định nghĩa một hàm trong C++ là:\n\n```cpp\n\nreturn_type function_name(parameter list) {\n    // Hàm body\n}\n\n```\n- return_type: Kiểu dữ liệu của đầu ra do hàm tạo ra. Nó có thể bị void, cho biết rằng hàm không trả về bất kỳ giá trị nào.\n- function_name: Tên được đặt cho hàm, tuân theo các quy ước đặt tên của C++.\n- danh sách tham số: Danh sách các tham số/đối số đầu vào cần thiết để thực hiện tác vụ. Nó là tùy chọn và khi không cần tham số, bạn có thể để trống hoặc sử dụng từ khóa void.\n\n## Ví dụ\n\n```cpp\n\n#include <iostream>\nusing namespace std;\n\n// Hàm cộng hai số\nint addNumbers(int a, int b) {\n    int sum = a + b;\n    return sum;\n}\n\nint main() {\n    int num1 = 5, num2 = 10;\n    int result = addNumbers(num1, num2); // Gọi hàm\n    cout << \"The sum is: \" << result << endl;\n    return 0;\n}\n\n```\nTrong ví dụ này, hàm addNumbers nhận hai tham số số nguyên, a và b, rồi trả về tổng của các số. Sau đó chúng ta gọi hàm này từ hàm main() và hiển thị kết quả.\n\n## Hàm nguyên mẫu\nTrong một số trường hợp, bạn có thể muốn sử dụng một hàm trước khi thực sự định nghĩa nó. Để làm điều này, bạn cần khai báo một hàm nguyên mẫu ở đầu mã code của mình.\n\nMột hàm nguyên mẫu là một khai báo của hàm không có phần thân của nó và nó thông báo cho trình biên dịch về tên, kiểu trả về và các tham số của hàm.\n\n```cpp\n\n#include <iostream>\nusing namespace std;\n\n// Hàm nguyên mẫu\nint multiplyNumbers(int x, int y);\n\nint main() {\n    int num1 = 3, num2 = 7;\n    int result = multiplyNumbers(num1, num2); // gọi hàm\n    cout << \"The product is: \" << result << endl;\n    return 0;\n}\n\n// Định nghĩa hàm\nint multiplyNumbers(int x, int y) {\n    int product = x * y;\n    return product;\n}\n\n```\nTrong ví dụ này, chúng tôi sử dụng một hàm nguyên mẫu chomultipleNumbers() trước khi xác định nó. Bằng cách này, chúng ta có thể gọi hàm từ hàm main() mặc dù nó chưa được định nghĩa trong mã code."
                },
                {
                    "author": "Dev Alex",
                    "title": "  Hàm Lambda trong C++",
                    "param": "chap-3-1",
                    "level": "beginner",
                    "code": " # Hàm Lambda trong C++\nHàm lambda, hay đơn giản là “lambda”, là một hàm ẩn danh (chưa được đặt tên) được xác định tại chỗ, trong mã code nguồn của bạn và với một cú pháp ngắn gọn. Các hàm Lambda đã được giới thiệu trong C++11 và kể từ đó đã trở thành một tính năng được sử dụng rộng rãi, đặc biệt là khi kết hợp với các thuật toán Thư viện chuẩn.\n\n## Cú pháp\nĐây là cú pháp cơ bản của hàm lambda trong C++:\n\n```cpp\n\n[capture-list](parameters) -> return_type {\n    // hàm body\n};\n\n```\n- **danh sách lưu chữ trong bộ nhớ:**  Danh sách các biến từ phạm vi xung quanh mà hàm lambda có thể truy cập.\n- **tham số:**  Danh sách các tham số đầu vào, giống như trong một hàm thông thường. Không bắt buộc.\n- **return_type:**  Loại giá trị mà hàm lambda sẽ trả về. Phần này là tùy chọn và trình biên dịch có thể suy ra nó trong nhiều trường hợp.\n- **hàm body:**  Mã code xác định hoạt động của hàm lambda.\n\n## Ví dụ sử dụng\nDưới đây là một số ví dụ minh họa việc sử dụng các hàm lambda trong C++:\n- Hàm lambda không có kiểu lưu thông tin và bộ lưu trữ, tham số hoặc kiểu trả về.\n\n```cpp\n\nauto printHello = []() {\n    std::cout << \"Hello, World!\" << std::endl;\n};\nprintHello(); // đầu ra: Hello, World!\n\n```\n- Hàm lambda có tham số.\n\n```cpp\n\nauto add = [](int a, int b) {\n    return a + b;\n};\nint result = add(3, 4); // kết quả = 7\n\n```\n- Hàm lambda với tính năng nắm bắt theo giá trị.\n\n```cpp\n\nint multiplier = 3;\nauto times = [multiplier](int a) {\n    return a * multiplier;\n};\nint result = times(5); // kết quả = 15\n\n```\n- Hàm lambda với lưu chữ trong bộ nhớ theo tham chiếu.\n\n```cpp\n\nint expiresInDays = 45;\nauto updateDays = [&expiresInDays](int newDays) {\n    expiresInDays = newDays;\n};\nupdateDays(30); // ngày hết hạn = 30\n\n```\nLưu ý rằng, khi sử dụng lưu chữ trong bộ nhớ theo tham chiếu, bất kỳ thay đổi nào được thực hiện đối với biến được chụp bên trong hàm lambda sẽ ảnh hưởng đến giá trị của nó trong phạm vi xung quanh. "
                },
                {
                    "author": "Dev Alex",
                    "title": " Toán tử trong C++",
                    "param": "chap-3-2",
                    "level": "beginner",
                    "code": "# Toán tử trong C++\nToán tử trong C++ là các ký hiệu thực hiện các thao tác khác nhau trên dữ liệu, chẳng hạn như các phép toán số học, so sánh và logic. Chúng được sử dụng để thao tác và đánh giá các biểu thức và biến.\n\nDưới đây là danh sách các loại toán tử thường được sử dụng trong C++:\n- **Toán tử số học:** Chúng được sử dụng để thực hiện các phép toán số học như cộng, trừ, nhân và chia.\n  - +: phép cộng\n  \n```cpp\n\n  int sum = 5 + 3; // Tổng là 8\n  \n```\n\t- -: Phép trừ\n  \n```cpp\n\n  int difference = 5 - 3; // sự khác biệt sẽ là 2\n  \n```\n  - *: Phép nhân\n  \n```cpp\n\n  int product = 5 * 3; // kết quả là 15\n  \n```\n  - /: phép chia\n  \n```cpp\n\n  int quotient = 15 / 3; // thương là 5\n  \n```\n  - %: modulo (phần dư)\n  \n```cpp\n\n  int remainder = 7 % 3; // số dư là 1\n  \n```\n- **Toán tử so sánh (quan hệ):** Chúng được sử dụng để so sánh hai giá trị và trả về đúng hoặc sai dựa trên phép so sánh.\n  - ==: bằng\n  \n```cpp\n\n  bool isEqual = (5 == 3); // bằng sẽ là sai\n  \n```\n\t- !=: không bằng\n  \n```cpp\n\n  bool isNotEqual = (5 != 3); // không bằng sẽ là đúng\n  \n```\n  - <: nhỏ hơn\n  \n```cpp\n\n  bool isLess = (5 < 3); // nhỏ hơn là sai\n  \n```\n  - >: lớn hơn\n  \n```cpp\n\n  bool isGreater = (5 > 3); // lớn hơn sẽ là đúng\n  \n```\n  - <=: nhỏ hơn hoặc bằng\n  \n```cpp\n\n  bool isLessOrEqual = (5 <= 3); // nhỏ hơn hoặc bằng là sai\n  \n```\n  - >=: lớn hơn hoặc bằng\n  \n```cpp\n\n  bool isGreaterOrEqual = (5 >= 3); // lớn hơn hoặc bằng sẽ là đúng\n  \n```\n- **Toán tử logic:** Các toán tử này được sử dụng để thực hiện các phép toán logic như AND (&&), OR (||) và NOT (!) trên các giá trị boolean.\n  - &&: logic AND\n  \n```cpp\n\n  bool result = (true && false); // kết quả sẽ là sai\n  \n```\n  - ||: logic OR\n  \n```cpp\n\n  bool result = (true || false); // kết quả sẽ là đúng\n  \n```\n  - !: logic NOT\n  \n```cpp\n\n  bool result = !false; // kết quả sẽ là đúng\n  \n```\n- **Toán tử gán:** Chúng được sử dụng để gán giá trị cho các biến.\n  - =: phép gán đơn giản\n  \n```cpp\n\n  int x = 5; // x nhận giá trị 5\n  \n```\n  - +=: phép cộng\n  \n```cpp\n\n  int x = 5;\n  x += 3; // x nhận giá trị 8 (5 + 3)\n  \n```\n  - -=: phép trừ\n  \n```cpp\n\n  int x = 5;\n  x -= 3; // x nhận giá trị 2 (5 - 3)\n  \n```\n  - *=: phép nhân\n  \n```cpp\n\n  int x = 5;\n  x *= 3; // x nhận giá trị 15 (5 * 3)\n  \n```\n  - /=: phép chia\n   \n```cpp\n\n  int x = 15;\n  x /= 3; // x nhận giá trị 5 (15 / 3)\n  \n```\n  - %=: phép gán modulo\n  \n```cpp\n\n  int x = 7;\n  x %= 3; // x nhận giá trị 1 (7 % 3)\n  \n```\nĐây là một số loại toán tử chính trong C++. Mỗi toán tử cho phép bạn thực hiện các thao tác cụ thể, giúp mã code của bạn hiệu quả và ngắn gọn hơn.\n"
                }
            ]
        },
        {
            "title": "Chương 5 Kiểu dữ liệu",
            "param": "chap-4-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " Kiểu dữ liệu trong C++",
                    "param": "chap-4-0",
                    "level": "beginner",
                    "code": "# Kiểu dữ liệu trong C++\nTrong C++, các kiểu dữ liệu được sử dụng để phân loại các loại dữ liệu khác nhau mà một chương trình có thể xử lý. Chúng rất cần thiết để xác định loại giá trị mà một biến có thể chứa và dung lượng bộ nhớ mà nó sẽ chiếm. Một số kiểu dữ liệu cơ bản trong C++ bao gồm số nguyên, số dấu chấm động, ký tự và kiểu dữ liệu booleans\n\n## Các kiểu dữ liệu cơ bản\n\n## Số nguyên (int)\nSố nguyên là số nguyên có thể lưu trữ cả giá trị dương và âm. Kích thước của int phụ thuộc vào cấu trúc hệ thống (thường là 4 byte).\n\nVí dụ:\n\n```cpp\n\nint num = 42;\n\n```\nCó các biến thể của int có thể chứa các dãy số khác nhau:\n- short (short int): Phạm vi nhỏ hơn int.\n- long(long int): Phạm vi lớn hơn int.\n- long long (long long int): Phạm vi thậm chí còn lớn hơn long int.\n\n## Dấu chấm động (float, double)\nCác loại dấu chấm động đại diện cho các số thực, tức là các số có dấu thập phân. Có hai loại dấu phẩy động chính:\n- float: Cung cấp các số dấu chấm động có độ chính xác đơn. Nó thường chiếm 4 byte bộ nhớ.\nVí dụ:\n \n```cpp\n\nfloat pi = 3.14f;\n\n```\n- double: Cung cấp các số dấu phẩy động có độ chính xác kép. Nó tiêu tốn nhiều bộ nhớ hơn (thường là 8 byte) nhưng có độ chính xác cao hơn float.\n- \nVí dụ:\n\n```cpp\n\ndouble pi_high_precision = 3.1415926535;\n\n```\n\n## Kí tự (char)\nCác ký tự đại diện cho một ký tự đơn lẻ, chẳng hạn như một chữ cái, chữ số hoặc ký hiệu. Chúng được lưu trữ bằng cách sử dụng giá trị ASCII của ký hiệu và thường chiếm 1 byte bộ nhớ.\n\nVí dụ:\n\n```cpp\n\nchar letter = 'A';\n\n```\n\n## Boolean (bool)\nBooleans đại diện cho các giá trị logic: true hoặc false. Chúng thường chiếm 1 byte bộ nhớ.\n\nVí dụ:\n\n```cpp\n\nbool is_cpp_great = true;\n\n```\n\n## Các kiểu dữ liệu dẫn xuất\nCác kiểu dữ liệu dẫn xuất là các kiểu bắt nguồn từ các kiểu dữ liệu cơ bản. Một số ví dụ bao gồm:\n\n## Mảng\nMảng được sử dụng để lưu trữ nhiều giá trị của cùng một kiểu dữ liệu trong các vị trí bộ nhớ liên tiếp.\n\nVí dụ:\n\n```cpp\n\nint numbers[5] = {1, 2, 3, 4, 5};\n\n```\n\n## Con trỏ\nCon trỏ được sử dụng để lưu trữ địa chỉ bộ nhớ của một biến.\n\nVí dụ:\n\n```cpp\n\nint num = 42;\nint* pNum = &num;\n\n```\n\n## Tham chiếu\nTham chiếu là một cách khác để chia sẻ vị trí bộ nhớ giữa các biến, cho phép bạn tạo bí danh cho một biến khác.\n\nVí dụ:\n\n```cpp\n\nint num = 42;\nint& numRef = num;\n\n```\n\n## Kiểu dữ liệu do người dùng định nghĩa\nCác kiểu dữ liệu do người dùng định nghĩa là các kiểu được người lập trình định nghĩa, chẳng hạn như cấu trúc, lớp và liên kết.\n\n## Cấu trúc (struct)\nCác cấu trúc được sử dụng để nhóm các biến thuộc các loại dữ liệu khác nhau dưới một tên duy nhất.\n\nVí dụ:\n\n```cpp\n\nstruct Person {\n    string name;\n    int age;\n    float height;\n};\nPerson p1 = {\"John Doe\", 30, 5.9};\n\n```\n\n## Lớp (class)\nLớp tương tự như các cấu trúc, nhưng chúng cũng có thể có các hàm thành viên và chỉ định truy cập.\n\nVí dụ:\n\n```cpp\n\nclass Person {\npublic:\n    string name;\n    int age;\n\n    void printInfo() {\n        cout << \"Name: \" << name << \", Age: \" << age << endl;\n    };\n};\n\nPerson p1;\np1.name = \"John Doe\";\np1.age = 30;\n\n```\n\n## Các liên kết (Union)\nCác liên kết được sử dụng để lưu trữ các loại dữ liệu khác nhau trong cùng một vị trí bộ nhớ.\n\nVí dụ:\n\n```cpp\n\nunion Data {\n    int num;\n    char letter;\n    float decimal;\n};\n\nData myData;\nmyData.num = 42;\n\n```"
                },
                {
                    "author": "Dev Alex",
                    "title": " Nhập tĩnh",
                    "param": "chap-4-1",
                    "level": "beginner",
                    "code": "# Nhập tĩnh\nTrong C++, kiểu nhập tĩnh có nghĩa là kiểu dữ liệu của một biến được xác định tại thời điểm biên dịch, trước khi chương trình được thực thi. Điều này có nghĩa là một biến chỉ có thể được sử dụng với dữ liệu thuộc một loại cụ thể và trình biên dịch đảm bảo rằng các thao tác được thực hiện với biến tương thích với loại của nó.\n\nC++ là một ngôn ngữ được nhập tĩnh, có nghĩa là nó sử dụng kiểu gõ tĩnh để xác định kiểu dữ liệu và thực hiện kiểm tra kiểu trong thời gian biên dịch. Điều này giúp đảm bảo cho an toàn kiểu và có thể ngăn ngừa một số loại lỗi xảy ra trong quá trình thực thi chương trình.\n\nĐây là một ví dụ mã code đơn giản để minh họa cách nhập tĩnh trong C++:\n\n```cpp\n\n#include <iostream>\n\nint main() {\n    int num = 42;        // 'num' được nhập tĩnh dưới dạng số nguyên\n    double pi = 3.14159; // 'pi' được nhập tĩnh dưới dạng double\n\n    num = pi; // Việc gán này sẽ gây ra lỗi thời gian biên dịch vì các kiểu không khớp\n\n    std::cout << \"The value of num is: \" << num << std::endl;\n    std::cout << \"The value of pi is: \" << pi << std::endl;\n\n    return 0;\n}\n\n```\nTrong đoạn mã code trên, biến num được nhập tĩnh dưới dạng int và pi được nhập tĩnh dưới dạng double. Nếu bạn cố gắng gán giá trị của pi cho num, bạn sẽ gặp lỗi thời gian biên dịch. Điều này là do hệ thống nhập tĩnh đảm bảo rằng các biến chỉ được sử dụng với các kiểu dữ liệu tương thích."
                },
                {
                    "author": "Dev Alex",
                    "title": " Dynamic Typing trong C++",
                    "param": "chap-4-2",
                    "level": "beginner",
                    "code": "# Dynamic Typing trong C++\nC++ được biết đến như một ngôn ngữ kiểu tĩnh, có nghĩa là kiểu dữ liệu của các biến của nó được xác định tại thời điểm biên dịch. Tuy nhiên, C++ cũng cung cấp các khái niệm để có một mức dynamic typing nhất định, nghĩa là xác định kiểu dữ liệu của các biến trong thời gian chạy.\n\nDưới đây là tổng quan ngắn gọn về hai cách để đạt được dynamic typing trong C++:\n\n## Con trỏ void*\nCon trỏ void* là một con trỏ chung có thể trỏ tới các đối tượng thuộc bất kỳ kiểu dữ liệu nào. Chúng có thể được sử dụng để lưu trữ một tham chiếu đến bất kỳ loại đối tượng nào mà không cần biết loại đối tượng cụ thể.\n\nVí dụ:\n\n```cpp\n\n#include <iostream>\n\nint main() {\n    int x = 42;\n    float y = 3.14f;\n    std::string z = \"Hello, world!\";\n\n    void* void_ptr;\n\n    void_ptr = &x;\n    std::cout << \"int value: \" << *(static_cast<int*>(void_ptr)) << std::endl;\n\n    void_ptr = &y;\n    std::cout << \"float value: \" << *(static_cast<float*>(void_ptr)) << std::endl;\n\n    void_ptr = &z;\n    std::cout << \"string value: \" << *(static_cast<std::string*>(void_ptr)) << std::endl;\n\n    return 0;\n}\n\n```\n\n## std::any (C++17)\nC++17 đã giới thiệu lớp std::any đại diện cho một vùng chứa an toàn kiểu tổng quát cho các giá trị đơn lẻ thuộc bất kỳ loại nào.\n\n```cpp\n\n#include <iostream>\n#include <any>\n\nint main() {\n    std::any any_value;\n\n    any_value = 42;\n    std::cout << \"int value: \" << std::any_cast<int>(any_value) << std::endl;\n\n    any_value = 3.14;\n    std::cout << \"double value: \" << std::any_cast<double>(any_value) << std::endl;\n\n    any_value = std::string(\"Hello, world!\");\n    std::cout << \"string value: \" << std::any_cast<std::string>(any_value) << std::endl;\n\n    return 0;\n}\n\n```\nVí dụ: Hãy nhớ rằng cả hai con trỏ void* và std::any đều có ý nghĩa về hiệu suất do việc kiểm tra và truyền kiểu bổ sung diễn ra trong thời gian chạy. Chúng nên được sử dụng cẩn thận và chỉ khi thực sự cần thiết."
                },
                {
                    "author": "Dev Alex",
                    "title": " Nhận dạng loại thời gian chạy (RTTI)",
                    "param": "chap-4-3",
                    "level": "beginner",
                    "code": "# Nhận dạng loại thời gian chạy (RTTI)\nNhận dạng loại thời gian chạy (RTTI) là một tính năng trong C++ cho phép bạn lấy thông tin loại của một đối tượng trong khi thực hiện chương trình. Điều này có thể hữu ích khi sử dụng kiểu nhập động, trong đó loại đối tượng có thể thay đổi khi chạy.\n\nCó hai cơ chế chính cho RTTI trong C++:\n- toán tử typeid\n- toán tử dynamic_cast\n\n## Toán tử typeid\ntypeid là một toán tử trả về một tham chiếu đến một đối tượng có kiểu std::type_info, chứa thông tin về kiểu của đối tượng. Nên thêm tệp tiêu đề <typeinfo> để sử dụng typeid.\n\nĐây là một ví dụ:\n\n```cpp\n\n#include <iostream>\n#include <typeinfo>\n\nclass Base { virtual void dummy() {} };\nclass Derived : public Base { /* ... */ };\n\nint main() {\n    Base* base_ptr = new Derived;\n\n    // Sử dụng typeid để lấy kiểu đối tượng\n    std::cout << \"Type: \" << typeid(*base_ptr).name() << '\\n';\n\n    delete base_ptr;\n    return 0;\n}\n\n```\n\n## Toán tử dynamic_cast\ndynamic_cast là một toán tử ép kiểu thực hiện kiểm tra kiểu trong thời gian chạy và hạ thấp một cách an toàn một con trỏ cơ sở hoặc tham chiếu đến một con trỏ hoặc tham chiếu dẫn xuất. Nó trả về giá trị null hoặc đưa ra một ngoại lệ bad_cast (nếu truyền tham chiếu) khi quá trình truyền không thành công.\n\nĐây là một ví dụ:\n\n```cpp\n\n#include <iostream>\n\nclass Base { virtual void dummy() {} };\nclass Derived1 : public Base { /* ... */ };\nclass Derived2 : public Base { /* ... */ };\n\nint main() {\n    Base* base_ptr = new Derived1;\n\n    // Sử dụng dynamic_cast để hạ thấp con trỏ một cách an toàn\n    Derived1* derived1_ptr = dynamic_cast<Derived1*>(base_ptr);\n    if (derived1_ptr) {\n        std::cout << \"Downcast to Derived1 successful\\n\";\n    }\n    else {\n        std::cout << \"Downcast to Derived1 failed\\n\";\n    }\n\n    Derived2* derived2_ptr = dynamic_cast<Derived2*>(base_ptr);\n    if (derived2_ptr) {\n        std::cout << \"Downcast to Derived2 successful\\n\";\n    }\n    else {\n        std::cout << \"Downcast to Derived2 failed\\n\";\n    }\n\n    delete base_ptr;\n    return 0;\n}\n\n```\nXin lưu ý rằng việc sử dụng RTTI có thể có một số chi phí hoạt động, vì nó yêu cầu lưu trữ và xử lý thông tin bổ sung do trình biên dịch tạo trong thời gian chạy."
                }
            ]
        },
        {
            "title": "Chương 6 Con trỏ, tham chiếu",
            "param": "chap-5-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " Con trỏ",
                    "param": "chap-5-0",
                    "level": "beginner",
                    "code": "# Con trỏ\nCon trỏ là một biến lưu địa chỉ bộ nhớ của một biến (hoặc hàm) khác. Nó trỏ đến vị trí của biến trong bộ nhớ và nó cho phép bạn truy cập hoặc sửa đổi giá trị một cách gián tiếp. Đây là một định dạng chung để khai báo một con trỏ:\n\n```cpp\n\ndataType *pointerName;\n\n```\n\n## Khởi tạo một con trỏ:\n\n```cpp\n\nint num = 10;\nint *ptr = &num;  // Con trỏ 'ptr' hiện trỏ đến địa chỉ bộ nhớ của 'num'\n\n```\n\n## Truy cập giá trị bằng con trỏ:\n\n```cpp\n\nint value = *ptr; // Giá trị hiện chứa giá trị của biến mà 'ptr' trỏ tới (tức là 10)\n\n```\n\n## Tham chiếu\nMột tham chiếu là bí danh cho một biến hiện có, nghĩa là nó là một tên khác cho cùng một vị trí bộ nhớ. Không giống như con trỏ, các tham chiếu không thể rỗng và chúng phải được khởi tạo khi chúng được khai báo. Khi một tham chiếu được khởi tạo, nó không thể thay đổi để tham chiếu đến một biến khác.\n\nĐây là một định dạng chung để khai báo một tham chiếu:\n\n```cpp\n\ndataType &referenceName = existingVariable;\n\n```\nVí dụ:\n\n```cpp\n\nint num = 10;\nint &ref = num; // Tham chiếu 'ref' hiện là bí danh của 'num'\n\n```\nSửa đổi giá trị của ref cũng sẽ sửa đổi giá trị của num vì chúng chia sẻ cùng một vị trí bộ nhớ.\n\n**Lưu ý:** Tham chiếu thường được sử dụng khi bạn muốn truyền một biến bằng tham chiếu trong các đối số của hàm hoặc khi bạn muốn tạo bí danh cho một biến mà không cần cú pháp con trỏ. "
                },
                {
                    "author": "Dev Alex",
                    "title": " Tham chiếu",
                    "param": "chap-5-1",
                    "level": "beginner",
                    "code": "# Tham chiếu\nMột tham chiếu có thể được coi là một con trỏ không đổi (đừng nhầm với con trỏ tới một giá trị không đổi) luôn trỏ đến (tham chiếu) cùng một đối tượng. Chúng được khai báo bằng ký hiệu & (dấu và).\n\n## Khai báo và khởi tạo\nĐể khai báo một tham chiếu, hãy sử dụng ký hiệu & theo sau là loại biến và tên của tham chiếu. Lưu ý rằng bạn phải khởi tạo một tham chiếu khi bạn khai báo nó.\n\n```cpp\n\nintvar = 10;      // Khai báo một biến số nguyên\nint& ref = var; // Khai báo một tham chiếu \"trỏ tới\" var\n\n```\n\n## Cách sử dụng\nBạn có thể sử dụng tham chiếu giống như bạn sử dụng biến ban đầu. Khi bạn thay đổi giá trị của tham chiếu, giá trị của biến ban đầu cũng thay đổi, vì cả hai đều chia sẻ cùng một vị trí bộ nhớ.\n\n```cpp\n\nbiến = 20; // Đặt giá trị của var thành 20\ncout << ref << endl; // Đầu ra 20\n\ntham chiếu = 30; // Đặt giá trị của ref thành 30\ncout << var << endl; // Đầu ra 30\n\n```\n\n## Thông số hàm\nBạn có thể sử dụng tham chiếu làm tham số hàm để tạo bí danh cho đối số. Điều này thường được thực hiện khi bạn cần sửa đổi biến ban đầu hoặc khi chuyển một đối tượng có kích thước đáng kể để tránh chi phí sao chép.\n\n```cpp\n\nvoid swap(int& a, int& b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n   int x = 5, y = 10;\n   cout << \"Before Swap: x = \" << x << \" y = \" << y << endl; // đầu ra 5 10\n   \n   swap(x, y);\n   cout << \"After Swap: x = \" << x << \" y = \" << y << endl;  // đầu ra 10 5\n}\n\n```"
                },
                {
                    "author": "Dev Alex",
                    "title": " Mô hình bộ nhớ trong C++",
                    "param": "chap-5-2",
                    "level": "beginner",
                    "code": "# Mô hình bộ nhớ trong C++\nMô hình bộ nhớ trong C++ xác định cách chương trình lưu trữ và truy cập dữ liệu trong bộ nhớ máy tính. Nó bao gồm các phân đoạn khác nhau, chẳng hạn như phân đoạn Ngăn xếp, Đống, Dữ liệu và Mã code. Mỗi phân đoạn này được sử dụng để lưu trữ các loại dữ liệu khác nhau và có các đặc điểm cụ thể.\n\n## Bộ nhớ ngăn xếp\nBộ nhớ ngăn xếp được sử dụng cho các biến thời lượng lưu trữ tự động, chẳng hạn như các biến cục bộ và dữ liệu lệnh gọi hàm. Bộ nhớ ngăn xếp được trình biên dịch quản lý và việc phân bổ cũng như hủy phân bổ được thực hiện tự động. Bộ nhớ ngăn xếp cũng là cấu trúc dữ liệu LIFO (Last In First Out), nghĩa là dữ liệu gần đây nhất được cấp phát là dữ liệu đầu tiên được hủy cấp phát.\n\n```cpp\n\nvoid functionExample() {\n    int x = 10; // x được lưu trữ trong bộ nhớ ngăn xếp\n}\n\n```\n\n## Bộ nhớ heap\nBộ nhớ heap được sử dụng cho các biến thời lượng lưu trữ động, chẳng hạn như các đối tượng được tạo bằng từ khóa new. Lập trình viên có quyền kiểm soát việc phân bổ và giải phóng bộ nhớ heap bằng cách sử dụng các toán tử new và delete. Bộ nhớ heap là vùng bộ nhớ lớn hơn ngăn xếp, nhưng có thời gian truy cập chậm hơn\n\n```cpp\n\nvoid functionExample() {\n    int* p = new int; // cấp phát động int trong bộ nhớ heap\n    *p = 10;\n    // thêm mã code\n    delete p; // giải phóng bộ nhớ\n}\n\n```\n\n## Phân đoạn dữ liệu\nPhân đoạn dữ liệu bao gồm hai phần: phân đoạn dữ liệu được khởi tạo và phân đoạn dữ liệu chưa được khởi tạo. Phân đoạn dữ liệu đã khởi tạo lưu trữ các biến toàn cục, tĩnh và hằng số với các giá trị ban đầu, trong khi phân đoạn chưa khởi tạo lưu trữ các biến toàn cục và tĩnh chưa được khởi tạo.\n\n```cpp\n\n// Đoạn dữ liệu khởi tạo\nint globalVar = 10; // biến toàn cục\nstatic int staticVar = 10; // biến cục bộ tĩnh\nconst int constVar = 10; // biến hằng có giá trị\n\n// Đoạn dữ liệu chưa khởi tạo\nint globalVar; // các biến toàn cục chưa được khởi tạo\n\n```\n\n## Đoạn mã code\nĐoạn mã Code (còn được gọi là đoạn Văn bản) lưu mã thực thi (mã máy) của chương trình. Nó thường nằm trong vùng chỉ đọc của bộ nhớ để ngăn việc vô tình sửa đổi.\n\n```cpp\n\nvoid functionExample() {\n    // Mã máy cho hàm này được lưu trữ trong đoạn mã code.\n}\n\n```\nTóm lại, việc hiểu mô hình bộ nhớ trong C++ giúp tối ưu hóa việc sử dụng tài nguyên bộ nhớ và cải thiện hiệu suất tổng thể của chương trình."
                },
                {
                    "author": "Dev Alex",
                    "title": " Tuổi thọ của đối tượng trong C++",
                    "param": "chap-5-3",
                    "level": "beginner",
                    "code": "# Tuổi thọ của đối tượng trong C++\nThời gian tồn tại của đối tượng đề cập đến thời gian mà một đối tượng tồn tại, kể từ thời điểm nó được tạo ra cho đến khi nó bị hủy. Trong C++, vòng đời của một đối tượng có thể được phân thành bốn loại:\n- **Thời lượng lưu trữ tĩnh:** Các đối tượng có thời lượng lưu trữ tĩnh tồn tại trong toàn bộ quá trình chạy chương trình. Các đối tượng này được cấp phát khi bắt đầu chạy chương trình và được cấp phát lại khi chương trình kết thúc. Biến toàn cục, thành viên dữ liệu tĩnh và biến cục bộ tĩnh thuộc danh mục này.\n\n```cpp\n\nint global_var;            // Thời lượng lưu trữ tĩnh\nclass MyClass {\n  static int static_var;   // Thời lượng lưu trữ tĩnh\n};\nvoid myFunction() {\n  static int local_var;    // Thời lượng lưu trữ tĩnh\n}\n\n```\n- **Thời lượng lưu trữ luồng:** Các đối tượng có thời lượng lưu trữ luồng tồn tại trong suốt thời gian tồn tại của luồng mà chúng thuộc về. Chúng được tạo khi một luồng bắt đầu và bị hủy khi luồng đó thoát. Thời lượng lưu trữ luồng có thể được chỉ định bằng cách sử dụng từ khóa thread_local.\n\n```cpp\n\nthread_local int my_var;   // Thời lượng lưu trữ luồng\n\n```\n- **Thời lượng lưu trữ tự động:** Các đối tượng có thời lượng lưu trữ tự động được tạo tại thời điểm xác định và bị hủy khi thoát khỏi phạm vi mà chúng được khai báo. Các đối tượng này còn được gọi là các đối tượng \"cục bộ\" hoặc \"ngăn xếp\". Các tham số hàm và các biến không tĩnh cục bộ thuộc loại này.\n\n```cpp\n\nvoid myFunction() {\n  int local_var;           // Thời lượng lưu trữ tự động\n}\n\n```\n- **Thời lượng lưu trữ động:** Các đối tượng có thời lượng lưu trữ động được tạo trong thời gian chạy, sử dụng các chức năng cấp phát bộ nhớ như new hoặc malloc. Thời gian tồn tại của các đối tượng này phải được quản lý theo cách thủ công vì chúng không được tự động hủy cấp phát khi thoát khỏi phạm vi. Thay vào đó, trách nhiệm của lập trình viên là hủy các đối tượng bằng cách sử dụng hàm delete hoặc free khi chúng không còn cần thiết, để tránh rò rỉ bộ nhớ.\n\n```cpp\n\nint* ptr = new int;        // Thời lượng lưu trữ động\ndelete ptr;\n\n```\nHiểu thời gian tồn tại của đối tượng là điều cần thiết để quản lý bộ nhớ hiệu quả trong các chương trình C++ và tránh các vấn đề phổ biến như rò rỉ bộ nhớ và hành vi không xác định.\n\nHãy nhớ rằng sự hiểu biết đúng đắn về hàm tạo và hàm hủy đối với các lớp cũng rất cần thiết khi làm việc với các đối tượng có thời gian tồn tại khác nhau, vì chúng cho phép bạn kiểm soát hành vi tạo và hủy đối tượng.\n"
                },
                {
                    "author": "Dev Alex",
                    "title": " Con trỏ đặc biệt (unique_ptr)",
                    "param": "chap-5-4",
                    "level": "beginner",
                    "code": "# Con trỏ đặc biệt (unique_ptr)\nstd::unique_ptr là một con trỏ thông minh được cung cấp bởi Thư viện chuẩn C++. Nó là một lớp mẫu được sử dụng để quản lý các đối tượng hoặc mảng đơn lẻ.\n\nunique_ptr hoạt động dựa trên khái niệm sở hữu độc quyền - nghĩa là chỉ một unique_ptr được phép sở hữu một đối tượng tại một thời điểm. Quyền sở hữu này có thể được chuyển nhượng hoặc di chuyển nhưng không thể chia sẻ hoặc sao chép.\n\nKhái niệm này giúp ngăn ngừa các vấn đề như con trỏ không trỏ đến một đối tượng hợp lệ thích hợp, giảm rò rỉ bộ nhớ và loại bỏ nhu cầu quản lý bộ nhớ thủ công. Khi unique_ptr vượt quá phạm vi, nó sẽ tự động xóa đối tượng mà nó sở hữu.\n\nHãy cùng xem một số ví dụ cơ bản về việc sử dụng unique_ptr:\n\n## Tạo một unique_ptr\n\n```cpp\n\n#include <iostream>\n#include <memory>\n\nint main() {\n    std::unique_ptr<int> p1(new int(5)); // Khởi tạo với con trỏ tới một số nguyên mới\n    std::unique_ptr<int> p2 = std::make_unique<int>(10); // phương pháp quy chiếu (C++14 trở đi)\n\n    std::cout << *p1 << \", \" << *p2 << std::endl;\n    return 0;\n}\n\n```\n\n## Chuyển nhượng quyền sở hữu\n\n```cpp\n\n#include <iostream>\n#include <memory>\n\nint main() {\n    std::unique_ptr<int> p1(new int(5));\n\n    std::unique_ptr<int> p2 = std::move(p1); // Quyền sở hữu được chuyển từ p1 sang p2\n\n    if (p1) {\n        std::cout << \"p1 owns the object\" << std::endl;\n    } else if (p2) {\n        std::cout << \"p2 owns the object\" << std::endl;\n    }\n\n    return 0;\n}\n\n```\n\n## Sử dụng unique_ptr với Trình xóa tùy chỉnh\n\n```cpp\n\n#include <iostream>\n#include <memory>\n\nstruct MyDeleter {\n    void operator()(int* ptr) {\n        std::cout << \"Custom Deleter: Deleting pointer\" << std::endl;\n        delete ptr;\n    }\n};\n\nint main() {\n    std::unique_ptr<int, MyDeleter> p1(new int(5), MyDeleter());\n    return 0; // Trình xóa tùy chỉnh sẽ được gọi khi p1 vượt quá phạm vi\n}\n\n```\nHãy nhớ rằng vì unique_ptr có quyền sở hữu độc quyền nên bạn không thể sử dụng nó khi bạn cần chia sẻ quyền truy cập vào một đối tượng. Đối với những trường hợp như vậy, bạn có thể sử dụng std::shared_ptr."
                },
                {
                    "author": "Dev Alex",
                    "title": " Con trỏ dùng chung",
                    "param": "chap-5-5",
                    "level": "beginner",
                    "code": "# Con trỏ dùng chung\nshared_ptr là một loại con trỏ thông minh trong C++ cho phép nhiều con trỏ chia sẻ quyền sở hữu đối tượng được cấp phát động. Đối tượng sẽ chỉ được hủy cấp phát tự động khi shared_ptr cuối cùng trỏ tới nó bị hủy.\n\nKhi sử dụng shared_ptr, bộ đếm tham chiếu sẽ tự động tăng lên mỗi khi một con trỏ mới được tạo và giảm đi khi mỗi con trỏ vượt ra ngoài phạm vi. Khi bộ đếm tham chiếu về 0, hệ thống sẽ dọn sạch bộ nhớ.\n\n## Mã code ví dụ\nĐây là một ví dụ về cách sử dụng shared_ptr:\n\n```cpp\n\n#include <iostream>\n#include <memory>\n\nclass MyClass {\npublic:\n    MyClass() { std::cout << \"Constructor is called.\" << std::endl; }\n    ~MyClass() { std::cout << \"Destructor is called.\" << std::endl; }\n};\n\nint main() {\n    // tạo một con trỏ dùng chung để quản lý đối tượng MyClass\n    std::shared_ptr<MyClass> ptr1(new MyClass());\n    \n    {\n        // tạo một con trỏ dùng chung khác và khởi tạo nó với con trỏ đã tạo trước đó\n        std::shared_ptr<MyClass> ptr2 = ptr1;\n\n        std::cout << \"Inside the inner scope.\" << std::endl;\n        // cả hai con trỏ đều chia sẻ cùng một đối tượng và bộ đếm tham chiếu đã được tăng lên 2\n    }\n\n    std::cout << \"Outside the inner scope.\" << std::endl;\n    // rời khỏi phạm vi bên trong sẽ phá hủy ptr2 và bộ đếm tham chiếu được giảm xuống 1\n    \n    // hàm chính trả về, ptr1 vượt ra ngoài phạm vi và bộ đếm tham chiếu trở thành 0\n     // điều này khiến đối tượng MyClass bị xóa và hàm hủy được gọi\n}\n\n```\nĐầu ra:\n\n```cpp\n\nConstructor is called.\nInside the inner scope.\nOutside the inner scope.\nDestructor is called.\n\n```\nTrong ví dụ này, ptr1 và ptr2 chia sẻ quyền sở hữu của cùng một đối tượng. Đối tượng chỉ bị hủy khi cả hai con trỏ vượt ra ngoài phạm vi và bộ đếm tham chiếu trở thành số không."
                },
                {
                    "author": "Dev Alex",
                    "title": " Con trỏ weak",
                    "param": "chap-5-6",
                    "level": "beginner",
                    "code": "# Con trỏ weak\nMột weak_ptr là một loại con trỏ thông minh trong C++ bổ sung mức độ gián tiếp và an toàn cho một con trỏ raw. Nó chủ yếu được sử dụng để phá vỡ các chu kỳ tham chiếu trong trường hợp hai đối tượng đã chia sẻ các con trỏ với nhau hoặc khi bạn cần một tham chiếu không sở hữu cho một đối tượng được shared_ptr quản lý.\n\nMột weak_ptr không làm tăng số lượng tham chiếu của đối tượng mà nó trỏ tới, đây là điểm khác biệt quan trọng giữa weak_ptr và shared_ptr. Điều này đảm bảo rằng đối tượng sẽ bị xóa sau khi shared_ptr cuối cùng sở hữu nó vượt ra ngoài phạm vi, ngay cả khi vẫn còn có weak_ptrs tham chiếu đến nó.\n\nĐể sử dụng một weak_ptr, bạn phải chuyển đổi nó thành một shared_ptr bằng cách sử dụng hàm lock(), hàm này sẽ cố gắng tạo một shared_ptr mới để chia sẻ quyền sở hữu đối tượng. Nếu thành công, số lượng tham chiếu của đối tượng sẽ tăng lên và bạn có thể sử dụng shared_ptr được trả về để truy cập đối tượng một cách an toàn.\n\nĐây là một ví dụ về việc sử dụng weak_ptr:\n\n```cpp\n\n#include <iostream>\n#include <memory>\n\nclass MyClass {\npublic:\n    void DoSomething() {\n        std::cout << \"Doing something...\\n\";\n    }\n};\n\nint main() {\n    std::weak_ptr<MyClass> weak;\n\n    {\n        std::shared_ptr<MyClass> shared = std::make_shared<MyClass>();\n        weak = shared;\n\n        if(auto sharedFromWeak = weak.lock()) {\n            sharedFromWeak->DoSomething(); // Sử dụng an toàn đối tượng\n            std::cout << \"Shared uses count: \" << sharedFromWeak.use_count() << '\\n'; // 2\n        }\n    }\n\n    // chia sẻ vượt quá phạm vi và đối tượng MyClass bị hủy\n    if(auto sharedFromWeak = weak.lock()) {\n        // Khối này sẽ không được thực thi vì đối tượng bị hủy\n    }\n    else {\n        std::cout << \"Object has been destroyed\\n\";\n    }\n\n    return 0;\n}\n\n```\nTrong ví dụ này, chúng tôi tạo một shared_ptr có tên là shared để quản lý một đối tượng MyClass. Bằng cách gán nó cho một weak_ptr có tên là weak, chúng tôi lưu trữ một tham chiếu không sở hữu cho đối tượng. Bên trong phạm vi bên trong, chúng tôi tạo một shared_ptr mới có tên sharedFromWeak bằng cách sử dụng weak.lock() để sử dụng đối tượng một cách an toàn. Sau phạm vi bên trong, đối tượng MyClass bị hủy do shared vượt quá phạm vi và bất kỳ nỗ lực nào khác để tạo shared_ptr từ weak sẽ thất bại vì đối tượng đã bị hủy."
                },
                {
                    "author": "Dev Alex",
                    "title": " Con trỏ raw và toán tử new và delete",
                    "param": "chap-5-7",
                    "level": "beginner",
                    "code": "# Con trỏ raw và toán tử new và delete\nCon trỏ raw trong C++ là cấu trúc cấp thấp giữ trực tiếp địa chỉ bộ nhớ. Chúng có thể được sử dụng để cấp phát bộ nhớ theo cách thủ công, tạo mảng động và truyền giá trị một cách hiệu quả, trong số những thứ khác.\n\n## Toán tử new\nToán tử new được sử dụng để cấp phát bộ nhớ trên heap. Bộ nhớ được phân bổ bằng cách sử dụng new vẫn khả dụng cho đến khi bạn giải phóng nó một cách rõ ràng bằng cách sử dụng toán tử delete tương ứng.\n\nĐây là một ví dụ về việc sử dụng toán tử new:\n\n```cpp\n\nint* ptr = new int; // phân bổ một int trên heap\n*ptr = 42; // Gán giá trị 42 cho int được cấp phát\n\n```\n\n## Toán tử delete\nToán tử delete được sử dụng để giải phóng bộ nhớ đã được phân bổ bằng cách sử dụng new. Sau khi bộ nhớ được giải phóng, nó có sẵn để được phân bổ lại cho các mục đích khác. Việc không phân bổ bộ nhớ đúng cách có thể dẫn đến rò rỉ bộ nhớ.\n\nĐây là một ví dụ về việc sử dụng toán tử delete:\n\n```cpp\n\nint* ptr = new int; // Cấp phát động một int trên heap\n*ptr = 42; // Gán giá trị 42 cho int được cấp phát\ndelete ptr; // Giải phóng bộ nhớ được gán cho ptr\n\n```\n\n## Toán tử new [] và delete []\nToán tử new[] và delete[] được sử dụng để phân bổ và giải phóng bộ nhớ cho một mảng đối tượng. Cú pháp của new[] và delete[] rất giống với cú pháp của new và delete.\n\nĐây là một ví dụ về cách sử dụng toán tử new[] và delete[]:\n\n```cpp\n\nint n = 10;\nint* arr = new int[n]; // Tự động phân bổ một mảng gồm 10 số nguyên trên heap\n\n// Đặt một số giá trị trong mảng\nfor (int i = 0; i < n; i++) {\n  arr[i] = i;\n}\ndelete[] arr; // Giải phóng bộ nhớ được gán cho mảng\n\n```\nTóm lại, con trỏ raw, toán tử new và delete cho phép quản lý bộ nhớ thủ công trong C++, cung cấp khả năng kiểm soát phân bổ và giải phóng. Đảm bảo luôn giải phóng bộ nhớ được phân bổ bằng new hoặc new[], để tránh rò rỉ bộ nhớ trong các chương trình của bạn."
                },
                {
                    "author": "Dev Alex",
                    "title": " Rò rỉ bộ nhớ",
                    "param": "chap-5-8",
                    "level": "beginner",
                    "code": "# Rò rỉ bộ nhớ\nRò rỉ bộ nhớ xảy ra khi một chương trình phân bổ bộ nhớ trong heap nhưng không giải phóng bộ nhớ trở lại hệ điều hành khi không còn cần thiết. Theo thời gian, điều này dẫn đến cạn kiệt bộ nhớ khả dụng, dẫn đến hiệu suất hệ thống thấp hoặc treo máy.\n\nTrong C++, khi bạn sử dụng con trỏ raw, bạn cần quản lý phân bổ và giải phóng bộ nhớ theo cách thủ công. Trong nhiều trường hợp, bạn sẽ sử dụng từ khóa new để phân bổ bộ nhớ cho một đối tượng trong heap và sử dụng từ khóa delete để giải phóng bộ nhớ đó khi không còn cần thiết. Quên làm điều này có thể gây rò rỉ bộ nhớ.\n\nĐây là một ví dụ:\n\n```cpp\n\nvoid create_memory_leak() {\n    int* ptr = new int[100]; // phân bổ bộ nhớ trong heap cho một mảng số nguyên\n    // một số mã code...\n    // Mã code giải phóng bộ nhớ bị thiếu: delete[] ptr;\n} // ptr vượt quá phạm vi, khối bộ nhớ được phân bổ không được giải phóng, gây rò rỉ bộ nhớ.\n\n```\nĐể tránh rò rỉ bộ nhớ, bạn phải luôn đảm bảo rằng bộ nhớ được giải phóng trước khi một con trỏ vượt ra ngoài phạm vi hoặc được gán lại. Một số cách để đạt được điều này bao gồm sử dụng con trỏ thông minh C++ (std::unique_ptr, std::shared_ptr), kỹ thuật RAII (Khởi tạo thu nhận tài nguyên) và bộ chứa từ thư viện chuẩn C++ quản lý phân bổ bộ nhớ bên trong (ví dụ: std::vector, std::string).\n\nVí dụ: mã code này sẽ không bị rò rỉ bộ nhớ:\n\n```cpp\n\n#include <memory>\nvoid no_memory_leak() {\n    std::shared_ptr<int> ptr = std::make_shared<int[]>(100); // phân bổ bộ nhớ trong heap cho một mảng số nguyên bằng shared_ptr\n    // mốt số mã code...\n} // shared_ptr vượt quá phạm vi và nó sẽ tự động giải phóng khối bộ nhớ được gán cho nó.\n\n```"
                }
            ]
        },
        {
            "title": "Chương 7 Cấu trúc struct",
            "param": "chap-6-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " Cơ sở mã code cấu trúc",
                    "param": "chap-6-0",
                    "level": "beginner",
                    "code": "# Cơ sở mã code cấu trúc\nCơ sở mã code cấu trúc là một phần thiết yếu của quá trình phát triển phần mềm liên quan đến việc tổ chức và mô đun mã hóa của bạn để làm cho mã code dễ bảo trì hơn, hiệu quả hơn và dễ hiểu hơn. Cơ sở mã code có cấu trúc tốt giúp tăng cường cộng tác, đơn giản hóa việc thêm các tính năng mới và giúp gỡ lỗi nhanh hơn. Trong C++, có nhiều kỹ thuật khác nhau giúp bạn cấu trúc cơ sở mã code của mình một cách hiệu quả.\n\n## Namespace\nNamespace là một trong những công cụ trong C++ để tổ chức mã code của bạn bằng cách cung cấp phạm vi được đặt tên cho các mã code định danh khác nhau mà bạn tạo, như hàm, lớp và biến. Chúng giúp tránh xung đột tên và làm cho mã code của bạn trở nên mô-đun hơn.\n\n```cpp\n\nnamespace MyNamespace {\n    int aFunction() {\n        // thực thi hàm\n    }\n}\n//để sử dụng hàm\nMyNamespace::aFunction();\n\n```\n\n## Include Guards\nInclude Guards là một công cụ để ngăn chặn nhiều lần bao gồm tệp tiêu đề trong dự án của bạn. Chúng bao gồm các chỉ thị tiền xử lý bao gồm tệp tiêu đề một cách có điều kiện chỉ một lần, ngay cả khi nó được bao gồm ở nhiều nơi.\n\n```cpp\n\n#ifndef MY_HEADER_FILE_H\n#define MY_HEADER_FILE_H\n// mã code của bạn ở đây\n#endif // CỦA TÔI_TIÊU ĐỀ_FILE_H\n\n```\n\n## File tiêu đề và file nguồn\nViệc tách phần triển khai và phần khai báo của bạn thành các file tiêu đề (.h) và file nguồn (.cpp) là một khía cạnh quan trọng trong việc cấu trúc cơ sở mã code của bạn trong C++. Các file tiêu đề thường chứa các khai báo lớp và hàm, trong khi các file nguồn chứa các định nghĩa của chúng.\n\n// MyClass.h\n\n```cpp\n\n#ifndef MY_CLASS_H\n#define MY_CLASS_H\n\nclass MyClass\n{\npublic:\n    MyClass();\n    int myMethod();\n};\n \n#endif // CỦA TÔI_LỚP_H\n\n```\n// MyClass.cpp\n\n```cpp\n\n#include \"MyClass.h\"\n\nMyClass::MyClass() {\n    // triển khai hàm \n}\n\nint MyClass::myMethod() {\n    // phương pháp thực thi\n}\n\n```\n\n## Định dạng mã code\nĐịnh dạng mã code và thụt lề nhất quán đóng một vai trò quan trọng trong việc cấu trúc cơ sở mã code của bạn, giúp bạn và các nhà phát triển khác dễ đọc và dễ hiểu hơn. Hướng dẫn về phong cách chẳng hạn như  Google C++ Style Guide có thể giúp bạn duy trì định dạng nhất quán trong suốt dự án của mình."
                },
                {
                    "author": "Dev Alex",
                    "title": " Phạm vi trong C++",
                    "param": "chap-6-1",
                    "level": "beginner",
                    "code": "# Phạm vi trong C++\nPhạm vi đề cập đến khả năng hiển thị và khả năng truy cập của các biến, hàm, lớp và các mã code định danh khác trong chương trình C++. Nó xác định thời gian tồn tại và phạm vi của các mã code định danh này. Trong C++, có bốn loại phạm vi:\n- **Phạm vi toàn cục:** Các định danh được khai báo bên ngoài bất kỳ hàm hoặc lớp nào đều có phạm vi toàn cục. Chúng có thể được truy cập từ bất kỳ phần nào của chương trình (trừ khi bị ẩn bởi một mã code định danh cục bộ có cùng tên). Thời gian tồn tại của mã code định danh toàn cầu là toàn bộ thời lượng của chương trình.\n\n```cpp\n\n#include <iostream>\nint globalVar; // Đây là biến toàn cục\nint main() {\n    std::cout << \"Global variable: \" << globalVar << std::endl;\n}\n\n```\n- **Phạm vi cục bộ:** Các định danh được khai báo trong một hàm hoặc một khối có phạm vi cục bộ. Chúng chỉ có thể được truy cập trong hàm hoặc khối mà chúng được khai báo. Thời gian tồn tại của chúng bị giới hạn trong khoảng thời gian thực thi hàm/khối.\n\n```cpp\n\n#include <iostream>\n\nvoid localExample() {\n    int localVar; // Đây là biến cục bộ\n    localVar = 5;\n    std::cout << \"Local variable: \" << localVar << std::endl;\n}\n\nint main() {\n    localExample();\n    // std::cout << localVar << std::endl; //error: ‘localVar’ was not declared in this scope\n}\n\n```\n- **Phạm vi không gian tên:** Một không gian tên là một phạm vi được đặt tên nhóm các định danh có liên quan lại với nhau. Định danh được khai báo trong một không gian tên có phạm vi không gian tên. Chúng có thể được truy cập bằng cách sử dụng tên không gian tên và toán tử phân giải phạm vi ::.\n\n```cpp\n\n#include <iostream>\n\nnamespace MyNamespace {\n    int namespaceVar = 42;\n}\n\nint main() {\n    std::cout << \"Namespace variable: \" << MyNamespace::namespaceVar << std::endl;\n}\n\n```\n- **Phạm vi lớp:**  Các định danh được khai báo trong một lớp có phạm vi lớp. Chúng có thể được truy cập bằng cách sử dụng tên lớp và toán tử phân giải phạm vi :: hoặc đối với các thành viên không tĩnh, một đối tượng của lớp và dấu chấm . hoặc mũi tên -> toán tử.\n\n```cpp\n\n#include <iostream>\n\nclass MyClass {\npublic:\n    static int staticMember;\n    int nonStaticMember;\n\n    MyClass(int value) : nonStaticMember(value) {}\n};\n\nint MyClass::staticMember = 7;\n\nint main() {\n    MyClass obj(10);\n    std::cout << \"Static member: \" << MyClass::staticMember << std::endl;\n    std::cout << \"Non-static member: \" << obj.nonStaticMember << std::endl;\n}\n\n```\nHiểu các loại phạm vi khác nhau trong C++ là điều cần thiết để cấu trúc mã code hiệu quả và quản lý tài nguyên trong cơ sở mã code."
                },
                {
                    "author": "Dev Alex",
                    "title": " Namespace trong C++",
                    "param": "chap-6-2",
                    "level": "beginner",
                    "code": "# Namespace trong C++\nTrong C++, namespace là một phạm vi hoặc vùng chứa được đặt tên được sử dụng để tổ chức và đính kèm một tập hợp các phần tử mã code, chẳng hạn như biến, hàm, lớp và các namespace khác. Chúng chủ yếu được sử dụng để phân chia và quản lý cơ sở mã code, cho phép các nhà phát triển kiểm soát xung đột tên và chuyên biệt hoá mã code.\n\n## Cú pháp\nĐây là cú pháp để khai báo một namespace:\n\n```cpp\n\nnamespace identifier {\n    // phần tử mã code \n}\n\n```\n\n## Sử dụng namespace\nĐể truy cập các phần tử trong một namespace, bạn có thể sử dụng toán tử phân giải phạm vi ::. Dưới đây là một số ví dụ:\n\n## Khai báo và truy cập một namespace\n\n```cpp\n\n#include <iostream>\n\nnamespace animals {\n    std::string dog = \"Bobby\";\n    std::string cat = \"Lilly\";\n}\n\nint main() {\n    std::cout << \"Dog's name: \" << animals::dog << std::endl;\n    std::cout << \"Cat's name: \" << animals::cat << std::endl;\n\n    return 0;\n}\n\n```\n\n## Namespace lồng nhau\nNamespace có thể được lồng trong các không gian tên khác:\n\n```cpp\n\n#include <iostream>\n\nnamespace outer {\n    int x = 10;\n\n    namespace inner {\n        int y = 20;\n    }\n}\n\nint main() {\n    std::cout << \"Outer x: \" << outer::x << std::endl;\n    std::cout << \"Inner y: \" << outer::inner::y << std::endl;\n\n    return 0;\n}\n\n```\n\n## Từ khóa using\nBạn có thể sử dụng từ khóa using để nhập các phần tử được đặt tên vào phạm vi hiện tại. Tuy nhiên, điều này có thể dẫn đến xung đột tên nếu nhiều namespace có các phần tử trùng tên.\n\n## Sử dụng một phần tử từ một namespace\n\n```cpp\n\n#include <iostream>\n\nnamespace animals {\n    std::string dog = \"Bobby\";\n    std::string cat = \"Lilly\";\n}\n\nint main() {\n    using animals::dog;\n    \n    std::cout << \"Dog's name: \" << dog << std::endl;\n\n    return 0;\n}\n\n```\n\n## Sử dụng toàn bộ namespace\n\n```cpp\n\n#include <iostream>\n\nnamespace animals {\n    std::string dog = \"Bobby\";\n    std::string cat = \"Lilly\";\n}\n\nint main() {\n    using namespace animals;\n    \n    std::cout << \"Dog's name: \" << dog << std::endl;\n    std::cout << \"Cat's name: \" << cat << std::endl;\n\n    return 0;\n}\n\n```\nTóm lại, namespace là một cơ chế hữu ích trong C++ để tổ chức mã code, tránh xung đột đặt tên và quản lý khả năng hiển thị của các phần tử mã code."
                },
                {
                    "author": "Dev Alex",
                    "title": " Tách mã code",
                    "param": "chap-6-3",
                    "level": "beginner",
                    "code": "# Tách mã code\nTách mã code đề cập đến quá trình chia nhỏ cơ sở mã code lớn thành các tệp hoặc mô-đun nhỏ hơn, dễ quản lý hơn. Điều này giúp cải thiện tổ chức, khả năng bảo trì và khả năng đọc của mã code. Trong C++, việc chia tách mã code thường đạt được thông qua việc sử dụng các tệp biên dịch, file tiêu đề và file nguồn riêng biệt.\n\n## File tiêu đề (.h hoặc .hpp)\nCác tệp tiêu đề, thường có phần mở rộng .h hoặc .hpp, chịu trách nhiệm khai báo các lớp, hàm và biến cần thiết cho nhiều file nguồn. Chúng hoạt động như một giao diện giữa các phần khác nhau của mã code, giúp quản lý các phần phụ thuộc dễ dàng hơn và giảm khả năng mã code trùng lặp.\n\nVí dụ về tệp tiêu đề:\n\n```cpp\n\n// ví dụ.h\n#ifndef EXAMPLE_H\n#define EXAMPLE_H\n\nclass Example {\npublic:\n    void printMessage();\n};\n\n```\n\n## File nguồn (.cpp)\nCác file nguồn, với phần mở rộng .cpp, chịu trách nhiệm triển khai chức năng thực tế được xác định trong các file tiêu đề tương ứng. Chúng bao gồm các file tiêu đề khi cần thiết và cung cấp các định nghĩa phương thức lớp và hàm.\n\nVí dụ về tệp nguồn:\n\n```cpp\n\n// ví dụ.cpp\n#include \"example.h\"\n#include <iostream>\n\nvoid Example::printMessage() {\n    std::cout << \"Hello, code splitting!\" << std::endl;\n}\n\n```\n\n## Biên soạn riêng\nC++ cho phép biên dịch riêng biệt, nghĩa là mỗi file nguồn có thể được biên dịch độc lập thành một tệp đối tượng. Các tệp đối tượng này sau đó có thể được liên kết với nhau để tạo thành file thực thi cuối cùng. Điều này cung cấp thời gian xây dựng nhanh hơn khi thực hiện các thay đổi đối với một file nguồn vì chỉ file đó cần được biên dịch lại và các file đối tượng khác có thể được sử dụng lại.\n\nVí dụ về biên dịch và liên kết riêng biệt:\n\n```cpp\n\n# Compile each source file into an object file\ng++ -c main.cpp -o main.o\ng++ -c example.cpp -o example.o\n# Link object files together to create the executable\ng++ main.o example.o -o my_program\n\n```\nBằng cách làm theo kỹ thuật tách mã code, bạn có thể tổ chức tốt hơn cơ sở mã code C++ của mình, làm cho nó dễ quản lý và bảo trì hơn.\n"
                },
                {
                    "author": "Dev Alex",
                    "title": " Tiền khai báo",
                    "param": "chap-6-4",
                    "level": "beginner",
                    "code": "# Tiền khai báo\nTiền khai báo là một cách khai báo một ký hiệu (lớp, hàm hoặc biến) trước khi định nghĩa nó trong mã code. Nó giúp trình biên dịch hiểu được kiểu, kích thước và sự tồn tại của biểu tượng. Tiền khai báo này đặc biệt hữu ích khi chúng ta có các phụ thuộc theo chu kỳ hoặc để giảm thời gian biên dịch bằng cách tránh đưa vào tiêu đề không cần thiết trong tệp nguồn.\n\n## Lớp tiền khai báo\nĐể sử dụng một loại lớp trước khi nó được định nghĩa, bạn có thể khai báo lớp mà không cần xác định các thành viên của nó, như sau:\n\n```cpp\n\nlass ClassA; // Tiền khai báo\n\n```\nSau đó, bạn có thể sử dụng các con trỏ hoặc tham chiếu đến lớp trong mã code của mình trước khi xác định chính lớp đó:\n\n```cpp\n\nvoid do_something (ClassA& obj);\n\nclass ClassB {\npublic:\n    void another_function(ClassA& obj);\n};\n\n```\nTuy nhiên, nếu bạn cố tạo một đối tượng của ClassA hoặc gọi các hàm thành viên của nó mà không định nghĩa lớp, bạn sẽ gặp lỗi biên dịch.\n\n## Hàm tiền khai báo\nCác hàm phải được khai báo trước khi sử dụng chúng và có thể sử dụng khai báo chuyển tiếp để khai báo một hàm mà không cần xác định nó:\n\n```cpp\n\nint add(int a, int b); // tiền khai báo\n\nint main() {\n    int result = add(2, 3);\n    return 0;\n}\n\nint add(int a, int b) {\n    return a + b;\n}\n\n```\n\n## Tiền khai báo Enum và Typedef\nĐối với enum và typedef, không thể chuyển tiếp khai báo vì chúng không có giai đoạn khai báo và định nghĩa riêng biệt.\n\nHãy nhớ rằng các khai báo chuyển tiếp nên được sử dụng một cách thận trọng, vì chúng có thể làm cho mã code trở nên khó hiểu hơn.\n"
                }
            ]
        },
        {
            "title": "Chương 8 OOP, Struct",
            "param": "chap-7-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " Cấu trúc và lớp trong C++",
                    "param": "chap-7-0",
                    "level": "beginner",
                    "code": "# Cấu trúc và lớp trong C++\nCấu trúc và lớp là các kiểu dữ liệu do người dùng định nghĩa trong C++ cho phép nhóm các biến thuộc các kiểu dữ liệu khác nhau dưới một tên duy nhất. Chúng giúp quản lý và sắp xếp dữ liệu phức tạp dễ dàng hơn bằng cách tạo các đối tượng có các thuộc tính và hành vi cụ thể. Sự khác biệt chính giữa cấu trúc và lớp là chỉ định truy cập mặc định của chúng: các thành viên của cấu trúc được mặc định là công khai, trong khi các thành viên của lớp là riêng tư.\n\n## Cấu trúc\nMột cấu trúc được xác định bằng cách sử dụng từ khóa struct, theo sau là tên của cấu trúc và một bộ dấu ngoặc nhọn {} bao quanh các thành viên (biến và/hoặc hàm) của cấu trúc. Các thành viên có thể thuộc các kiểu dữ liệu khác nhau. Để tạo một đối tượng thuộc loại cấu trúc, hãy sử dụng tên cấu trúc theo sau là tên đối tượng.\n\nĐây là một ví dụ về việc xác định một cấu trúc và tạo một đối tượng:\n\n```cpp\n\nstruct Employee {\n    int id;\n    std::string name;\n    float salary;\n};\n\nEmployee e1; // tạo một đối tượng của cấu trúc 'employee'\n\n```\nBạn có thể truy cập các thành viên của cấu trúc bằng cách sử dụng toán tử dấu chấm .:\n\n```cpp\n\ne1.id = 1;\ne1.name = \"John Doe\";\ne1.salary = 40000;\n\n```\n\n## Các lớp\nMột lớp được định nghĩa bằng cách sử dụng class, theo sau là tên của lớp và một bộ dấu ngoặc nhọn {} bao quanh các thành viên (biến và/hoặc hàm) của lớp. Giống như các cấu trúc, các thành viên của lớp có thể thuộc các kiểu dữ liệu khác nhau. Bạn có thể tạo các đối tượng của một lớp bằng cách sử dụng tên lớp theo sau là tên đối tượng.\n\nĐây là một ví dụ về định nghĩa lớp và tạo đối tượng:\n\n\n```cpp\n\nclass Student {\n    int roll_no;\n    std::string name;\n    float marks;\n\npublic:\n    void set_data(int r, std::string n, float m) {\n        roll_no = r;\n        name = n;\n        marks = m;\n    }\n\n    void display() {\n        std::cout << \"Roll no: \" << roll_no\n                  << \"\\nName: \" << name\n                  << \"\\nMarks: \" << marks << std::endl;\n    }\n};\n\nStudent s1; // tạo một đối tượng của lớp 'Student'\n\n```\nVì các thành viên dữ liệu của một lớp là riêng tư theo mặc định, chúng tôi không thể truy cập chúng trực tiếp bằng cách sử dụng toán tử dấu chấm từ bên ngoài lớp. Thay vào đó, chúng tôi sử dụng các hàm thành viên công khai để đặt hoặc nhận các giá trị của chúng:\n\n```cpp\n\ns1.set_data(1, \"Alice\", 95.0);\ns1.display();\n\n```\nĐó là một bản tóm tắt ngắn gọn về cấu trúc và lớp trong C++. Hãy nhớ rằng mặc dù chúng có vẻ giống nhau, nhưng các lớp cung cấp nhiều quyền kiểm soát hơn đối với việc đóng gói dữ liệu và có thể được sử dụng để triển khai các tính năng nâng cao hơn như kế thừa và đa hình."
                },
                {
                    "author": "Dev Alex",
                    "title": " Quy Tắc Zero, Five, Three",
                    "param": "chap-7-1",
                    "level": "beginner",
                    "code": "# Quy Tắc Zero, Five, Three\nQuy tắc Zero, Three và Five trong C++\n\nQuy tắc zero, three và five là một bộ hướng dẫn để quản lý tài nguyên đối tượng trong C++ hiện đại, liên quan đến cấu trúc và lớp. Các quy tắc này xử lý hành vi mặc định của hàm tạo, hàm hủy và các hàm thành viên đặc biệt khác cần thiết để quản lý tài nguyên phù hợp.\n\n## Quy luật Zero\nQuy tắc Zero tuyên bố rằng nếu một lớp hoặc cấu trúc không quản lý tài nguyên một cách rõ ràng, thì nó không nên định nghĩa bất kỳ hàm thành viên đặc biệt nào, tức là hàm hủy, hàm tạo sao chép, toán tử gán sao chép, hàm tạo di chuyển và toán tử gán di chuyển. Trình biên dịch sẽ tự động tạo các hàm này và hành vi sẽ chính xác để quản lý các tài nguyên như bộ nhớ và xử lý file.\n\nVí dụ:\n\n```cpp\n\nstruct MyResource {\n    std::string name;\n    int value;\n};\n\n```\nTrong ví dụ này, MyResource là một cấu trúc đơn giản không quản lý bất kỳ tài nguyên nào, vì vậy nó không xác định bất kỳ hàm thành viên đặc biệt nào. Trình biên dịch sẽ tự động tạo chúng và hành vi sẽ chính xác.\n\n## Quy tắc Three\nQuy tắc Three quy định rằng một lớp hoặc cấu trúc quản lý tài nguyên nên xác định ba hàm thành viên đặc biệt sau:\n- hàm hủy\n- hàm tạo sao chép\n- Hàm sao chép toán tử gán\n\nCác hàm này là cần thiết để quản lý tài nguyên phù hợp, chẳng hạn như giải phóng bộ nhớ hoặc xử lý chính xác các bản sao sâu.\n\nVí dụ:\n\n```cpp\n\nclass MyResource {\npublic:\n    // Hàm tạo và hàm hủy\n    MyResource() : data(new int[100]) {} \n    ~MyResource() { delete[] data; } \n\n    // Sao chép hàm tạo\n    MyResource(const MyResource& other) : data(new int[100]) {\n        std::copy(other.data, other.data + 100, data);\n    }\n\n    // Sao chép toán tử gán\n    MyResource& operator=(const MyResource& other) {\n        if (&other == this) { return *this; }\n        std::copy(other.data, other.data + 100, data);\n        return *this;\n    }\n\nprivate:\n    int* data;\n};\n\n```\nTrong ví dụ này, MyResource là một lớp quản lý tài nguyên (một mảng các số nguyên), do đó, nó định nghĩa hàm hủy, hàm tạo bản sao và toán tử gán bản sao.\n\n## Quy tắc Five\nQuy tắc Five mở rộng Quy tắc Three để bao gồm thêm hai hàm thành viên đặc biệt:\n- Di chuyển hàm tạo\n- Di chuyển hàm toán tử gán\n\nC++ hiện đại giới thiệu ngữ nghĩa di chuyển, cho phép xử lý tài nguyên hiệu quả hơn bằng cách chuyển quyền sở hữu mà không nhất thiết phải sao chép tất cả dữ liệu.\n\nVí dụ:\n\n```cpp\n\nclass MyResource {\npublic:\n    // Hàm tạo và hàm hủy\n    MyResource() : data(new int[100]) {}\n    ~MyResource() { delete[] data; }\n\n    // Sao chép hàm tạo\n    MyResource(const MyResource& other) : data(new int[100]) {\n        std::copy(other.data, other.data + 100, data);\n    }\n\n    // Sao chép toán tử gán\n    MyResource& operator=(const MyResource& other) {\n        if (&other == this) { return *this; }\n        std::copy(other.data, other.data + 100, data);\n        return *this;\n    }\n\n    // Di chuyển hàm tạo\n    MyResource(MyResource&& other) noexcept : data(other.data) {\n        other.data = nullptr;\n    }\n\n    // Di chuyển hàm toán tử gán\n    MyResource& operator=(MyResource&& other) noexcept {\n        if (&other == this) { return *this; }\n        delete[] data;\n        data = other.data;\n        other.data = nullptr;\n        return *this;\n    }\n\nprivate:\n    int* data;\n};\n\n```\nTrong ví dụ này, MyResource là một lớp quản lý tài nguyên (một mảng các số nguyên), do đó, nó xác định tất cả năm hàm thành viên đặc biệt để quản lý tài nguyên phù hợp và di chuyển ngữ nghĩa."
                },
                {
                    "author": "Dev Alex",
                    "title": " Đa kế thừa",
                    "param": "chap-7-2",
                    "level": "beginner",
                    "code": "# Đa kế thừa\nĐa kế thừa là một tính năng trong C++, trong đó một lớp có thể kế thừa các đặc điểm (thành viên dữ liệu và hàm thành viên) từ nhiều hơn một lớp cha. Khái niệm này tương tự như kế thừa đơn (trong đó một lớp kế thừa từ một lớp cơ sở duy nhất), nhưng trong đa kế thừa, một lớp có thể có nhiều lớp cơ sở.\n\nKhi một lớp kế thừa nhiều lớp cơ sở, nó trở thành một hỗn hợp các thuộc tính và hành vi của chúng và có thể ghi đè hoặc mở rộng chúng khi cần.\n\n## Cú pháp\nĐây là cú pháp để khai báo một lớp có nhiều kế thừa:\n\n```cpp\n\nclass DerivedClass : access-specifier BaseClass1, access-specifier BaseClass2, ...\n{\n    // lớp body\n};\n\n```\nDerivedClass sẽ kế thừa các thành viên từ cả BaseClass1 và BaseClass2. access-specifier (như public, protected, or private) xác định khả năng truy cập của các thành viên được kế thừa.\n\n## Ví dụ\nDưới đây là một ví dụ về đa kế thừa đang hoạt động:\n\n```cpp\n\n#include <iostream>\n\n//Lớp cơ sở 1\nclass Animal\n{\npublic:\n    void eat()\n    {\n        std::cout << \"I can eat!\" << std::endl;\n    }\n};\n\n// lớp cơ sở 2\nclass Mammal\n{\npublic:\n    void breath()\n    {\n        std::cout << \"I can breathe!\" << std::endl;\n    }\n};\n\n// Lớp phái sinh kế thừa từ cả Động vật và Động vật có vú\nclass Dog : public Animal, public Mammal\n{\npublic:\n    void bark()\n    {\n        std::cout << \"I can bark! Woof woof!\" << std::endl;\n    }\n};\n\nint main()\n{\n    Dog myDog;\n\n    // Gọi các thành viên từ cả hai lớp cơ sở\n    myDog.eat();\n    myDog.breath();\n    \n    // Gọi một thành viên từ lớp dẫn xuất\n    myDog.bark();\n\n    return 0;\n}\n\n```\n\n## Ghi chú\nTrong một số trường hợp, đa thừa kế có thể dẫn đến các biến chứng như sự mơ hồ và “vấn đề kim cương”. Đảm bảo rằng bạn sử dụng nhiều kế thừa một cách thận trọng và duy trì các lớp mô-đun và có cấu trúc tốt để ngăn ngừa sự cố.\n\nĐể biết thêm thông tin về đa thừa kế C++ và các chủ đề liên quan, hãy tham khảo tài liệu C++ hoặc hướng dẫn lập trình C++ toàn diện."
                },
                {
                    "author": "Dev Alex",
                    "title": " Kế thừa kim cương",
                    "param": "chap-7-3",
                    "level": "beginner",
                    "code": "# Kế thừa kim cương\nKế thừa kim cương là một kịch bản cụ thể trong đa kế thừa trong đó một lớp được dẫn xuất từ hai hoặc nhiều lớp, do đó, được dẫn xuất từ một lớp cơ sở chung. Nó tạo ra sự mơ hồ phát sinh từ việc sao chép lớp cơ sở chung, dẫn đến hành vi mơ hồ trong khi gọi các thành viên trùng lặp.\n\nĐể giải quyết sự mơ hồ này, bạn có thể sử dụng kế thừa ảo. Một lớp cơ sở ảo là một lớp được chia sẻ bởi nhiều lớp sử dụng từ khóa virtual trong C++. Điều này đảm bảo rằng chỉ một bản sao của lớp cơ sở được kế thừa trong lớp dẫn xuất cuối cùng và do đó, giải quyết được vấn đề thừa kế kim cương.\n\nVí dụ:\n\n```cpp\n\n#include<iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    void print() {\n        cout << \"Base class\" << endl;\n    }\n};\n\nclass Derived1 : virtual public Base {\npublic:\n    void derived1Print() {\n        cout << \"Derived1 class\" << endl;\n    }\n};\n\nclass Derived2 : virtual public Base {\npublic:\n    void derived2Print() {\n        cout << \"Derived2 class\" << endl;\n    }\n};\n\nclass Derived3 : public Derived1, public Derived2 {\npublic:\n    void derived3Print() {\n        cout << \"Derived3 class\" << endl;\n    }\n};\n\nint main()\n{\n    Derived3 d3;\n    d3.print(); // Bây giờ, không có sự mơ hồ nào trong việc gọi hàm lớp cơ sở\n    d3.derived1Print();\n    d3.derived2Print();\n    d3.derived3Print();\n\n    return 0;\n}\n\n```\nTrong đoạn mã code trên, Derived1 và Derived2 được dẫn xuất từ lớp base bằng cách sử dụng kế thừa ảo. Vì vậy, khi chúng ta tạo một đối tượng Derived3 và gọi hàm print() từ lớp base, sẽ không có sự mơ hồ nào và mã sẽ thực thi mà không gặp bất kỳ sự cố nào."
                },
                {
                    "author": "Dev Alex",
                    "title": " Lập trình Object-Oriented (OOP) trong C++",
                    "param": "chap-7-4",
                    "level": "beginner",
                    "code": "# Lập trình Object-Oriented (OOP) trong C++\nLập trình Object-Oriented (OOP) là một mô hình lập trình sử dụng các đối tượng, là các thể hiện của các lớp, để thực hiện các thao tác và tương tác với nhau. Trong C++, bạn có thể đạt được OOP thông qua việc sử dụng các lớp và đối tượng.\n\n## Các lớp\nMột lớp là một kế hoạch chi tiết để tạo các đối tượng. Nó xác định cấu trúc (thành viên dữ liệu) và hành vi (hàm thành viên) cho một loại đối tượng. Đây là một ví dụ về một lớp đơn giản:\n\n```cpp\n\nclass Dog {\npublic:\n    std::string name;\n    int age;\n\n    void bark() {\n        std::cout << name << \" barks!\" << std::endl;\n    }\n};\n\n```\nLớp Dog này có hai thành viên dữ liệu: name và age, và một thành viên hàm bark. Bạn có thể tạo một đối tượng của lớp này và truy cập các thành viên của nó như sau:\n\n```cpp\n\nDog myDog;\nmyDog.name = \"Fido\";\nmyDog.age = 3;\nmyDog.bark(); // đầu ra: Fido barks!\n\n```\n\n## Đóng gói\nĐóng gói là khái niệm gói dữ liệu và các hàm hoạt động trên dữ liệu đó trong một đơn vị, chẳng hạn như một lớp. Nó giúp ẩn các chi tiết triển khai bên trong của một lớp và chỉ hiển thị các thông tin và hàm cần thiết. Trong C++, bạn có thể sử dụng các chỉ định truy cập như public, private, và protected để kiểm soát khả năng hiển thị và khả năng truy cập của các thành viên lớp. Ví dụ:\n\n```cpp\n\nclass Dog {\nprivate:\n    std::string name;\n    int age;\n\npublic:\n    void setName(std::string n) {\n        name = n;\n    }\n\n    void setAge(int a) {\n        age = a;\n    }\n\n    void bark() {\n        std::cout << name << \" barks!\" << std::endl;\n    }\n};\n\n```\nTrong ví dụ này, chúng tôi đã đặt các thành viên dữ liệu name và age ở private và thêm các hàm thành viên công cộng setName và setAge để sửa đổi chúng. Bằng cách này, dữ liệu nội bộ của lớp Dog được bảo vệ và chỉ có thể truy cập thông qua các hàm được cung cấp.\n\n## Kế thừa\nKế thừa là khái niệm dẫn xuất các lớp mới từ các lớp hiện có, cho phép tổ chức và tái sử dụng mã code. Trong C++, tính kế thừa đạt được bằng cách sử dụng dấu hai chấm : theo sau là từ chỉ định truy cập của lớp cơ sở và tên lớp cơ sở. Ví dụ:\n\n```cpp\n\nclass Animal {\npublic:\n    void breathe() {\n        std::cout << \"I can breathe\" << std::endl;\n    }\n};\n\nclass Dog : public Animal {\npublic:\n    void bark() {\n        std::cout << \"Dog barks!\" << std::endl;\n    }\n};\n\n```\nTrong ví dụ này, lớp Dog kế thừa từ lớp Animal, vì vậy lớp Dog có thể truy cập hàm Breath từ lớp Animal. Khi bạn tạo một đối tượng Dog, bạn có thể sử dụng cả hai hàm breath và dark.\n\n```cpp\n\nDog myDog;\nmyDog.breathe(); // đầu ra: I can breathe\nmyDog.bark(); // đầu ra: Dog barks!\n\n```\n\n## Đa hình\nTính đa hình cho phép bạn sử dụng một giao diện duy nhất để biểu diễn các loại khác nhau. Trong C++, nó chủ yếu đạt được bằng cách sử dụng nạp chồng hàm, hàm ảo và ghi đè. Ví dụ:\n\n```cpp\n\nclass Animal {\npublic:\n    virtual void makeSound() {\n        std::cout << \"The Animal makes a sound\" << std::endl;\n    }\n};\n\nclass Dog : public Animal {\npublic:\n    void makeSound() override {\n        std::cout << \"Dog barks!\" << std::endl;\n    }\n};\n\nclass Cat : public Animal {\npublic:\n    void makeSound() override {\n        std::cout << \"Cat meows!\" << std::endl;\n    }\n};\n\n```\nTrong ví dụ này, chúng ta có một lớp cơ sở Animal với hàm makeSound ảo. Sau đó, chúng tôi lấy được hai lớp, Dog và Cat, ghi đè lên hàm makeSound. Điều này cho phép hành vi đa hình, trong đó một con trỏ Animal hoặc tham chiếu có thể được sử dụng để truy cập đúng hàm makeSound tùy thuộc vào loại lớp dẫn xuất.\n\n```cpp\n\nAnimal *animals[2] = {new Dog, new Cat};\nanimals[0]->makeSound(); // đầu ra: Dog barks!\nanimals[1]->makeSound(); // đầu ra: Cat meows!\n\n```\nĐó là tổng quan ngắn gọn về các khái niệm lập trình hướng đối tượng trong C++."
                },
                {
                    "author": "Dev Alex",
                    "title": " Đa hình tĩnh",
                    "param": "chap-7-5",
                    "level": "beginner",
                    "code": "# Đa hình tĩnh\nĐa hình tĩnh, còn được gọi là đa hình thời gian biên dịch, là một loại đa hình giải quyết các kiểu và lệnh gọi phương thức tại thời điểm biên dịch thay vì trong thời gian chạy. Điều này thường đạt được thông qua việc sử dụng nạp chồng hàm và khuôn mẫu trong C++.\n\n## Nạp chồng hàm\nNạp chồng hàm là cách tạo nhiều hàm có cùng tên nhưng khác danh sách tham số. Trình biên dịch xác định hàm chính xác để gọi dựa trên các loại và số lượng đối số được sử dụng khi hàm được gọi.\n\nVí dụ:\n\n```cpp\n\n#include <iostream>\n\nvoid print(int i) {\n    std::cout << \"Printing int: \" << i << std::endl;\n}\n\nvoid print(double d) {\n    std::cout << \"Printing double: \" << d << std::endl;\n}\n\nvoid print(const char* s) {\n    std::cout << \"Printing string: \" << s << std::endl;\n}\n\nint main() {\n    print(5);          // In cuộc gọi (int i)\n    print(3.14);       // In cuộc gọi (double d)\n    print(\"Hello\");    // In cuộc gọi (const char* s)\n\n    return 0;\n}\n\n```\n\n## Khuôm mẫu\nKhuôn mẫu là một tính năng mạnh mẽ trong C++ cho phép bạn tạo các hàm hoặc lớp chung. Mã code thực tế cho các loại cụ thể được tạo tại thời điểm biên dịch, giúp tránh được chi phí hoạt động đa hình trong thời gian chạy. Việc sử dụng các khuôn mẫu là kỹ thuật chính để đạt được tính đa hình tĩnh trong C++.\n\nVí dụ:\n\n```cpp\n\n#include <iostream>\n\n// hàm khuôn mẫu để in bất kỳ loại nào\ntemplate<typename T>\nvoid print(const T& value) {\n    std::cout << \"Printing value: \" << value << std::endl;\n}\n\nint main() {\n    print(42);           // in\n    print(3.14159);      // gấp đôi \n    print(\"Hello\");      // const char*\n\n    return 0;\n}\n\n```\nTóm lại, đa hình tĩnh đạt được hành vi đa hình trong thời gian biên dịch bằng cách sử dụng nạp chồng hàm và khuôn mẫu, thay vì dựa vào thông tin thời gian chạy như đa hình động. Điều này có thể dẫn đến mã code hiệu quả hơn vì các cuộc gọi phương thức được giải quyết tại thời điểm biên dịch."
                },
                {
                    "author": "Dev Alex",
                    "title": " Nạp chồng hàm",
                    "param": "chap-7-6",
                    "level": "beginner",
                    "code": "# Nạp chồng hàm\nNạp chồng hàm là một kiểu đa hình tĩnh trong C++ trong đó nhiều hàm có cùng tên nhưng khác bộ tham số được định nghĩa trong cùng một phạm vi. Điều này cho phép bạn sử dụng cùng một tên hàm cho nhiều tác vụ bằng cách cung cấp các đối số khác nhau trong khi gọi hàm. Hàm thích hợp để gọi được xác định trong thời gian biên dịch dựa trên số lượng và loại đối số được truyền.\n\nĐể nạp chồng hàm, chỉ cần xác định một hàm khác có cùng tên nhưng một bộ tham số khác. Trình biên dịch sẽ tự động chọn hàm chính xác để gọi dựa trên các đối số được cung cấp.\n\n## Ví dụ\nĐây là một ví dụ minh họa nạp chồng hàm:\n\n```cpp\n\n#include <iostream>\nusing namespace std;\n\nvoid print(int num) {\n    cout << \"Printing int: \" << num << endl;\n}\n\nvoid print(double num) {\n    cout << \"Printing double: \" << num << endl;\n}\n\nvoid print(char const *str) {\n    cout << \"Printing string: \" << str << endl;\n}\n\nint main() {\n    print(5);\n    print(3.14);\n    print(\"Hello, world!\");\n\n    return 0;\n}\n\n```\nTrong ví dụ này, nạp chồng ba hàm có tên print được định nghĩa. Mỗi người nhận một loại đối số khác nhau: int, double và char const *. Khi gọi print() với các đối số khác nhau như 5, 3.14 hoặc \"Hello, world!\", thì hàm thích hợp được chọn dựa trên loại đối số được cung cấp.\n\nĐầu ra của chương trình này sẽ là:\n\n```cpp\n\nPrinting int: 5\nPrinting double: 3.14\nPrinting string: Hello, world!\n\n```\nHãy nhớ rằng số lượng tham số và kiểu của chúng phải khác nhau để nạp chồng hai hàm."
                },
                {
                    "author": "Dev Alex",
                    "title": " Đa hình động",
                    "param": "chap-7-7",
                    "level": "beginner",
                    "code": "# Đa hình động\nĐa hình động là một khái niệm lập trình trong các ngôn ngữ hướng đối tượng như C++, trong đó một lớp dẫn xuất có thể ghi đè hoặc xác định lại các phương thức của lớp cơ sở của nó. Điều này có nghĩa là một lệnh gọi phương thức duy nhất có thể có các triển khai khác nhau dựa trên loại đối tượng mà nó được gọi.\n\nTính đa hình động đạt được thông qua các hàm ảo, là các hàm thành viên của một lớp cơ sở được đánh dấu bằng từ virtual. Khi bạn chỉ định một hàm ảo trong một lớp cơ sở, nó có thể được ghi đè trong bất kỳ lớp dẫn xuất nào để cung cấp một triển khai khác.\n\n## Ví dụ\nĐây là một ví dụ trong C++ thể hiện tính đa hình động.\n\n```cpp\n\n#include <iostream>\n\n// Lớp cơ sở\nclass Shape {\npublic:\n    virtual void draw() {\n        std::cout << \"Drawing a shape\" << std::endl; \n    }\n};\n\n// Dẫn xuất lớp 1\nclass Circle : public Shape {\npublic:\n    void draw() override {\n        std::cout << \"Drawing a circle\" << std::endl; \n    }\n};\n\n// Dẫn xuất lớp 2\nclass Rectangle : public Shape {\npublic:\n    void draw() override {\n        std::cout << \"Drawing a rectangle\" << std::endl;\n    }\n};\n\nint main() {\n    Shape* shape;\n    Circle circle;\n    Rectangle rectangle;\n\n    // Lưu trữ địa chỉ của đường tròn\n    shape = &circle;\n\n    // Gọi hàm vẽ hình tròn\n    shape->draw();\n\n    // Lưu địa chỉ của hình chữ nhật\n    shape = &rectangle;\n\n    // Gọi hàm vẽ hình chữ nhật\n    shape->draw();\n\n    return 0;\n\n```\nMã code này định nghĩa một lớp cơ sở shape với một hàm ảo draw. Hai lớp dẫn xuất Circle và Rectangle đều ghi đè hàm draw để cung cấp các triển khai của riêng chúng. Sau đó, trong hàm main, một con trỏ kiểu Shape được sử dụng để gọi các hàm draw ứng của các đối tượng Circle và rectangle. Đầu ra của chương trình này sẽ là:\n\n```cpp\n\nDrawing a circle\nDrawing a rectangle\n\n```\nNhư bạn có thể thấy, bằng cách sử dụng tính đa hình động, chúng ta có thể xác định trong thời gian chạy phương thức draw nào sẽ được gọi dựa trên loại đối tượng đang được sử dụng."
                },
                {
                    "author": "Dev Alex",
                    "title": " Phương thức ảo",
                    "param": "chap-7-8",
                    "level": "beginner",
                    "code": "# Phương thức ảo\nCác phương thức ảo là một khía cạnh quan trọng của tính đa hình động trong C++. Chúng cho phép các phương thức của lớp con ghi đè lên các phương thức của lớp cơ sở, vì vậy phương thức thích hợp được gọi tùy thuộc vào loại thực tế của một đối tượng trong thời gian chạy.\n\nĐể khai báo một phương thức là ảo, chỉ cần sử dụng từ khóa ảo trong phần khai báo của phương thức trong lớp cơ sở. Điều này cho trình biên dịch biết rằng phương thức nên được coi là một phương thức ảo, cho phép nó bị ghi đè bởi các lớp dẫn xuất.\n\n## Mã code ví dụ\nĐây là một ví dụ minh họa các phương thức ảo:\n\n```cpp\n\n#include <iostream>\n\n// Lớp cơ sở\nclass Shape {\npublic:\n    virtual double area() const {\n        return 0;\n    }\n};\n\n// Lớp được đề xuất\nclass Circle : public Shape {\npublic:\n    Circle(double r) : radius(r) {}\n\n    // Ghi đè phương thức của lớp cơ sở\n    double area() const override {\n        return 3.14 * radius * radius;\n    }\n\nprivate:\n    double radius;\n};\n\n// Lớp được đề xuất\nclass Rectangle : public Shape {\npublic:\n    Rectangle(double w, double h) : width(w), height(h) {}\n\n    // Ghi đè phương thức của lớp cơ sở\n    double area() const override {\n        return width * height;\n    }\n\nprivate:\n    double width;\n    double height;\n};\n\nint main() {\n    Circle c(5);\n    Rectangle r(4, 6);\n\n    Shape* shape = &c;\n    std::cout << \"Circle's area: \" << shape->area() << std::endl;\n\n    shape = &r;\n    std::cout << \"Rectangle's area: \" << shape->area() << std::endl;\n\n    return 0;\n}\n\n```\nTrong ví dụ này, chúng ta định nghĩa một lớp cơ sở Shape có một phương thức ảo area. Phương thức này sau đó được ghi đè bởi các lớp dẫn xuất Circle và Rectangle. Bằng cách sử dụng một phương thức ảo và một con trỏ lớp cơ sở tới các đối tượng dẫn xuất, chúng ta có thể gọi phương thức area thích hợp dựa trên loại đối tượng thực tế khi chạy."
                },
                {
                    "author": "Dev Alex",
                    "title": " Bảng ảo",
                    "param": "chap-7-9",
                    "level": "beginner",
                    "code": "# Bảng ảo\nBảng ảo (hoặc Vtable) là một cơ chế được trình biên dịch C++ sử dụng để hỗ trợ tính đa hình động. Trong đa hình động, hàm thích hợp được gọi trong thời gian chạy, tùy thuộc vào loại đối tượng thực tế.\n\nKhi một lớp chứa một hàm ảo, trình biên dịch sẽ tạo một bảng ảo cho lớp đó. Bảng này chứa các con trỏ hàm tới các hàm ảo được định nghĩa trong lớp. Mỗi đối tượng của lớp đó có một con trỏ tới bảng ảo của nó (vptr, con trỏ ảo), được trình biên dịch tự động khởi tạo trong quá trình xây dựng đối tượng.\n\n## Ví dụ\nHãy xem xét ví dụ sau:\n\n```cpp\n\nclass Base {\npublic:\n    virtual void function1() {\n        std::cout << \"Base::function1\" << std::endl;\n    }\n\n    virtual void function2() {\n        std::cout << \"Base::function2\" << std::endl;\n    }\n};\n\nclass Derived : public Base {\npublic:\n    void function1() override {\n        std::cout << \"Derived::function1\" << std::endl;\n    }\n\n    void function3() {\n        std::cout << \"Derived::function3\" << std::endl;\n    }\n};\n\nint main() {\n    Base* obj = new Derived(); // tạo một đối tượng Derived và gán một con trỏ kiểu Base*\n    obj->function1(); // gọi Derived::function1, do tính đa hình động\n    obj->function2(); // gọi Base::function2\n\n    delete obj;\n    return 0;\n}\n\n```\nTrong ví dụ này, khi một đối tượng Derived được tạo, trình biên dịch sẽ tạo một Vtable cho lớp Derived, chứa các con trỏ tới các hàm ảo của nó:\n- Derived::function1 (được ghi đè từ Base)\n- Base::function2 (kế thừa từ Base)\n\nCon trỏ _vptr_ trong đối tượng Derived trỏ tới Vtable này. Khi function1 được gọi trên con trỏ base đến đối tượng Derived, con trỏ hàm trong Vtable được sử dụng để gọi đúng hàm (trong trường hợp này là Derived::function1). Tương tự, lệnh gọi fuction2 gọi Base::function2, vì đó là con trỏ hàm được lưu trữ trong Vtable cho lớp Derived.\n\nLưu ý rằng function3 không phải là một phần của Vtable, vì nó không phải là một hàm ảo."
                }
            ]
        },
        {
            "title": "Chương 9 Xử lí ngoại lệ",
            "param": "chap-8-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " Tổng quan",
                    "param": "chap-8-0",
                    "level": "beginner",
                    "code": "# Tổng quan\nXử lý ngoại lệ trong C++ là một cơ chế để xử lý các lỗi, sự bất thường hoặc các sự kiện không mong muốn có thể xảy ra trong quá trình thực thi chương trình trong thời gian chạy. Điều này cho phép chương trình tiếp tục chạy hoặc thoát một cách nhẹ nhàng khi gặp lỗi thay vì bị treo đột ngột.\n\nC++ cung cấp một bộ từ khóa và cấu trúc để triển khai xử lý ngoại lệ:\n- try: Xác định một khối mã code cần được theo dõi để phát hiện các ngoại lệ.\n- catch: Chỉ định loại ngoại lệ sẽ bị bắt và khối mã code sẽ được thực thi khi ngoại lệ đó xảy ra\n- throw: Ném một ngoại lệ sẽ bị bắt và xử lý bởi khối bắt thích hợp.\n- noException: Chỉ định một hàm không đưa ra ngoại lệ hoặc chấm dứt chương trình nếu một ngoại lệ được đưa ra trong phạm vi của nó.\n\n## Ví dụ\nĐây là một ví dụ minh họa cách sử dụng cơ bản của xử lý ngoại lệ:\n\n```cpp\n\n#include <iostream>\n\nint divide(int a, int b) {\n    if (b == 0) {\n        throw \"Division by zero!\";\n    }\n    return a / b;\n}\n\nint main() {\n    int num1, num2;\n\n    std::cout << \"Enter two numbers for division: \";\n    std::cin >> num1 >> num2;\n\n    try {\n        int result = divide(num1, num2);\n        std::cout << \"The result is: \" << result << std::endl;\n    } catch (const char* msg) {\n        std::cerr << \"Error: \" << msg << std::endl;\n    }\n\n    return 0;\n}\n\n```\nTrong ví dụ này, chúng ta định nghĩa một hàm divide đưa ra một ngoại lệ nếu b bằng không. Trong hàm main, chúng ta sử dụng khối try để gọi divide và xuất kết quả. Nếu một ngoại lệ được ném ra, nó sẽ bị bắt bên trong khối catch, khối này sẽ xuất ra thông báo lỗi. Bằng cách này, chúng ta có thể xử lý lỗi một cách khéo léo hơn là để chương trình bị lỗi khi cố gắng chia cho 0.\n\n## Tiêu chuẩn ngoại lệ\nC++ cung cấp một tập hợp tiêu chuẩn các lớp ngoại lệ trong thư viện <stdexcept> có thể được sử dụng làm loại ngoại lệ để xử lý lỗi cụ thể hơn. Một số lớp này bao gồm:\n- std::Exception: Lớp cơ sở cho tất cả các ngoại lệ tiêu chuẩn. \n- std::logic_error: Đại diện cho các lỗi có thể được phát hiện tĩnh bởi chương trình.\n- std::runtime_error: Đại diện cho các lỗi xảy ra trong quá trình thực thi chương trình.\n\nĐây là một ví dụ cho thấy cách sử dụng các ngoại lệ tiêu chuẩn:\n\n```cpp\n\n#include <iostream>\n#include <stdexcept>\n\nint divide(int a, int b) {\n    if (b == 0) {\n        throw std::runtime_error(\"Division by zero!\");\n    }\n    return a / b;\n}\n\nint main() {\n    int num1, num2;\n\n    std::cout << \"Enter two numbers for division: \";\n    std::cin >> num1 >> num2;\n\n    try {\n        int result = divide(num1, num2);\n        std::cout << \"The result is: \" << result << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n\n```\nTrong ví dụ này, chúng tôi đã sửa đổi hàm divide để ném std::runtime_error thay vì một chuỗi đơn giản. Khối catch hiện bắt các ngoại lệ xuất phát từ std::Exception và sử dụng hàm thành viên what() để hiển thị thông báo lỗi."
                },
                {
                    "author": "Dev Alex",
                    "title": " Mã code exit",
                    "param": "chap-8-1",
                    "level": "beginner",
                    "code": "# Mã code exit\nMã code exit, còn được gọi là \"mã trả về\" hoặc \"mã trạng thái\", là các giá trị số mà chương trình trả về môi trường gọi (thường là hệ điều hành) khi chương trình kết thúc thực thi. Các mã code này được sử dụng để chỉ ra sự thành công hay thất bại của việc thực hiện chương trình.\n\n0 là mã thoát tiêu chuẩn để thực thi thành công, trong khi các mã code thoát khác 0 thường biểu thị lỗi hoặc các tình huống ngoại lệ khác. Ý nghĩa thực tế của các mã  code thoát khác không có thể khác nhau giữa các ứng dụng hoặc hệ thống khác nhau.\nTrong C++, bạn có thể trả về mã code thoát từ hàm main bằng cách sử dụng câu lệnh return hoặc bạn có thể sử dụng hàm exit(), là một phần của Thư viện chuẩn C++.\n\n\n## Ví dụ: Sử dụng return trong main\n\n```cpp\n\n#include <iostream>\n\nint main() {\n    // một số mã code ở đây...\n\n    if (/*some error condition*/) {\n        std::cout << \"An error occurred.\" << std::endl;\n        return 1;\n    }\n\n    // một số mã code ở đây...\n\n    if (/*another error condition*/) {\n        std::cout << \"Another error occurred.\" << std::endl;\n        return 2;\n    }\n\n    return 0; // Thực hiện thành công\n}\n\n```\n\n## Ví dụ: Sử dụng hàm exit()\n\n```cpp\n\n#include <iostream>\n#include <cstdlib>\n\nvoid some_function() {\n    // một số mã code ở đây...\n\n    if (/*some error condition*/) {\n        std::cout << \"An error occurred.\" << std::endl;\n        std::exit(1);\n    }\n\n    // một số  mã code ở đây...\n}\n\nint main() {\n    some_function();\n\n    // một số mã code khác ở đây...\n\n    return 0; // thực hiện thành công \n}\n\n```\nTrong cả hai ví dụ trên, chương trình trả về các mã code thoát tùy thuộc vào các điều kiện lỗi khác nhau gặp phải trong quá trình thực thi. Mã code 1 và 2 được sử dụng để phân biệt giữa hai tình trạng lỗi."
                },
                {
                    "author": "Dev Alex",
                    "title": " Xử lý ngoại lệ trong C++",
                    "param": "chap-8-2",
                    "level": "beginner",
                    "code": "# Xử lý ngoại lệ trong C++\nXử lý ngoại lệ là một phương pháp được sử dụng để khắc phục các lỗi thời gian chạy để có thể duy trì dòng chảy bình thường của chương trình. Trong C++, điều này được thực hiện bằng ba từ khóa: try, catch và throw.\n\n## Try { … }\nTrong khối try, bạn viết mã code có khả năng tạo ngoại lệ. Nếu gặp phải ngoại lệ, quyền kiểm soát sẽ được chuyển đến khối catch có liên quan để xử lý sự cố.\n\nVí dụ:\n\n```cpp\n\ntry {\n  // mã code có thể ném một ngoại lện\n}\n\n```\n\n## Catch (…) { … }\nKhối catch theo sau khối try và chịu trách nhiệm xử lý các ngoại lệ do khối try đưa ra. Có thể có nhiều khối catch để xử lý các loại ngoại lệ khác nhau.\n\nVí dụ:\n\n```cpp\n\ncatch (int e) {\n  //xử lý ngoại lệ kiểu int\n}\ncatch (char e) {\n  // /xử lý ngoại lệ kiểu char\n}\ncatch (...) {\n  // xử lý bất kỳ ngoại lệ nào khác\n}\n\n```\n\n## throw … ;\nTrong trường hợp xảy ra lỗi trong khối try, bạn có thể sử dụng từ khóa throw để tạo ngoại lệ cho loại cụ thể. Điều này sau đó sẽ được catch và xử lý bởi khối bắt tương ứng.\n\nVí dụ:\n\n```cpp\n\ntry {\n  int num1 = 10, num2 = 0;\n  if (num2 == 0) {\n    throw \"Division by zero not allowed!\";\n  } else {\n    int result = num1 / num2;\n    cout << \"Result: \" << result << endl;\n  }\n}\ncatch (const char* e) {\n  cout << \"Error: \" << e << endl;\n}\n\n```\nTóm lại, xử lý ngoại lệ trong C++ là một kỹ thuật để xử lý các lỗi thời gian chạy trong khi vẫn duy trì luồng bình thường của chương trình. Các từ khóa try, catch và throw được sử dụng cùng nhau để tạo cấu trúc xử lý các trường hợp ngoại lệ khi chúng xảy ra."
                },
                {
                    "author": "Dev Alex",
                    "title": " Vi phạm quyền truy cập",
                    "param": "chap-8-3",
                    "level": "beginner",
                    "code": "# Vi phạm quyền truy cập\nVi phạm quyền truy cập là một loại lỗi cụ thể xảy ra khi một chương trình cố gắng truy cập vào một vị trí bộ nhớ không hợp lệ. Trong C++, vi phạm quyền truy cập phổ biến nhất là do:\n- truy cập tới dữ liệu trong vị trí bộ nhớ được trỏ tới một null hoặc con trỏ không hợp lệ.\n- Truy cập một mảng ngoài giới hạn.\n- Đọc hoặc ghi vào bộ nhớ được giải phóng bởi người dùng hoặc hệ điều hành.\n\nĐiều quan trọng là xác định các vi phạm quyền truy cập vì chúng có thể dẫn đến hành vi không thể đoán trước, sự cố ứng dụng hoặc hỏng dữ liệu.\n\nMột số ví dụ về vi phạm quyền truy cập là:\n\n## Dereferencing null hoặc con trỏ không hợp lệ\n\n```cpp\n\nint *p = nullptr;\nint x = *p;  // Vi phạm quyền truy cập: cố gắng truy cập nội dung của con trỏ null\n\n```\n\n## Truy cập một mảng ngoài giới hạn\n\n```cpp\n\nint arr[5] = {1, 2, 3, 4, 5};\nint y = arr[5];  // Vi phạm quyền truy cập: chỉ mục nằm ngoài giới hạn (chỉ số hợp lệ là 0-4)\n\n```\n\n## Đọc hoặc ghi vào bộ nhớ được giải phóng\n\n```cpp\n\nint* p2 = new int[10];\ndelete[] p2;\np2[3] = 42;  // Vi phạm quyền truy cập: ghi vào bộ nhớ đã được giải phóng\n\n```\n\n## Gỡ lỗi vi phạm quyền truy cập\nCác công cụ như trình gỡ lỗi, trình phân tích tĩnh và trình lập hồ sơ có thể giúp xác định các vi phạm quyền truy cập trong mã code của bạn. Ví dụ:\n- **Microsoft Visual Studio:** Sử dụng trình gỡ lỗi tích hợp sẵn để xác định dòng mã code chịu trách nhiệm về lỗi vi phạm quyền truy cập.\n- **Valgrind:** Một công cụ Linux phổ biến giúp phát hiện rò rỉ bộ nhớ và vi phạm quyền truy cập trong các chương trình C++ của bạn.\n- **AddressSanitizer:** Trình phát hiện lỗi bộ nhớ thời gian chạy cho C++ có thể phát hiện các truy cập vượt quá giới hạn, rò rỉ bộ nhớ và lỗi sử dụng sau khi sử dụng miễn phí.\n"
                }
            ]
        },
        {
            "title": "Chương 10 Khái niệm quan trọng",
            "param": "chap-9-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " Khái niệm ngôn ngữ trong C++",
                    "param": "chap-9-0",
                    "level": "beginner",
                    "code": "# Khái niệm ngôn ngữ trong C++\nC ++ là một ngôn ngữ lập trình hướng đối tượng, cấp cao, mạnh mẽ, cung cấp một số khái niệm ngôn ngữ chính. Những khái niệm này cung cấp nền tảng để bạn có thể xây dựng các chương trình hiệu quả, đáng tin cậy và có thể bảo trì được. Dưới đây là tóm tắt ngắn gọn về một số khái niệm ngôn ngữ quan trọng trong C++.\n\n## Biến và kiểu dữ liệu\nC++ cung cấp các kiểu dữ liệu cơ bản khác nhau như int, float, double, char và bool để khai báo và thao tác các biến trong chương trình.\n\nVí dụ:\n\n```cpp\n\nint age = 25;\nfloat height = 1.7f;\ndouble salary = 50000.0;\nchar grade = 'A';\nbool isEmployed = true;\n\n```\n\n## Cấu trúc điều khiển\nCác cấu trúc điều khiển cho phép bạn điều khiển luồng thực hiện của một chương trình. Các cấu trúc điều khiển chính trong C++ bao gồm:\n- Câu lệnh điều kiện: if, else, và else if\n- Cấu trúc vòng lặp: for, while và do-while\n- Xây dựng Switch-case\n\nVí dụ:\n\n```cpp\n\n// Câu lệnh If-else \nif (age > 18) {\n    cout << \"You are eligible to vote.\";\n} else {\n    cout << \"You are not eligible to vote.\";\n}\n\n// vòng lặp For \nfor (int i = 0; i < 5; i++) {\n    cout << \"Hello World!\";\n}\n\n```\n\n## Hàm\nCác hàm trong C++ cho phép bạn chia một chương trình lớn thành các đoạn mã code nhỏ, dễ quản lý và có thể tái sử dụng.\n\nVí dụ:\n\n```cpp\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int sum = add(10, 20);\n    cout << \"The sum is: \" << sum;\n    return 0;\n}\n\n```\n\n## Mảng và vectơ\nMảng và Vectơ là các cấu trúc dữ liệu thường được sử dụng để lưu trữ và thao tác với một tập hợp các phần tử của cùng một kiểu dữ liệu.\n\nVí dụ:\n\n```cpp\n\n// mảng\nint marks[] = {90, 80, 95, 85};\n\n// Vector\nvector<int> scores = {10, 20, 30, 40};\n\n```\n\n## Con trỏ\nCon trỏ là biến lưu trữ địa chỉ bộ nhớ của các biến khác. Chúng cho phép xử lý bộ nhớ hiệu quả hơn và rất hữu ích khi làm việc với các cấu trúc dữ liệu động.\n\nVí dụ:\n\n```cpp\n\nint num = 10;\nint* p = &num; //p lưu trữ địa chỉ của num\n\n```\n\n## Cấu trúc và Lớp\nCấu trúc và Lớp là các kiểu dữ liệu do người dùng định nghĩa cho phép nhóm các biến và hàm dưới một tên duy nhất\n\nVí dụ:\n\n```cpp\n\n// Cấu trúc\nstruct Student {\n    string name;\n    int age;\n};\n\n// Lớp\nclass Employee {\npublic:\n    string name;\n    int age;\n    void displayInfo() {\n        cout << \"Name: \" << name << \"\\nAge: \" << age;\n    }\n};\n\n```\n\n## Kế thừa và đa hình\nKế thừa là một cơ chế cho phép một lớp kế thừa các thuộc tính và phương thức từ một lớp cơ sở. Tính đa hình cho phép bạn sử dụng một kiểu lớp cơ sở để biểu diễn các đối tượng của lớp dẫn xuất.\n\nVí dụ:\n\n```cpp\n\nclass Base {\npublic:\n    void display() {\n        cout << \"This is the base class.\";\n    }\n};\n\nclass Derived : public Base {\npublic:\n    void display() {\n        cout << \"This is the derived class.\";\n    }\n};\n\n```\n\n## Xử lý ngoại lệ\nC++ cung cấp một cơ chế để xử lý các ngoại lệ (lỗi thời gian chạy) một cách duyên dáng bằng cách sử dụng các cấu trúc try, catch và throw.\n\nVí dụ:\n\n```cpp\n\ntry {\n    //Mã code có thể ném một ngoại lệ\n    int result = a / b;\n} catch (const exception &e) {\n    cout << \"Caught an exception: \" << e.what();\n}\n\n```\nĐây là một số khái niệm ngôn ngữ chính trong C++, sẽ giúp bạn hiểu ngôn ngữ này tốt hơn và phát triển các ứng dụng hiệu quả và có thể bảo trì được.\n"
                },
                {
                    "author": "Dev Alex",
                    "title": " Macro C++",
                    "param": "chap-9-1",
                    "level": "beginner",
                    "code": "# Macro C++\nMacro là các chỉ thị tiền xử lý trong C++ được bộ tiền xử lý sử dụng để thực hiện thay thế văn bản. Chúng được xác định bằng chỉ thị #define, theo sau là tên macro và giá trị được thay thế.\n\nMacro có thể được sử dụng để xác định hằng số, tạo macro giống hàm hoặc thực hiện quá trình biên dịch có điều kiện.\n\n## Macro liên tục\nCác macro không đổi được sử dụng để xác định các hằng số tượng trưng để sử dụng trong mã code. Chúng không sử dụng bất kỳ bộ nhớ nào và được thay thế bởi bộ tiền xử lý trước quá trình biên dịch.\n\nVí dụ:\n\n```cpp\n\n#define PI 3.14159\n\n```\nMacro này định nghĩa một hằng số tượng trưng PI. Bạn có thể sử dụng nó trong mã code của mình như thể nó là một biến thông thường.\n\n```cpp\n\ndouble circumference = 2 * PI * radius;\n\n```\n\n## Hàm giống như Macro\nCác macro giống như hàm tương tự như các hàm thông thường. Họ lấy một danh sách các đối số và thực hiện thay thế văn bản.\n\nVí dụ:\n\n```cpp\n\n#define SQUARE(x) ((x) * (x))\n\n```\nMacro này định nghĩa một hàm giống macro SQUARE để tính bình phương của một số.\n\n```cpp\n\nint square_of_five = SQUARE(5); // mở rộng thành ((5) * (5))\n\n```\n\n## Biên dịch có điều kiện\nMacro có thể được sử dụng để biên dịch có điều kiện bằng cách sử dụng các chỉ thị #ifdef, #ifndef, #if, #else, #elif và #endif.\n\nVí dụ:\n\n```cpp\n\n#define DEBUG_MODE\n\n#ifdef DEBUG_MODE\n  // Mã code chỉ được biên dịch trong chế độ gỡ lỗi\n#else\n  // Mã code chỉ được biên dịch nếu DEBUG_MODE không được xác định\n#endif\n\n```\nVí dụ này minh họa cách bạn có thể sử dụng macro để kiểm soát các phần mã code đang được biên dịch, tùy thuộc vào việc có hay không có định nghĩa macro.\n"
                },
                {
                    "author": "Dev Alex",
                    "title": " Tự động (Loại Trừ kiểu Tự Động)",
                    "param": "chap-9-10",
                    "level": "beginner",
                    "code": "# Tự động (Loại Trừ kiểu Tự Động)\n\n## Tự động\nauto là một từ khóa trong ngôn ngữ C++ được giới thiệu trong C++11, được sử dụng để loại trừ tự động. Nó tự động suy ra loại biến từ loại biểu thức khởi tạo của nó tại thời điểm biên dịch.\nTừ khóa auto rất hữu ích khi bạn đang xử lý các loại phức tạp hoặc khi loại biến khó dự đoán. Nó có thể giúp viết mã code sạch hơn và ít bị lỗi hơn.\n\nĐây là một ví dụ đơn giản về việc sử dụng auto để loại trừ kiểu:\n\n```cpp\n\n#include <iostream>\n#include <vector>\n\nint main() {\n    // Cách khai báo biến truyền thống:\n    int myInt = 5;\n\n    // Sử dụng auto để loại trừ:\n    auto myAutoInt = 5; // Automatically deduces the type as 'int'\n\n    // Ví dụ với các kiểu phức tạp hơn:\n    std::vector<int> myVector = {1, 2, 3, 4, 5};\n\n    // Không có auto, việc lặp lại vector sẽ như thế này:\n    for (std::vector<int>::iterator it = myVector.begin(); it != myVector.end(); ++it) {\n        std::cout << *it << std::endl;\n    }\n\n    // Với auto, việc khai báo iterator trở nên đơn giản hơn:\n    for (auto it = myVector.begin(); it != myVector.end(); ++it) {\n        std::cout << *it << std::endl;\n    }\n}\n\n```\nHãy nhớ rằng auto suy ra loại dựa trên biểu thức khởi tạo, vì vậy nếu bạn không cung cấp giá trị ban đầu, bạn sẽ gặp lỗi thời gian biên dịch:\n\n```cpp\n\nauto myVar; // Lỗi: Không thể suy ra loại mà không có bộ khởi tạo\n\n```\nTrong C++14, bạn cũng có thể sử dụng auto với các kiểu trả về của hàm để trình biên dịch tự động suy ra kiểu trả về dựa trên biểu thức được trả về:\n\n```cpp\n\nauto add(int x, int y) {\n    return x + y; // Trình biên dịch suy ra kiểu trả về là 'int'\n}\n\n```"
                },
                {
                    "author": "Dev Alex",
                    "title": " Xáo trộn tên",
                    "param": "chap-9-2",
                    "level": "beginner",
                    "code": "# Xáo trộn tên\nXáo trộn tên, còn được gọi là trang trí tên, là một kỹ thuật được trình biên dịch sử dụng để mã code hóa thông tin bổ sung về phạm vi, loại, liên kết hoặc thông tin nhận dạng khác của một mã code định danh (tên hàm, tên biến, v.v.) trong tên của nó. Mục đích chính của xáo trộn tên là để hỗ trợ nạp chồng hàm, cho phép nhiều hàm có cùng tên nhưng danh sách tham số khác nhau cùng tồn tại trong một chương trình.\n\nTrong C++, trình biên dịch tạo ra một tên đọc sai cho mỗi hàm và biến dựa trên phạm vi và kiểu của chúng. Tên đọc sai thường được hình thành bằng cách ghép tên gốc, loại tham số và thông tin khác, thường sử dụng tiền tố hoặc hậu tố.\n\nVí dụ: giả sử bạn có hàm sau:\n\n```cpp\n\nint add(int a, int b)\n{\n    return a + b;\n}\n\n```\nTrình biên dịch có thể tạo ra một tên đọc sai, chẳng hạn như _Z3addii, mã code hóa tên hàm add và hai tham số int của nó.\n\nCác quy tắc chính xác cho việc xáo trộn tên phụ thuộc vào việc triển khai và nền tảng. Các trình biên dịch khác nhau có thể xáo trộn các tên khác nhau, điều này có thể dẫn đến sự không tương thích khi cố gắng liên kết các tệp đối tượng hoặc thư viện được biên dịch với các trình biên dịch khác nhau.\n\nMột số công cụ, chẳng hạn như bộ lọc C++ (có trong GCC và Clang), có thể được sử dụng để tách tên bị đọc sai trở lại mã code định danh ban đầu, điều này có thể hữu ích khi gỡ lỗi hoặc làm việc với các bảng ký hiệu.\n\n```cpp\n\n$ echo \"_Z3addii\" | c++filt\nadd(int, int)\n\n```\nNói chung, bạn không cần phải hiểu chi tiết về xáo trộn tên khi viết mã code trong C++, vì trình biên dịch sẽ tự động xử lý việc này. Tuy nhiên, nó có thể ảnh hưởng đến hành vi của chương trình trong một số trường hợp, chẳng hạn như khi sử dụng các thư viện bên ngoài hoặc liên kết các tệp đối tượng từ các trình biên dịch khác nhau."
                },
                {
                    "author": "Dev Alex",
                    "title": " Tra cứu phụ thuộc đối số (ADL)",
                    "param": "chap-9-3",
                    "level": "beginner",
                    "code": "# Tra cứu phụ thuộc đối số (ADL)\nTra cứu phụ thuộc đối số (ADL) hoặc Tra cứu Koenig là một cơ chế trong C++ cho phép trình biên dịch tìm kiếm hàm thích hợp để gọi dựa trên các loại đối số được cung cấp. Nó đặc biệt hữu ích khi sử dụng các hàm hoặc toán tử quá tải trong một không gian tên.\n\nADL cho phép trình biên dịch tìm các hàm trong cùng một không gian tên với các đối số, ngay cả khi hàm không được khai báo tại điểm sử dụng hoặc trong không gian tên được cung cấp. Điều này đặc biệt hữu ích khi làm việc với các mẫu hoặc lập trình chung.\n\n## Ví dụ\nHãy xem xét ví dụ sau sử dụng không gian tên và nạp chồng operator<<():\n\n```cpp\n\nnamespace MyNamespace {\n    class MyClass {\n    public:\n        int value;\n    };\n\n    std::ostream& operator<<(std::ostream& os, const MyClass& obj) {\n        os << \"MyClass: \" << obj.value;\n        return os;\n    }\n}\n\nint main() {\n    MyNamespace::MyClass obj;\n    obj.value = 42;\n    using std::cout; // Bắt buộc phải sử dụng 'cout' mà không đủ điều kiện cho nó.\n    cout << obj << std::endl; // ADL được sử dụng để nạp chồng 'operator<<'.\n}\n\n```\nTrong ví dụ này, khi bạn gọi cout << obj; trong main(), ADL được sử dụng để tìm đúng nạp chồng operator<<() trong không gian tên MyNamespace vì đối số obj thuộc loại MyNamespace::MyClass."
                },
                {
                    "author": "Dev Alex",
                    "title": " Hành vi không xác định (UB)",
                    "param": "chap-9-4",
                    "level": "beginner",
                    "code": "# Hành vi không xác định (UB)\n\n## Hành vi không xác định\nHành vi không xác định trong C ++ đề cập đến tình huống không thể dự đoán hành vi của chương trình do vi phạm bất kỳ quy tắc ngôn ngữ nào. Đó là kết quả của nhiều yếu tố như biến chưa được khởi tạo, sử dụng con trỏ để giải phóng bộ nhớ, truy cập bộ nhớ ngoài giới hạn, v.v. Tiêu chuẩn C++ không xác định hành vi trong các trường hợp như vậy, có nghĩa là trình biên dịch hoặc hệ thống thời gian chạy được tự do thực hiện xử lý những tình huống này theo bất kỳ cách nào nó muốn.\n\nMột số ví dụ phổ biến về Hành vi không xác định là:\n- **Biến chưa được khởi tạo:**  Việc truy cập giá trị của biến chưa được khởi tạo có thể dẫn đến hành vi không xác định. Giá trị của biến chưa được khởi tạo là tùy ý và phụ thuộc vào giá trị trong vị trí bộ nhớ trước khi biến được khai báo.\n\n```cpp\n\nint x;\nint y = x + 5; // Hành vi không xác định do x chưa được khởi tạo\n\n```\n- **Truy cập bộ nhớ ngoài giới hạn:** Truy cập bộ nhớ ngoài ranh giới của một mảng hoặc bộ đệm có thể dẫn đến hành vi không xác định.\n\n```cpp\n\nint arr[5];\nint val = arr[5]; // Hành vi không xác định vì các chỉ số hợp lệ là 0 đến 4\n\n```\n- **Không tham chiếu con trỏ null:** Hủy tham chiếu một con trỏ null có thể dẫn đến hành vi không xác định.\n\n```cpp\n\nint *ptr = nullptr;\nint val = *ptr; // Hành vi không xác định vì ptr là một con trỏ null\n\n```\n- **Chia cho không:** Thực hiện thao tác chia cho số không là hành vi không xác định trong C++.\n\n```cpp\n\nint x = 5;\nint y = 0;\nint z = x / y; // Hành vi không xác định vì phép chia cho 0 không được phép\n\n```\nĐiều quan trọng là phải phát hiện và khắc phục nguyên nhân gốc rễ của hành vi không xác định trong chương trình của bạn vì nó có thể dẫn đến kết quả không thể đoán trước, hỏng dữ liệu và lỗ hổng bảo mật. Để giảm thiểu hành vi không xác định, bạn có thể sử dụng các công cụ như bộ phân tích mã code tĩnh, công cụ phân tích động và các tùy chọn trình biên dịch giúp phát hiện các sự cố tiềm ẩn."
                },
                {
                    "author": "Dev Alex",
                    "title": " Truyền kiểu trong C++",
                    "param": "chap-9-5",
                    "level": "beginner",
                    "code": "# Truyền kiểu trong C++\nTruyền kiểu là quá trình chuyển đổi một giá trị từ kiểu dữ liệu này sang kiểu dữ liệu khác. Trong C++, có bốn phương pháp ép kiểu khác nhau:\n- **Truyền kiểu C:**  Đó là cú pháp kế thừa từ C và nó được thực hiện bằng cách đặt kiểu dữ liệu đích trong ngoặc đơn trước giá trị cần truyền. Ví dụ:\n\n```cpp\n\nint a = 10;\nfloat b = (float)a;  // Truyền kiểu C từ int sang float\n\n```\n- static_cast: Đây là phương thức được sử dụng phổ biến nhất để truyền kiểu trong C++. Nó được thực hiện tại thời điểm biên dịch và bạn nên sử dụng nó khi bạn có một chuyển đổi rõ ràng giữa các loại dữ liệu. Ví dụ:\n\n```cpp\n\nint a = 10;\nfloat b = static_cast<float>(a);  // static_cast từ int sang float\n\n```\n- dynamic_cast: Phương thức này được sử dụng cụ thể để chuyển đổi an toàn các con trỏ và tham chiếu giữa các lớp cơ sở và lớp dẫn xuất trong hệ thống phân cấp lớp. Ví dụ:\n\n```cpp\n\nclass Base {};\nclass Derived : public Base {};\n\nBase* base_ptr = new Derived();\nDerived* derived_ptr = dynamic_cast<Derived*>(base_ptr);  // dynamic_cast from Base* to Derived*\n\n```\n- reinterpret_cast: Truyền này thay đổi loại con trỏ, tham chiếu hoặc giá trị số nguyên. Nó còn được gọi là ép kiểu bit vì nó thay đổi cách trình biên dịch diễn giải các bit bên dưới. Chỉ sử dụng reinterpret_cast khi bạn hiểu sâu về những gì mình đang làm, vì nó không đảm bảo rằng giá trị thu được sẽ có ý nghĩa. Ví dụ:\n\n```cpp\n\nint* a = new int(42);\nlong b = reinterpret_cast<long>(a);  //reinterpret_cast từ int* thành long\n\n```\n- const_cast: Phương pháp truyền này được sử dụng để loại bỏ bộ định tính const khỏi một biến. Nó thường không được khuyến nghị, nhưng có thể hữu ích trong một số trường hợp khi bạn không kiểm soát được hằng số của một biến. Ví dụ:\n\n```cpp\n\nconst int a = 10;\nint* ptr = const_cast<int*>(&a);  // const_cast từ const int* sang int*\n*ptr = 20;  // Không nên dùng, thận trọng khi sử dụng\n\n```\nHãy nhớ sử dụng đúng loại truyền dựa trên tình huống cụ thể và tuân theo các phương pháp lập trình tốt để đảm bảo mã an toàn và hiệu quả."
                },
                {
                    "author": "Dev Alex",
                    "title": "  Static Cast",
                    "param": "chap-9-6",
                    "level": "beginner",
                    "code": "#  Static Cast\nstatic_cast là một trong những toán tử ép kiểu trong C++ cho phép bạn chuyển đổi giữa các loại dữ liệu khác nhau, chẳng hạn như số nguyên và số float hoặc giữa các loại con trỏ. Loại truyền này thực hiện kiểm tra thời gian biên dịch và đưa ra lỗi nếu không thể chuyển đổi hợp lệ giữa các loại đã cho. static_cast nói chung an toàn hơn so với ép kiểu C vì nó không thực hiện diễn giải lại dữ liệu không an toàn và cho phép kiểm tra kiểu tốt hơn.\n\n## Cú pháp\nCú pháp của static_cast như sau:\n\n```cpp\n\nstatic_cast<new_type>(expression)\n\n```\n\n## Ví dụ \n- Chuyển đổi giữa các kiểu dữ liệu cơ bản:\n\n```cpp\n\nint i = 42;\nfloat f = static_cast<float>(i); // Chuyển đổi số nguyên i thành float f\n\n```\n- Con trỏ casting của các loại đối tượng khác nhau trong hệ thống phân cấp thừa kế:\n\n```cpp\n\nclass Base { /* ... */ };\nclass Derived : public Base { /* ... */ };\n\nBase *bPtr = new Derived;\nDerived *dPtr = static_cast<Derived *>(bPtr); // Chuyển đổi con trỏ Cơ sở bPtr thành Con trỏ dẫn xuất dPtr\n\n```\n- Chuyển đổi một số nguyên thành liệt kê:\n\n```cpp\n\nenum Color { RED, GREEN, BLUE };\nint value = 1;\nColor color = static_cast<Color>(value); // Chuyển đổi giá trị số nguyên thành kiểu liệt kê Màu tương ứng\n\n```\nHãy nhớ rằng nên thận trọng khi sử dụng static_cast khi truyền con trỏ giữa các loại đối tượng khác nhau. Nếu loại ban đầu của con trỏ không khớp với loại mục tiêu, kết quả của phép truyền có thể không chính xác hoặc gây ra hành vi không mong muốn."
                },
                {
                    "author": "Dev Alex",
                    "title": " Const_cast",
                    "param": "chap-9-7",
                    "level": "beginner",
                    "code": "# Const_cast\nconst_cast là một kiểu ép kiểu trong C++ cho phép bạn loại bỏ hoặc thêm hằng số vào một biến. Nói cách khác, nó cho phép bạn sửa đổi một const hoặc volatile, hoặc thay đổi một con trỏ hoặc tham chiếu thành một kiểu const hoặc volatile. Điều này hữu ích trong một số tình huống nhất định khi bạn cần chuyển một biến const làm đối số hoặc khi tham số hàm yêu cầu loại không phải const, nhưng bạn muốn đảm bảo rằng biến đó không đổi trong toàn bộ mã code.\n\nHãy nhớ rằng việc sử dụng const_cast để sửa đổi một biến const thực sự có thể dẫn đến hành vi không xác định, vì vậy tốt nhất là chỉ sử dụng tính năng này khi thực sự cần thiết.\n\n## Ví dụ\nĐây là một ví dụ mã code cho thấy cách sử dụng const_cast:\n\n```cpp\n\n#include <iostream>\n\nvoid modifyVariable(int* ptr) {\n    *ptr = 42;\n}\n\nint main() {\n    const int original_value = 10;\n    int* non_const_value_ptr = const_cast<int*>(&original_value);\n    std::cout << \"Original value: \" << original_value << std::endl;\n\n    modifyVariable(non_const_value_ptr);\n    std::cout << \"Modified value: \" << *non_const_value_ptr << std::endl;\n\n    return 0;\n}\n\n```\nTrong ví dụ này, trước tiên chúng ta tạo một biến const, original_value. Sau đó, sử dụng const_cast để loại bỏ hằng số của biến và gán nó cho một con trỏ không phải là const, non_const_value_ptr. Hàm modVariable lấy một int* làm đối số và sửa đổi giá trị được chỉ bởi con trỏ, điều này sẽ không thể thực hiện được nếu chúng ta chuyển trực tiếp const int ban đầu. Cuối cùng, chúng tôi in giá trị gốc và *non_const_value_ptr, cho biết giá trị đã được sửa đổi bằng cách sử dụng const_cast.\n\nXin lưu ý rằng ví dụ này đi kèm với một số rủi ro vì nó liên quan đến hành vi không xác định. "
                },
                {
                    "author": "Dev Alex",
                    "title": " Dynamic Cast ",
                    "param": "chap-9-8",
                    "level": "beginner",
                    "code": "# Dynamic Cast \ndynamic_cast là một loại toán tử truyền trong C++ được sử dụng riêng cho tính đa hình. Nó chuyển đổi an toàn các con trỏ và tham chiếu của một lớp cơ sở sang lớp dẫn xuất của nó và kiểm tra tính hợp lệ của chuyển đổi trong thời gian chạy. Nếu chuyển đổi không hợp lệ (nghĩa là đối tượng không thuộc loại mục tiêu), nó sẽ trả về một con trỏ null thay vì tạo ra hành vi không xác định. Do đó, dynamic_cast có thể ngăn ngừa sự cố và lỗi tiềm ẩn khi sử dụng tính đa hình.\n\nĐây là một ví dụ cơ bản về cách sử dụng dynamic_cast:\n\n```cpp\n\n#include <iostream>\n\nclass BaseClass {\n   public:\n    virtual void display() {\n        std::cout << \"BaseClass\" << std::endl;\n    }\n};\n\nclass DerivedClass : public BaseClass {\n   public:\n    void display() {\n        std::cout << \"DerivedClass\" << std::endl;\n    }\n};\n\nint main() {\n    BaseClass *basePtr = new DerivedClass();  // Upcasting\n    DerivedClass *derivedPtr;\n\n    derivedPtr = dynamic_cast<DerivedClass *>(basePtr);  // Downcasting\n    if (derivedPtr) {\n        derivedPtr->display();  // đầu ra: lớp được đề xuất\n    } else {\n        std::cout << \"Invalid type conversion.\";\n    }\n\n    delete basePtr;\n    return 0;\n}\n\n```\nTrong ví dụ này, một con trỏ tới một đối tượng DerivedClass được gán cho một con trỏ BaseClass (basePtr). Sau đó, chúng tôi cố gắng truyền xuống nó trở lại con trỏ DerivedClass bằng cách sử dụng dynamic_cast. Nếu truyền thành công, chúng ta có thể truy cập hàm DerivedClass thông qua con trỏ mới (derivedPtr)."
                },
                {
                    "author": "Dev Alex",
                    "title": " reinterpret_cast ",
                    "param": "chap-9-9",
                    "level": "beginner",
                    "code": "# reinterpret_cast \nreinterpret_cast là một kiểu ép kiểu trong C++ cho phép bạn thay đổi kiểu của một con trỏ hoặc một số nguyên mà không làm thay đổi cách biểu diễn dữ liệu. Nó thường được sử dụng khi yêu cầu chuyển đổi ở mức quá thấp hoặc không được hỗ trợ bởi các phương thức truyền khác, chẳng hạn như static_cast.\n\nViệc sử dụng reinterpret_cast nên được xử lý cẩn thận vì nó có thể dẫn đến hành vi không xác định và các sự cố nghiêm trọng nếu sử dụng không đúng cách.\n\nĐây là một ví dụ về cách sử dụng:\n\n```cpp\n\n#include <iostream>\n\nint main() {\n    int num = 42;\n    int *num_ptr = &num;\n\n    // Cải trang con trỏ số nguyên thành con trỏ char\n    char *char_ptr = reinterpret_cast<char *>(num_ptr);\n\n    for (size_t i = 0; i < sizeof(int); ++i) {\n        //In các byte riêng lẻ của số nguyên dưới dạng ký tự\n        std::cout << \"Byte \" << i << \": \" << char_ptr[i] << std::endl;\n    }\n\n    return 0;\n}\n\n```\nTrong ví dụ này, chúng tôi đang sử dụng reinterpret_cast để thay đổi loại con trỏ từ int * thành char *, xử lý hiệu quả số nguyên dưới dạng một mảng ký tự và in từng byte.\n\nHãy nhớ rằng khi sử dụng reinterpret_cast, bạn nên thận trọng về việc hủy tham chiếu các con trỏ đã chuyển đổi. Hành vi này có thể không dự đoán được và có thể dẫn đến các sự cố, chẳng hạn như truy cập vào các vùng bộ nhớ không dành cho mục đích truy cập. reinterpret_cast nên được sử dụng ít và chỉ khi cần chuyển đổi cấp thấp."
                }
            ]
        },
        {
            "title": "Chương 11 Thư viện STL",
            "param": "chap-10-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " THƯ VIỆN TEMPLATE CHUẨN C++ (STL)",
                    "param": "chap-10-0",
                    "level": "beginner",
                    "code": "# THƯ VIỆN TEMPLATE CHUẨN C++ (STL)\nThư viện template chuẩn C++ (STL) là tập hợp các tệp tiêu đề cung cấp một số cấu trúc dữ liệu, thuật toán và hàm để đơn giản hóa trải nghiệm viết mã code C++ của bạn. Mục đích chính của STL là tiết kiệm thời gian và tăng hiệu quả bằng cách cung cấp một bộ công cụ hữu ích sẵn sàng để sử dụng. Các tính năng được sử dụng phổ biến nhất của STL có thể được chia thành ba loại chính: vùng lưu trữ, thuật toán và trình vòng lặp.\n\n## Vùng lưu trữ\n- **Lưu trữ trình tự:** Đây là các cấu trúc dữ liệu tuyến tính lưu trữ các phần tử theo cách tuần tự. Ví dụ bao gồm:\n  - std::vector: Một mảng động phát triển và thu hẹp lại trong thời gian chạy.\n    \n```cpp\n\n    std::vector<int> my_vector;\n    \n```\n  - std::list: Một danh sách liên kết đôi.\n    \n```cpp\n\n    std::list<int> my_list;\n    \n```\n  - std::deque: Hàng đợi hai đầu cho phép chèn và xóa ở cả hai đầu.\n    \n```cpp\n\n    std::deque<int> my_deque;\n    \n```\n- **Lưu trữ kết nối:** Các vùng lưu trữ này lưu trữ dữ liệu theo cách được sắp xếp với các khóa duy nhất. Ví dụ bao gồm:\n  - std::set: Một tập hợp các phần tử duy nhất được sắp xếp theo khóa.\n    \n```cpp\n\n    std::set<int> my_set;\n    \n```\n  - std::map: Một tập hợp các cặp khóa-giá trị được sắp xếp theo khóa.\n    \n```cpp\n\n    std::map<std::string, int> my_map;\n    \n```\n- **Lưu trữ kết nối ngẫu nhiên:** Các vùng lưu trữ này lưu trữ dữ liệu theo cách ngẫu nhiên bằng cách sử dụng bảng băm. Ví dụ bao gồm:\n  - std::unordered_set: Một tập hợp các phần tử duy nhất không theo thứ tự cụ thể.\n    \n```cpp\n\n    std::unordered_set<int> my_unordered_set;\n    \n```\n  - std::unordered_map: Một tập hợp các cặp khóa-giá trị không theo thứ tự cụ thể.\n    \n```cpp\n\n    std::unordered_map<std::string, int> my_unordered_map;\n    \n```\n- **Lưu trữ chuyển đổi tương thích dữ liệu:** Đây là những vùng lưu trữ dựa trên các vùng lưu trữ hiện có khác. Ví dụ bao gồm:\n  - std::stack: Cấu trúc dữ liệu LIFO dựa trên deque hoặc danh sách.\n    \n```cpp\n\n    std::stack<int> my_stack;\n    \n```\n  - std::queue: Cấu trúc dữ liệu FIFO dựa trên deque hoặc danh sách\n    \n```cpp\n\n    std::queue<int> my_queue;\n    \n```\n  - std::priority_queue: Một hàng đợi được sắp xếp dựa trên vector hoặc deque.\n    \n```cpp\n\n    std::priority_queue<int> my_priority_queue;\n    \n```\n\n## Thuật toán\nSTL cung cấp một số thuật toán chung có thể được sử dụng để thực hiện các thao tác khác nhau trên dữ liệu được lưu trữ trong các vùng lưu trữ. Chúng được chia thành năm loại: thuật toán trình tự không sửa đổi, thuật toán trình tự sửa đổi, thuật toán sắp xếp, thuật toán phạm vi được sắp xếp và thuật toán số.\nMột số ví dụ bao gồm std::find, std::replace, std::sort và std::binary_search.\nVí dụ: để sắp xếp một vecto, bạn có thể sử dụng đoạn code sau:\n\n```cpp\n\nstd::vector<int> my_vec = {4, 2, 5, 1, 3};\nstd::sort(my_vec.begin(), my_vec.end());\n\n```\n\n## Trình vòng lặp\nTrình vòng lặp là một khái niệm cơ bản trong STL, vì chúng cung cấp một cách thống nhất để truy cập các phần tử trong vùng lưu trữ. Trình vòng lặp có thể được coi là một dạng con trỏ nâng cao.\nMỗi vùng lưu trữ có loại trình vòng lặp riêng, có thể được sử dụng để duyệt qua các phần tử và sửa đổi giá trị. Các vòng lặp phổ biến nhất là begin() và end() để nhận các trình vòng lặp lần lượt trỏ đến phần tử đầu tiên và phần tử cuối cùng của vùng lưu trữ.\nVí dụ: để lặp qua một vecto và in các phần tử của nó, bạn có thể sử dụng đoạn code sau:\n\n```cpp\n\nstd::vector<int> my_vec = {1, 2, 3, 4, 5};\nfor(auto it = my_vec.begin(); it != my_vec.end(); ++it) {\n    std::cout << *it << \" \";\n}\n\n```"
                },
                {
                    "author": "Dev Alex",
                    "title": " iostream",
                    "param": "chap-10-1",
                    "level": "beginner",
                    "code": "# iostream\niostream là một tiêu đề trong Thư viện chuẩn C++ cung cấp chức năng cho các thuật toán đầu vào và đầu ra (I/O) cơ bản. Các luồng I/O tạo điều kiện truyền dữ liệu giữa chương trình của bạn và các nguồn khác nhau, chẳng hạn như bảng điều khiển (console), tệp hoặc các chương trình khác.\niostream bao hàm các lớp sau:\n- istream: dành cho các thuật toán đầu vào từ một nguồn đầu vào.\n- ostream: dành cho các thuật toán đầu ra cho một mục tiêu đầu ra.\n- iostream: sự kết hợp giữa istream và ostream cho cả thuật toán đầu vào và đầu ra.\nCác lớp này kế thừa từ các lớp cơ sở ios và ios_base. Ngoài ra, iostream định nghĩa một số đối tượng là thể hiện (instance) của các lớp này và đại diện cho các luồng đầu vào và đầu ra tiêu chuẩn:\n- cin: một đối tượng istream để đọc từ đầu vào tiêu chuẩn, thường tương ứng với bàn phím.\n- cout: một đối tượng ostream để ghi vào đầu ra tiêu chuẩn, điển hình là console.\n- cerr: một đối tượng ostream để ghi vào đầu ra lỗi tiêu chuẩn, thường được sử dụng để hiển thị các thông báo lỗi.\n- clog: một đối tượng ostream, tương tự như cerr, nhưng đầu ra của nó có thể được lưu trữ trong bộ đệm.\nDưới đây là một số mã code để ví dụ về cách sử dụng iostream cho các thuật toán đầu vào và đầu ra:\n\n```cpp\n\n#include <iostream>\n\nint main() {\n    int a;\n    std::cout << \"Enter a number: \";\n    std::cin >> a;\n    std::cout << \"You entered: \" << a << std::endl;\n    return 0;\n}\n\n```\n\n```cpp\n\n#include <iostream>\n\nint main() {\n    std::cerr << \"An error occurred.\" << std::endl;\n    std::clog << \"Logging information.\" << std::endl;\n    return 0;\n}\n\n```\nHãy nhớ thêm tệp tiêu đề iostream khi sử dụng các tính năng sau:\n\n```cpp\n\n#include <iostream>\n\n```"
                },
                {
                    "author": "Dev Alex",
                    "title": " Ngày giờ C++",
                    "param": "chap-10-2",
                    "level": "beginner",
                    "code": "# Ngày giờ C++\nTrong C++, bạn có thể làm việc với ngày và giờ bằng thư viện chrono, là một phần của Thư viện chuẩn (STL). Thư viện chrono cung cấp nhiều loại dữ liệu và hàm khác nhau để đại diện và thao tác với các duration, time point và clock.\n\n## Duration\nduration biểu thị một khoảng thời gian, có thể được biểu thị bằng nhiều đơn vị khác nhau như giây, phút, giờ, v.v. Để tạo duration, hãy sử dụng lớp mẫu std::chrono::duration. Các mẫu duration được xác định trước phổ biến là:\n- std::chrono::seconds\n- std::chrono::minutes\n- std::chrono::hours\n**Ví dụ:**\n\n```cpp\n\n#include <iostream>\n#include <chrono>\n\nint main() {\n    std::chrono::seconds sec(5);\n    std::chrono::minutes min(2);\n    std::chrono::hours hr(1);\n    return 0;\n}\n\n```\n\n## Time point\ntime_point đại diện cho một thời điểm cụ thể. Nó thường được tạo bằng cách sử dụng kết hợp giữa duration và clock. Trong C++, có ba loại clock được cung cấp bởi thư viện chrono:\n- std::chrono::system_clock: Đại diện cho wall clock thời gian thực trên toàn hệ thống.\n- std::chrono::steady_clock: Đại diện cho clock đơn điệu được đảm bảo không bao giờ bị điều chỉnh.\n- std::chrono::high_resolution_clock: Đại diện cho clock có chu kỳ đánh dấu ngắn nhất.\n**Ví dụ:**\n\n```cpp\n\n#include <iostream>\n#include <chrono>\n\nint main() {\n    std::chrono::system_clock::time_point tp = std::chrono::system_clock::now();\n    return 0;\n}\n\n```\n\n## Clock\nClock cung cấp quyền truy cập vào thời gian hiện tại. Nó bao gồm các phần tử sau:\n- time_point: Một thời điểm cụ thể.\n- duration: Khoảng thời gian giữa hai mốc thời gian.\n- now(): Một hàm tĩnh trả về điểm thời gian hiện tại.\n**Ví dụ:**\n\n```cpp\n\n#include <iostream>\n#include <chrono>\n\nint main() {\n    // Nhận time_point hiện tại bằng system_clock\n    std::chrono::system_clock::time_point now = std::chrono::system_clock::now();\n\n    // Nhận time_point 1 giờ kể từ bây giờ\n    std::chrono::system_clock::time_point one_hour_from_now = now + std::chrono::hours(1);\n    return 0;\n}\n\n```\n\n## Chuyển đổi thời điểm thành thời gian biểu diễn lịch\nĐể chuyển đổi một điểm thời gian thành biểu diễn lịch, bạn có thể sử dụng hàm std::chrono::system_clock::to_time_t.\n**Ví dụ:**\n\n```cpp\n\n#include <iostream>\n#include <chrono>\n#include <ctime>\n\nint main() {\n    std::chrono::system_clock::time_point now = std::chrono::system_clock::now();\n    std::time_t now_c = std::chrono::system_clock::to_time_t(now);\n    std::cout << \"Current time: \" << std::ctime(&now_c) << std::endl;\n    return 0;\n}\n\n```\nPhần này tóm tắt chức năng cơ bản của việc làm việc với ngày và giờ trong C++ bằng thư viện chrono. Bạn có thể tìm thấy các tính năng nâng cao hơn, chẳng hạn như thời lượng truyền và số học thời gian, trong **tài liệu tham khảo C++**."
                },
                {
                    "author": "Dev Alex",
                    "title": " Bộ lưu trữ C++",
                    "param": "chap-10-3",
                    "level": "beginner",
                    "code": "# Bộ lưu trữ C++\nBộ lưu trữ C++ là một phần của Thư viện template chuẩn (STL) cung cấp cấu trúc dữ liệu để lưu trữ và sắp xếp dữ liệu. Có nhiều loại lưu trữ, mỗi loại có đặc điểm và trường hợp sử dụng riêng. Ở đây, chúng tôi thảo luận về một số bộ lưu trữ thường được sử dụng:\n\n## 1. Vecto\nCác vecto là các mảng động có thể tự thay đổi kích thước khi cần. Chúng lưu trữ các phần tử trong một vị trí bộ nhớ liền kề, cho phép truy cập ngẫu nhiên nhanh chóng bằng cách sử dụng các chỉ số.\n**Ví dụ:**\n\n```cpp\n\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> vec = {1, 2, 3, 4, 5};\n\n    vec.push_back(6); // Thêm một phần tử vào cuối\n\n    std::cout << \"Vector contains:\";\n    for (int x : vec) {\n        std::cout << ' ' << x;\n    }\n    std::cout << std::endl;\n}\n\n```\n\n## 2. List\nMột list là một danh sách được liên kết kép cho phép các phần tử được chèn hoặc xóa khỏi bất kỳ vị trí nào trong thời gian cố định. Nó không hỗ trợ truy cập ngẫu nhiên. Danh sách tốt hơn vecto cho các tình huống mà bạn cần thường xuyên chèn hoặc xóa các phần tử ở giữa.\n**Ví dụ:**\n\n```cpp\n\n#include <iostream>\n#include <list>\n\nint main() {\n    std::list<int> lst = {1, 2, 3, 4, 5};\n\n    lst.push_back(6); // Thêm một phần tử vào cuối\n    \n    std::cout << \"List contains:\";\n    for (int x : lst) {\n        std::cout << ' ' << x;\n    }\n    std::cout << std::endl;\n}\n\n```\n\n## 3. Map\nMap là một vùng chứa kết hợp lưu trữ các cặp khóa-giá trị. Nó hỗ trợ truy xuất các giá trị dựa trên các khóa của chúng. Các phím được sắp xếp theo thứ tự tăng dần theo mặc định.\n**Ví dụ:**\n\n```cpp\n\n#include <iostream>\n#include <map>\n\nint main() {\n    std::map<std::string, int> m;\n\n    m[\"one\"] = 1;\n    m[\"two\"] = 2;\n\n    std::cout << \"Map contains:\" << std::endl;\n    for (const auto &pair : m) {\n        std::cout << pair.first << \": \" << pair.second << std::endl;\n    }\n}\n\n```\n\n## 4. Unordered_map\nTương tự như map, unordered map (map không có thứ tự) lưu trữ các cặp khóa-giá trị, nhưng nó được triển khai bằng cách sử dụng bảng băm. Điều này có nghĩa là unordered_map có hiệu suất trường hợp trung bình nhanh hơn so với map, vì nó không duy trì thứ tự đã sắp xếp. Tuy nhiên, hiệu suất trong trường hợp xấu nhất có thể kém hơn map.\n**Ví dụ:**\n\n```cpp\n\n#include <iostream>\n#include <unordered_map>\n\nint main() {\n    std::unordered_map<std::string, int> um;\n\n    um[\"one\"] = 1;\n    um[\"two\"] = 2;\n\n    std::cout << \"Unordered map contains:\" << std::endl;\n    for (const auto &pair : um) {\n        std::cout << pair.first << \": \" << pair.second << std::endl;\n    }\n}\n\n```\nĐây chỉ là một vài ví dụ về bộ lưu trữ C++. Có các loại bộ lưu trữ khác, chẳng hạn như set, multiset, deque, stack, queue và priority_queue. Mỗi bộ lưu trữ có các trường hợp sử dụng riêng và các đặc điểm riêng. Tìm hiểu về những bộ lưu trữ này và thời điểm sử dụng chúng có thể cải thiện đáng kể hiệu suất và hiệu quả của bạn trong việc sử dụng C++."
                },
                {
                    "author": "Dev Alex",
                    "title": " Trình vòng lặp",
                    "param": "chap-10-4",
                    "level": "beginner",
                    "code": "# Trình vòng lặp\nTrình vòng lặp là các đối tượng trong Thư viện chuẩn C++ (STL) giúp chúng ta duyệt qua các vùng chứa như mảng, danh sách và vecto. Về cơ bản, chúng hoạt động như một cầu nối giữa các lớp vùng lưu trữ và các thuật toán. Trình vòng lặp hoạt động tương tự như con trỏ nhưng cung cấp một cách tổng quát và trừu tượng hơn để truy cập các phần tử trong vùng lưu trữ.\nCó nhiều loại trình vòng lặp khác nhau mà bạn sẽ gặp tùy thuộc vào trường hợp sử dụng của chúng:\n- **Trình vòng lặp đầu vào:** Được sử dụng để đọc các phần tử trong vùng lưu trữ chỉ một lần, theo chiều thuận. Chúng không thể sửa đổi các phần tử.\nVí dụ:\n\n```cpp\n\nstd::vector<int> nums = {1, 2, 3, 4};\nstd::istream_iterator<int> input(std::cin);\nstd::copy(input, std::istream_iterator<int>(), std::back_inserter(nums));\n\n```\n- **Trình vòng lặp đầu ra:** Được sử dụng để ghi các phần tử trong vùng lưu trữ chỉ một lần, theo chiều thuận. Chúng không thể viết lại các phần tử.\nVí dụ:\n\n```cpp\n\nstd::vector<int> nums = {1, 2, 3, 4};\nstd::ostream_iterator<int> output(std::cout, \", \");\nstd::copy(nums.begin(), nums.end(), output);\n\n```\n- **Trình vòng lặp chuyển tiếp:** Tương tự như trình vòng lặp đầu vào nhưng có thể được sử dụng cho nhiều lần chuyển qua các phần tử trong một bộ lưu trữ. Chúng không thể chuyển dịch lùi.\nVí dụ: \n\n```cpp\n\nstd::forward_list<int> nums = {1, 2, 3, 4};\nstd::forward_list<int>::iterator itr = nums.begin();\nwhile (itr != nums.end()) {\n    std::cout << *itr << \" \";\n    ++itr;\n}\n\n```\n- **Trình vòng lặp hai chiều:** Các trình vòng lặp này cung cấp khả năng di chuyển tiến và lùi trong một vùng lưu trữ. Danh sách và bộ lưu trữ đều có trình vòng lặp hai chiều.\nVí dụ:\n\n```cpp\n\nstd::list<int> nums = {1, 2, 3, 4};\nstd::list<int>::reverse_iterator itr = nums.rbegin();\nwhile (itr != nums.rend()) {\n    std::cout << *itr << \" \";\n    ++itr;\n}\n\n```\n- **Trình vòng lặp truy cập ngẫu nhiên:** Các trình vòng lặp này cung cấp các cách linh hoạt nhất để truy cập các phần tử trong vùng lưu trữ. Chúng có thể di chuyển tiến, lùi, hoặc nhảy trực tiếp đến các phần tử khác và truy cập các phần tử tại một chỉ mục nhất định.\nVí dụ:\n\n```cpp\n\nstd::list<int> nums = {1, 2, 3, 4};\nstd::list<int>::iterator itr;\nfor (itr = nums.begin(); itr != nums.end(); ++itr) {\n    std::cout << *itr << \" \";\n}\nfor (--itr; itr != nums.begin(); --itr) {\n    std::cout << *itr << \" \";\n}\n\n```\n- **Trình vòng lặp truy cập ngẫu nhiên:** Các trình vòng lặp này cung cấp những cách linh hoạt nhất để truy cập các phần tử trong vùng chứa. Chúng có thể di chuyển tiến, lùi, nhảy trực tiếp đến các phần tử khác và truy cập các phần tử tại một chỉ mục nhất định.\nVí dụ:\n\n```cpp\n\nstd::vector<int> nums = {1, 2, 3, 4};\nstd::vector<int>::iterator itr;\nfor (itr = nums.begin(); itr != nums.end(); ++itr) {\n    std::cout << *itr << \" \";\n}\nfor (itr -= 1; itr != nums.begin() - 1; --itr) {\n    std::cout << *itr << \" \";\n}\n\n```\nĐối với hầu hết các trường hợp, bạn có thể bắt đầu với từ khóa auto và các phương thức vùng lưu trữ thích hợp (chẳng hạn như begin() và end()) để làm việc với các trình vòng lặp.\nVí dụ:\n\n```cpp\n\nstd::vector<int> nums = {1, 2, 3, 4};\nfor (auto itr = nums.begin(); itr != nums.end(); ++itr) {\n    std::cout << *itr << \" \";\n}\n\n```\nKhi làm việc với các thuật toán, hãy nhớ rằng Thư viện chuẩn C++ cung cấp các thuật toán khác nhau đã sử dụng các trình vòng lặp cho các tác vụ như tìm kiếm, sắp xếp và thao tác các phần tử."
                },
                {
                    "author": "Dev Alex",
                    "title": " Thuật toán STL",
                    "param": "chap-10-5",
                    "level": "beginner",
                    "code": "# Thuật toán STL\nThư viện mẫu chuẩn (STL) trong C++ cung cấp một tập hợp các thuật toán chung được thiết kế để hoạt động với các lớp vùng chứa khác nhau. Các thuật toán này được triển khai dưới dạng các hàm và có thể được áp dụng cho các cấu trúc dữ liệu khác nhau, chẳng hạn như mảng, vectơ, danh sách và các cấu trúc khác. File header chính cho thuật toán là <algorithm>.\n\n## Nội dung khóa\n\n### Sắp xếp\nSắp xếp (sorting) đề cập đến việc sắp xếp một chuỗi các phần tử theo một thứ tự cụ thể. STL cung cấp một số thuật toán sắp xếp, chẳng hạn như std::sort, std::stable_sort, và std::partial_sort.\n\n##\n## std::sort\nstd::sort được sử dụng để sắp xếp một loạt các phần tử [đầu tiên, cuối cùng) theo thứ tự tăng dần (theo mặc định). Bạn cũng có thể sử dụng các hàm so sánh tùy chỉnh hoặc biểu thức lambda để thay đổi thứ tự sắp xếp.\n\nVí dụ:\n\n```cpp\n\n#include <algorithm>\n#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> nums = {10, 9, 8, 7, 6, 5};\n    std::sort(nums.begin(), nums.end());\n\n    for (int num : nums) {\n        std::cout << num << ' ';\n    }\n    // Đầu ra: 5 6 7 8 9 10\n}\n\n```\n\n### Tìm kiếm\nTìm kiếm (searching) đề cập đến việc tìm xem liệu một phần tử cụ thể có xuất hiện trong một phạm vi phần tử nhất định hay không. STL cung cấp các thuật toán tìm kiếm khác nhau, chẳng hạn như std::find, std::binary_search, và std::find_if.\n\n##\n## std::find\nstd::find được sử dụng để tìm biến lặp của lần xuất hiện đầu tiên của một giá trị nhất định trong phạm vi [đầu tiên, cuối cùng).\n\nVí dụ:\n\n```cpp\n\n#include <algorithm>\n#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> nums = {5, 6, 7, 8, 9, 10};\n    auto it = std::find(nums.begin(), nums.end(), 9);\n\n    if (it != nums.end()) {\n        std::cout << \"Found 9 at position: \" << (it - nums.begin());\n    } else {\n        std::cout << \"9 not found\";\n    }\n    // Đầu ra: Found 9 at position: 4\n}\n\n```\n\n### Sửa đổi trình tự\nSTL cũng cung cấp các thuật toán để sửa đổi trình tự, chẳng hạn như std::remove, std::replace và std::unique.\n\n##\n## std::remove\nstd::remove được sử dụng để xóa tất cả các trường hợp của một giá trị khỏi vùng chứa trong phạm vi đã cho [đầu tiên, cuối cùng). Lưu ý rằng hàm không thay đổi kích thước vùng lưu trữ sau khi loại bỏ các phần tử.\n\nVí dụ:\n\n```cpp\n\n#include <algorithm>\n#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> nums = {5, 6, 7, 6, 8, 6, 9, 6, 10};\n    nums.erase(std::remove(nums.begin(), nums.end(), 6), nums.end());\n\n    for (int num : nums) {\n        std::cout << num << ' ';\n    }\n    // Đầu ra: 5 7 8 9 10\n}\n\n```\n\n## Tổng kết\nThuật toán STL trong C++ cung cấp một tập hợp các hàm hữu ích cho các thao tác chính như sắp xếp, tìm kiếm và sửa đổi trình tự. Các thuật toán có thể được sử dụng với nhiều lớp vùng lưu trữ khác nhau, làm cho chúng rất linh hoạt và là một phần thiết yếu của lập trình C++."
                },
                {
                    "author": "Dev Alex",
                    "title": " Đa luồng trong C++",
                    "param": "chap-10-6",
                    "level": "beginner",
                    "code": "# Đa luồng trong C++\nĐa luồng là việc thực thi đồng thời nhiều luồng trong một quy trình hoặc chương trình. Nó cải thiện hiệu suất và hiệu quả của một ứng dụng bằng cách cho phép nhiều tác vụ được thực thi song song.\n\nTrong C++, hỗ trợ đa luồng có sẵn thông qua thư viện thread được giới thiệu trong tiêu chuẩn C++11.\n\n## Tạo luồng cơ bản\nĐể tạo một luồng mới, hãy bao hàm tệp tiêu đề <thread> và tạo một phiên bản của std::thread nhận một hàm làm đối số. Hàm sẽ được thực hiện trong một luồng mới.\n\n```cpp\n\n#include <iostream>\n#include <thread>\n\nvoid my_function() {\n    std::cout << \"This function is executing in a separate thread\" << std::endl;\n}\n\nint main() {\n    std::thread t(my_function);\n    t.join(); // chờ luồng hoàn thành\n    return 0;\n}\n\n```\n\n## Luồng với đối số\nBạn có thể truyền đối số cho hàm luồng bằng cách cung cấp chúng dưới dạng đối số bổ sung cho hàm tạo std::thread.\n\n```cpp\n\n#include <iostream>\n#include <thread>\n\nvoid print_sum(int a, int b) {\n    std::cout << \"The sum is: \" << a + b << std::endl;\n}\n\nint main() {\n    std::thread t(print_sum, 3, 5);\n    t.join();\n    return 0;\n}\n\n```\n\n## Mutex và Khóa\nKhi nhiều luồng truy cập tài nguyên được chia sẻ, có khả năng xảy ra cuộc chạy đua dữ liệu. Để tránh điều này, hãy sử dụng mutex và khóa để đồng bộ hóa quyền truy cập tài nguyên được chia sẻ.\n\n```cpp\n\n#include <iostream>\n#include <mutex>\n#include <thread>\n\nstd::mutex mtx;\n\nvoid print_block(int n, char c) {\n    {\n        std::unique_lock<std::mutex> locker(mtx);\n        for (int i = 0; i < n; ++i) {\n            std::cout << c;\n        }\n        std::cout << std::endl;\n    }\n}\n\nint main() {\n    std::thread t1(print_block, 50, '*');\n    std::thread t2(print_block, 50, '$');\n\n    t1.join();\n    t2.join();\n\n    return 0;\n}\n\n```\nPhần giới thiệu ngắn này sẽ giúp bạn bắt đầu với các kỹ thuật đa luồng cơ bản trong C++. Còn rất nhiều điều cần tìm hiểu, chẳng hạn như nhóm luồng, biến điều kiện và hoạt động nguyên tử để điều chỉnh hiệu suất và đồng bộ hóa nâng cao."
                }
            ]
        },
        {
            "title": "Chương 12 Mẫu",
            "param": "chap-11-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " Khuôn mẫu C++ (Template C++)",
                    "param": "chap-11-0",
                    "level": "beginner",
                    "code": "# Khuôn mẫu C++ (Template C++)\nKhuôn mẫu trong C++ là một tính năng mạnh mẽ cho phép bạn viết mã code chung, nghĩa là bạn có thể viết một hàm hoặc một lớp duy nhất có thể hoạt động với các kiểu dữ liệu khác nhau. Điều này có nghĩa là bạn không cần phải viết các hàm hoặc lớp riêng biệt cho từng kiểu dữ liệu mà bạn muốn làm việc.\n\n## Hàm khuôn mẫu\nĐể tạo một hàm khuôn mẫu, bạn sử dụng từ khóa template theo sau là các tham số chỉ định kiểu hoặc biến thay thế tạm thời được đặt trong dấu ngoặc nhọn (< >). Sau đó, bạn xác định hàm của mình như bình thường, sử dụng các tham số chỉ định kiểu để chỉ định các kiểu chung.\n\nDưới đây là ví dụ về một hàm khuôn mẫu đơn giản nhận hai đối số và trả về giá trị lớn hơn trong hai đối số:\n\n```cpp\n\ntemplate <typename T>\nT max(T a, T b) {\n    return (a > b) ? a : b;\n}\n\n```\nĐể sử dụng hàm này, bạn có thể chỉ định rõ ràng tham số chỉ định kiểu:\n\n```cpp\n\nint result = max<int>(10, 20);\n\n```\nHoặc, bạn có thể để trình biên dịch suy diễn kiểu cho bạn:\n\n```cpp\n\nint result = max(10, 20);\n\n```\n\n## Lớp khuôn mẫu\nTương tự, bạn có thể tạo các lớp khuôn mẫu bằng cách sử dụng từ khóa template. Đây là một ví dụ về một lớp khuôn mẫu đơn giản đại diện cho một cặp giá trị:\n\n```cpp\n\ntemplate <typename T1, typename T2>\nclass Pair {\npublic:\n    T1 first;\n    T2 second;\n\n    Pair(T1 first, T2 second) : first(first), second(second) {}\n};\n\n```\nĐể sử dụng lớp này, bạn cần chỉ định các tham số chỉ định kiểu khi tạo đối tượng:\n\n```cpp\n\nPair<int, std::string> pair(1, \"Hello\");\n\n```\n\n## Chuyên biệt hóa khuôn mẫu\nĐôi khi, bạn có thể cần hành vi đặc biệt cho một loại dữ liệu cụ thể. Trong trường hợp này, bạn có thể sử dụng chuyên biệt hóa mẫu. Ví dụ: bạn có thể chuyên biệt hóa lớp Pair cho một kiểu cụ thể, chẳng hạn như char:\n\n```cpp\n\ntemplate <>\nclass Pair<char, char> {\npublic:\n    char first;\n    char second;\n\n    Pair(char first, char second) : first(first), second(second) {\n        // Hành vi đặc biệt cho các ký tự (ví dụ: chuyển đổi thành chữ hoa)\n        this->first = std::toupper(this->first);\n        this->second = std::toupper(this->second);\n    }\n};\n\n```\nBây giờ, khi bạn tạo một đối tượng Pair với các đối số mẫu char, hành vi chuyên biệt sẽ được sử dụng:\n\n```cpp\n\nPair<char, char> charPair('a', 'b');\n\n```\nTóm lại, các mẫu trong C++ cho phép bạn viết các hàm và lớp chung có thể hoạt động với các kiểu dữ liệu khác nhau, giảm trùng lặp mã code và làm cho mã của bạn linh hoạt hơn và có thể tái sử dụng."
                },
                {
                    "author": "Dev Alex",
                    "title": " Khuôn mẫu hàm variadic",
                    "param": "chap-11-1",
                    "level": "beginner",
                    "code": "# Khuôn mẫu hàm variadic\nCác khuôn mẫu hàm variadic là một tính năng trong C++11 cho phép bạn xác định một mẫu có số lượng đối số thay đổi. Điều này đặc biệt hữu ích khi bạn cần viết một hàm hoặc lớp có thể chấp nhận các số và loại đối số khác nhau.\n\n## Cú pháp\nCú pháp cho các khuôn mẫu hàm variadic rất đơn giản. Để xác định một khuôn mẫu hàm variadic, hãy sử dụng ký hiệu ... (dấu chấm lửng):\n\n```cpp\n\ntemplate <typename... Args>\n\n```\nKý hiệu này đại diện cho một gói tham số, có thể chứa 0 hoặc nhiều đối số. Bạn có thể sử dụng gói tham số này làm danh sách biến của các tham số khuôn mẫu trong định nghĩa khuôn mẫu của mình.\n\n## Ví dụ\n\n### Tổng hợp nhiều đối số bằng cách sử dụng các khuôn mẫu hàm variadic\n\n```cpp\n\n#include <iostream>\n\n// Trường hợp cơ sở cho đệ quy\ntemplate <typename T>\nT sum(T t) {\n  return t;\n}\n\n// Khuôn mẫu hàm variadic\ntemplate <typename T, typename... Args>\nT sum(T t, Args... args) {\n  return t + sum(args...);\n}\n\nint main() {\n  int result = sum(1, 2, 3, 4, 5);  // mở rộng đến 1 + 2 + 3 + 4 + 5\n  std::cout << \"The sum is: \" << result << std::endl;\n\n  return 0;\n}\n\n```\n\n### Lớp Tuple sử dụng khuôn mẫu hàm variadic\n\n```cpp\n\ntemplate <typename... Types>\nclass Tuple;\n\n// Trường hợp cơ sở: tuple empty\ntemplate <>\nclass Tuple<> {};\n\n// Trường hợp đệ quy: Tuple có một hoặc nhiều phần tử\ntemplate <typename Head, typename... Tail>\nclass Tuple<Head, Tail...> : public Tuple<Tail...> {\n public:\n  Tuple(Head head, Tail... tail) : Tuple<Tail...>(tail...), head_(head) {}\n\n  Head head() const { return head_; }\n\n private:\n  Head head_;\n};\n\nint main() {\n  Tuple<int, float, double> tuple(1, 2.0f, 3.0);\n  std::cout << \"First element: \" << tuple.head() << std::endl;\n  return 0;\n}\n\n```\nXin lưu ý rằng các ví dụ hiển thị là dành cho mục đích giáo dục và có thể không phải là triển khai hiệu quả nhất hoặc sẵn sàng để sản xuất. Với C++ 17 trở đi, thậm chí còn có nhiều cách ngắn gọn hơn để xử lý các khuôn mẫu hàm variadic, chẳng hạn như sử dụng biểu thức gấp."
                },
                {
                    "author": "Dev Alex",
                    "title": " Chuyên biệt hóa khuôn mẫu",
                    "param": "chap-11-2",
                    "level": "beginner",
                    "code": "# Chuyên biệt hóa khuôn mẫu\nChuyên biệt hóa khuôn mẫu là một cách để tùy chỉnh hoặc sửa đổi hành vi của khuôn mẫu cho một kiểu cụ thể hoặc một tập hợp các kiểu. Điều này có thể hữu ích khi bạn muốn tối ưu hóa hành vi hoặc cung cấp triển khai cụ thể cho một loại nhất định mà không ảnh hưởng đến hành vi chung của khuôn mẫu đối với các kiểu khác.\n\nCó hai cách chính để bạn có thể chuyên biệt hóa một khuôn mẫu:\n- **Chuyên biệt hóa toàn bộ:** Điều này xảy ra khi bạn cung cấp một triển khai cụ thể cho một kiểu hoặc tập hợp các kiểu cụ thể.\n- **Chuyên biệt hóa một phần:** Điều này xảy ra khi bạn cung cấp triển khai chung hơn cho một tập hợp con các kiểu phù hợp với một khuôn mẫu hoặc điều kiện nhất định.\n\n## Chuyên biệt hóa toàn bộ khuôn mẫu\nChuyên biệt hóa toàn bộ được sử dụng khi bạn muốn tạo một triển khai khuôn mẫu riêng biệt cho một kiểu cụ thể. Để làm điều này, bạn cần sử dụng từ khóa template<> theo sau là mẫu hàm với loại chuyên biệt hóa mong muốn.\n\nĐây là một ví dụ:\n\n```cpp\n\n#include <iostream>\n\ntemplate <typename T>\nvoid printData(const T& data) {\n    std::cout << \"General template: \" << data << std::endl;\n}\n\ntemplate <>\nvoid printData(const char*& data) {\n    std::cout << \"Specialized template for const char*: \" << data << std::endl;\n}\n\nint main() {\n    int a = 5;\n    const char* str = \"Hello, world!\";\n    printData(a); // Khuôn mẫu chung: 5\n    printData(str); // Khuôn mẫu chuyên dụng cho const char*: Hello, world!\n}\n\n```\n\n## Chuyên biệt hóa một phần khuôn mẫu\nChuyên biệt hóa một phần được sử dụng khi bạn muốn tạo một triển khai khuôn mẫu riêng biệt cho một tập hợp con các kiểu khớp với một khuôn mẫu hoặc điều kiện nhất định.\n\nĐây là một ví dụ về cách bạn có thể chuyên biệt hóa một phần lớp khuôn mẫu:\n\n```cpp\n\n#include <iostream>\n\ntemplate <typename K, typename V>\nclass MyPair {\npublic:\n    MyPair(K k, V v) : key(k), value(v) {}\n\n    void print() const {\n        std::cout << \"General template: key = \" << key << \", value = \" << value << std::endl;\n    }\n\nprivate:\n    K key;\n    V value;\n};\n\ntemplate <typename T>\nclass MyPair<T, int> {\npublic:\n    MyPair(T k, int v) : key(k), value(v) {}\n\n    void print() const {\n        std::cout << \"Partial specialization for int values: key = \" << key\n                  << \", value = \" << value << std::endl;\n    }\n\nprivate:\n    T key;\n    int value;\n};\n\nint main() {\n    MyPair<double, std::string> p1(3.2, \"example\");\n    MyPair<char, int> p2('A', 65);\n    p1.print(); // Khuôn mẫu chung: key = 3.2, value = example\n    p2.print(); // Chuyên biệt hóa một phần cho các giá trị int: key = A, value = 65\n}\n\n```\nTrong ví dụ này, lớp khuôn mẫu MyPair được chuyên biệt hóa một phần để cung cấp một hành vi khác khi tham số mẫu thứ hai thuộc kiểu int."
                },
                {
                    "author": "Dev Alex",
                    "title": " Chuyên biệt hóa toàn bộ khuôn mẫu",
                    "param": "chap-11-3",
                    "level": "beginner",
                    "code": "# Chuyên biệt hóa toàn bộ khuôn mẫu\nChuyên biệt hóa toàn bộ khuôn mẫu cho phép bạn cung cấp cách triển khai hoặc hành vi cụ thể cho khuôn mẫu khi được sử dụng với một bộ tham số loại nhất định. Nó hữu ích khi bạn muốn xử lý các trường hợp đặc biệt hoặc tối ưu hóa mã code của mình cho các kiểu cụ thể.\n\n## Cú pháp\nĐể tạo một chuyên biệt hóa đầy đủ của một khuôn mẫu, bạn cần xác định loại cụ thể mà chuyên biệt hóa sẽ xảy ra. Cú pháp trông như sau:\n\n```cpp\n\ntemplate <> //Chỉ ra rằng đây là một chuyên biệt hóa\nclassName<specificType> //Lớp chuyên biệt hóa cho kiểu cụ thể\n\n```\n\n## Ví dụ\nXem xét ví dụ sau để chứng minh chuyên biệt hóa toàn bộ mẫu:\n\n```cpp\n\n// Khuôn mẫu chung\ntemplate <typename T>\nclass MyContainer {\npublic:\n    void print() {\n        std::cout << \"Generic container.\" << std::endl;\n    }\n};\n\n// Chuyên biệt hóa toàn bộ khuôn mẫu cho int\ntemplate <>\nclass MyContainer<int> {\npublic:\n    void print() {\n        std::cout << \"Container for integers.\" << std::endl;\n    }\n};\n\nint main() {\n    MyContainer<double> d;\n    MyContainer<int> i;\n\n    d.print(); // Đầu ra: Bộ lưu trữ chung.\n    i.print(); // Đầu ra: Bộ lưu trữ số nguyên.\n\n    return 0;\n}\n\n```\nTrong ví dụ này, chúng tôi đã định nghĩa một lớp mẫu MyContainer chung cùng với chuyên biệt hóa đầy đủ cho kiểu int. Khi chúng ta sử dụng bộ lưu trữ với kiểu int, phương thức print của triển khai chuyên biệt hóa được gọi. Đối với các kiểu khác, việc triển khai khuôn mẫu chung sẽ được sử dụng."
                },
                {
                    "author": "Dev Alex",
                    "title": " Chuyên biệt hóa một phần khuôn mẫu",
                    "param": "chap-11-4",
                    "level": "beginner",
                    "code": "# Chuyên biệt hóa một phần khuôn mẫu\nChuyên biệt hóa một phần khuôn mẫu là một khái niệm trong các mẫu C++, cho phép bạn chuyên biệt hóa một khuôn mẫu cho một tập hợp con các đối số kiểu có thể có của nó. Nó đặc biệt hữu ích khi bạn muốn cung cấp triển khai tùy chỉnh cho một nhóm kiểu cụ thể mà không phải xác định các chuyên biệt hóa riêng biệt cho tất cả các loại trong nhóm đó.\n\nChuyên biệt hóa một phần khuôn mẫu đạt được bằng cách cung cấp chuyên biệt hóa khuôn mẫu với một bộ tham số mẫu mới. Mẫu mới này sẽ được chọn khi trình biên dịch suy ra các kiểu phù hợp với chuyên biệt hóa từng phần.\n\nĐây là một ví dụ mã code thể hiện chuyên biệt hóa một phần khuôn mẫu:\n\n```cpp\n\n// Khuôn mẫu chính\ntemplate <typename T>\nstruct MyTemplate {\n    static const char* name() {\n        return \"General case\";\n    }\n};\n\n// Chuyên biệt hóa một phần cho con trỏ\ntemplate <typename T>\nstruct MyTemplate<T*> {\n    static const char* name() {\n        return \"Partial specialization for pointers\";\n    }\n};\n\n// Chuyên biệt hóa toàn bộ cho int\ntemplate <>\nstruct MyTemplate<int> {\n    static const char* name() {\n        return \"Full specialization for int\";\n    }\n};\n\nint main() {\n    MyTemplate<double> t1; // Trường hợp chung\n    MyTemplate<double*> t2; // Chuyên biệt hóa một phần cho con trỏ\n    MyTemplate<int> t3; // Chuyên biệt hóa toàn bộ cho int\n\n    std::cout << t1.name() << std::endl;\n    std::cout << t2.name() << std::endl;\n    std::cout << t3.name() << std::endl;\n\n    return 0;\n}\n\n```\nTrong ví dụ trên, chúng tôi đã xác định khuôn mẫu chính MyTemplate với một tham số kiểu T. Sau đó, chúng tôi cung cấp chuyên biệt hóa một phần khuôn mẫu cho các kiểu con trỏ bằng cách chỉ định MyTemplate<T*>. Điều này có nghĩa là chuyên biệt hóa từng phần sẽ được chọn khi đối số kiểu là kiểu con trỏ.\n\nCuối cùng, chúng tôi cung cấp chuyên biệt hóa đầy đủ cho kiểu int bằng cách chỉ định MyTemplate<int>. Điều này sẽ được chọn khi đối số loại là int.\n\nKhi chạy ví dụ này, đầu ra sẽ là:\n\n```cpp\n\nGeneral case\nPartial specialization for pointers\nFull specialization for int\n\n```\nĐiều này chứng tỏ rằng chuyên biệt hóa một phần hoạt động như mong đợi và được chọn cho các loại con trỏ, trong khi chuyên biệt hóa đầy đủ được chọn cho kiểu int."
                },
                {
                    "author": "Dev Alex",
                    "title": " Type traits",
                    "param": "chap-11-5",
                    "level": "beginner",
                    "code": "# Type traits\nType traits là một tập hợp các lớp mẫu trong C++ giúp lấy thông tin về thuộc tính, hành vi hoặc đặc điểm của kiểu. Bạn có thể tìm thấy chúng trong tệp tiêu đề <type_traits>. Bằng cách sử dụng Type traits, bạn có thể điều chỉnh mã code của mình tùy thuộc vào các thuộc tính của một kiểu nhất định hoặc thậm chí thực thi các thuộc tính cụ thể cho các tham số kiểu của bạn trong mã code mẫu.\n\nMột số type traits phổ biến là:\n- std::is_pointer: Kiểm tra xem kiểu đã cho có phải là kiểu con trỏ hay không.\n- std::is_arithmetic: Kiểm tra xem kiểu đã cho có phải là kiểu số học hay không.\n- std::is_function: Kiểm tra xem kiểu đã cho có phải là kiểu hàm hay không.\n- std::decay: Áp dụng quy tắc decltype cho kiểu đầu vào (tham chiếu dải, bộ định tính cv, v.v.).\n\n## Sử dụng\nBạn có thể sử dụng type traits như sau:\n\n```cpp\n\n#include <iostream>\n#include <type_traits>\n\nint main() {\n    int a;\n    int* a_ptr = &a;\n\n    std::cout << \"Is 'a' a pointer? \" << std::boolalpha << std::is_pointer<decltype(a)>::value << std::endl;\n    std::cout << \"Is 'a_ptr' a pointer? \" << std::boolalpha << std::is_pointer<decltype(a_ptr)>::value << std::endl;\n\n    return 0;\n}\n\n```\n\n## Các loại Type traits\nMột số type traits giúp bạn tổng hợp các traits khác hoặc sửa đổi chúng, chẳng hạn như:\n- std::conditional: Nếu một giá trị boolean đã cho là true, hãy sử dụng kiểu A; nếu không, hãy sử dụng kiểu B.\n- std::enable_if: Nếu một giá trị boolean đã cho là true, hãy sử dụng kiểu A; mặt khác, không có kiểu lồng nhau.\n\n```cpp\n\n#include <iostream>\n#include <type_traits>\n\ntemplate <typename T>\ntypename std::enable_if<std::is_arithmetic<T>::value, T>::type find_max(T a, T b) {\n    return a > b ? a : b;\n}\n\nint main() {\n    int max = find_max(10, 20);\n    std::cout << \"Max: \" << max << std::endl;\n\n    return 0;\n}\n\n```\nTrong ví dụ này, hàm mẫu find_max chỉ được xác định khi T là một loại số học (ví dụ: int, float, double). Điều này ngăn việc sử dụng hàm find_max ngoài ý muốn với các kiểu phi số học.\n\nNhìn chung, type traits là một công cụ mạnh mẽ để tạo mã code C++ chung, có thể mở rộng và hiệu quả hơn, cung cấp một cách để truy vấn và điều chỉnh mã code của bạn dựa trên type traits."
                },
                {
                    "author": "Dev Alex",
                    "title": " SFINAE (Substitution Failure Is Not An Error)",
                    "param": "chap-11-6",
                    "level": "beginner",
                    "code": "# SFINAE (Substitution Failure Is Not An Error)\nSFINAE là một nguyên tắc trong siêu lập trình khuôn mẫu C++ cho phép trình biên dịch chọn hàm hoặc lớp thích hợp khi chuyên biệt hóa khuôn mẫu cụ thể không thành công trong quá trình thay thế. Thuật ngữ \"substitution failure\" đề cập đến quá trình mà trình biên dịch cố gắng thay thế các đối số khuôn mẫu thành khuôn mẫu hàm hoặc khuôn mẫu lớp. Nếu sự thay thế gây ra lỗi, trình biên dịch sẽ không coi chuyên biệt hóa cụ thể đó là một ứng viên và sẽ tiếp tục tìm kiếm một chuyên biệt hóa hợp lệ.\n\nÝ tưởng chính đằng sau SFINAE là nếu xảy ra lỗi thay thế, nó sẽ bị bỏ qua một cách âm thầm và trình biên dịch tiếp tục khám phá các chuyên biệt hóa hoặc quá tải mẫu khác. Điều này cho phép bạn viết mã linh hoạt và chung hơn, vì nó cho phép bạn có nhiều chuyên biệt hóa cho các tình huống khác nhau.\n\n## Ví dụ mã code\nĐây là một ví dụ minh họa hoạt động của SFINAE:\n\n```cpp\n\n#include <iostream>\n#include <type_traits>\n\ntemplate <typename T, typename = void>\nstruct foo_impl {\n    void operator()(T t) {\n        std::cout << \"Called when T is not arithmetic\" << std::endl;\n    }\n};\n\ntemplate <typename T>\nstruct foo_impl<T, std::enable_if_t<std::is_arithmetic<T>::value>> {\n    void operator()(T t) {\n        std::cout << \"Called when T is arithmetic\" << std::endl;\n    }\n};\n\ntemplate <typename T>\nvoid foo(T t) {\n    foo_impl<T>()(t);\n}\n\nint main() {\n    int a = 5;\n    foo(a); // đầu ra: Được gọi khi T là số học\n\n    std::string s = \"example\";\n    foo(s); // đầu ra: Được gọi khi T không phải là số học\n}\n\n```\nTrong ví dụ này, chúng tôi xác định hai chuyên biệt hóa khuôn mẫu hàm foo. Cái đầu tiên được chạy khi T là kiểu số học, trong khi cái thứ hai được chạy khi T không phải là kiểu số học. std::enable_if_t bên trong danh sách tham số mẫu cho phép ta kiểm soát chuyên biệt hóa nào hợp lệ đối với một kiểu T nhất định.\n\nKhi gọi foo(a) bằng một số nguyên, chuyên biệt hóa đầu tiên được chọn và khi gọi foo(s) bằng một chuỗi, chuyên biệthóa thứ hai sẽ được chọn. Nếu không có chuyên biệt hóa hợp lệ, mã code sẽ không biên dịch được."
                }
            ]
        },
        {
            "title": "Chương 13 Thành ngữ quan trọng",
            "param": "chap-12-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " Đặc ngữ C++",
                    "param": "chap-12-0",
                    "level": "beginner",
                    "code": "# Đặc ngữ C++\nĐặc ngữ C++ là các mẫu hoặc kỹ thuật đã được thiết lập ổn định thường được sử dụng trong lập trình C++ để đạt được một kết quả cụ thể. Chúng giúp làm cho mã code hiệu quả, dễ bảo trì và ít bị lỗi hơn. Dưới đây là một số đặc ngữ C ++ phổ biến:\n\n## 1. Chuyển đổi tài nguyên là Khởi tạo (RAII)\nĐặc ngữ này đảm bảo rằng các tài nguyên luôn được thu thập và giải phóng đúng cách bằng cách gắn thời gian tồn tại của chúng với thời gian tồn tại của một đối tượng. Khi đối tượng được tạo, nó sẽ lấy tài nguyên và khi bị phá hủy, nó sẽ giải phóng chúng.\n\n```cpp\n\nclass Resource {\npublic:\n    Resource() { /* Acquire resource */ }\n    ~Resource() { /* Release resource */ }\n};\n\nvoid function() {\n    Resource r; // Tài nguyên có được\n    // ...\n} // Tài nguyên được giải phóng khi r vượt quá phạm vi\n\n```\n\n## 2. Quy tắc tam xuất\nNếu một lớp định nghĩa bất kỳ một trong những điều sau đây, nó sẽ định nghĩa cả ba: hàm khởi tạo sao chép, toán tử gán sao chép và hàm hủy.\n\n```cpp\n\nclass MyClass {\npublic:\n    MyClass();\n    MyClass(const MyClass& other); // Hàm khởi tạo sao chép\n    MyClass& operator=(const MyClass& other); // Toán tử gán sao chép\n    ~MyClass(); // Hàm hủy\n};\n\n```\n\n## 3. Quy tắc ngũ xuất\nVới C++11, quy tắc tam đã được mở rộng thành ngũ, bao gồm hàm khởi tạo di chuyển và toán tử gán di chuyển.\n\n```cpp\n\nclass MyClass {\npublic:\n    MyClass();\n    MyClass(const MyClass& other); // Hàm khởi tạo sao chép\n    MyClass(MyClass&& other); // Hàm khởi tạo di chuyển\n    MyClass& operator=(const MyClass& other); // Toán tử gán sao chép\n    MyClass& operator=(MyClass&& other); // Toán tử gán di chuyển\n    ~MyClass(); // Hàm hủy\n};\n\n```\n\n## 4. Đặc ngữ PImpl (Con trỏ để thực hiện)\nĐặc ngữ này được sử dụng để tách các chi tiết triển khai của một lớp khỏi giao diện của nó, dẫn đến thời gian biên dịch nhanh hơn và khả năng thay đổi việc triển khai mà không ảnh hưởng đến máy khách.\n\n```cpp\n\n// tệp tiêu đề\nclass MyClass {\npublic:\n    MyClass();\n    ~MyClass();\n    void someMethod();\n\nprivate:\n    class Impl;\n    Impl* pImpl;\n};\n\n// tệp triển khai\nclass MyClass::Impl {\npublic:\n    void someMethod() { /* Implementation */ }\n};\n\nMyClass::MyClass() : pImpl(new Impl()) {}\nMyClass::~MyClass() { delete pImpl; }\nvoid MyClass::someMethod() { pImpl->someMethod(); }\n\n```\n\n## 5. Giao diện không ảo (NVI)\nNVI thực thi một giao diện chung cố định và cho phép các lớp con chỉ ghi đè các phương thức ảo private hoặc protected cụ thể.\n\n```cpp\n\nclass Base {\npublic:\n    void publicMethod() {\n        // Hành vi phổ biến\n        privateMethod(); // Đặt tên cho triển khai bị ghi đè\n    }\n\nprotected:\n    virtual void privateMethod() = 0; // Phương thức ảo thuần\n};\n\nclass Derived : public Base {\nprotected:\n    virtual void privateMethod() override {\n        // Triển khai được dẫn xuất\n    }\n};\n\n```\nĐây chỉ là một vài ví dụ về nhiều đặc ngữ trong lập trình C++. Họ có thể cung cấp hướng dẫn khi thiết kế và triển khai mã code của bạn, nhưng điều cần thiết là phải hiểu các khái niệm cơ bản để điều chỉnh chúng cho phù hợp với các tình huống khác nhau."
                },
                {
                    "author": "Dev Alex",
                    "title": " RAII (Chuyển đổi tài nguyên là Khởi tạo)",
                    "param": "chap-12-1",
                    "level": "beginner",
                    "code": "# RAII (Chuyển đổi tài nguyên là Khởi tạo)\nRAII là một đặc ngữ phổ biến trong C++ tập trung vào việc sử dụng vòng đời của đối tượng để quản lý tài nguyên. Nó khuyến khích ràng buộc thời gian tồn tại của tài nguyên với phạm vi của một đối tượng tương ứng để nó tự động có được khi một đối tượng được tạo và giải phóng khi đối tượng bị hủy. Điều này giúp đơn giản hóa mã code, tránh rò rỉ và quản lý tài nguyên hiệu quả.\n\n## Ví dụ mã code\nĐây là một ví dụ về việc sử dụng RAII để quản lý tài nguyên, cụ thể là một mảng được phân bổ động:\n\n```cpp\n\nclass ManagedArray {\npublic:\n    ManagedArray(size_t size) : size_(size), data_(new int[size]) {\n    }\n\n    ~ManagedArray() {\n        delete[] data_;\n    }\n\n    // Hàm truy cập\n    int& operator [](size_t i) {\n        return data_[i];\n    }\n\nprivate:\n    size_t size_;\n    int* data_;\n};\n\n```\nSử dụng:\n\n```cpp\n\n{\n    ManagedArray arr(10);\n    arr[0] = 42;\n\n    // Không cần giải phóng bộ nhớ một cách rõ ràng, nó sẽ tự động được giải phóng khi arr vượt quá phạm vi.\n}\n\n```\nMột trường hợp sử dụng phổ biến khác là quản lý khóa mutex:\n\n```cpp\n\nclass Lock {\npublic:\n    Lock(std::mutex& mtx) : mutex_(mtx) {\n        mutex_.lock();\n    }\n\n    ~Lock() {\n        mutex_.unlock();\n    }\n\nprivate:\n    std::mutex& mutex_;\n};\n\n```\nSử dụng:\n\n```cpp\n\nstd::mutex some_mutex;\n\nvoid protected_function() {\n    Lock lock(some_mutex);\n\n    // Làm một số công việc phải đồng bộ\n\n    // Không cần phải mở khóa mutex một cách rõ ràng, nó sẽ tự động được mở khóa khi khóa vượt quá phạm vi.\n}\n\n```\nTrong cả hai ví dụ, hàm tạo thu nhận tài nguyên (bộ nhớ cho mảng và khóa cho mutex) và hàm hủy sẽ giải phóng chúng. Bằng cách này, việc quản lý tài nguyên được gắn với thời gian tồn tại của đối tượng và tài nguyên được giải phóng chính xác ngay cả trong trường hợp ngoại lệ được đưa ra."
                },
                {
                    "author": "Dev Alex",
                    "title": " Đặc ngữ Pimpl",
                    "param": "chap-12-2",
                    "level": "beginner",
                    "code": "# Đặc ngữ Pimpl\nĐặc ngữ Pimpl (Con trỏ để triển khai), còn được gọi là dữ liệu lớp riêng, tường lửa trình biên dịch hoặc lớp xử lý, là một kỹ thuật được sử dụng trong C++ để ẩn chi tiết triển khai của lớp bằng cách sử dụng khai báo chuyển tiếp tới cấu trúc hoặc lớp riêng , giữ cho giao diện chung của lớp sạch sẽ và giảm các phụ thuộc thời gian biên dịch.\n\n## Triển khai\nĐây là một ví dụ đơn giản minh họa đặc ngữ Pimpl:\n\n### my_class.h\n\n```cpp\n\nclass MyClass_Impl; // khai báo chuyển tiếp\n\nclass MyClass\n{\npublic:\n    MyClass();\n    ~MyClass();\n    void some_method();\n\nprivate:\n    MyClass_Impl *pimpl; //con trỏ đến việc triển khai\n};\n\n```\n\n### my_class.cpp\n\n```cpp\n\n#include \"my_class.h\"\n#include <iostream>\n\nclass MyClass_Impl // việc triển khai thực tế\n{\npublic:\n    void some_method()\n    {\n        std::cout << \"Implementation method called!\" << std::endl;\n    }\n};\n\nMyClass::MyClass() : pimpl(new MyClass_Impl()) {} // hàm tạo\n\nMyClass::~MyClass() { delete pimpl; } // hàm hủy\n\nvoid MyClass::some_method()\n{\n    pimpl->some_method(); // ủy quyền đến triển khai\n}\n\n```\nBây giờ, tất cả các phương thức công khai của MyClass sẽ ủy quyền các lệnh gọi cho các phương thức tương ứng của MyClass_Impl. Bằng cách này, bạn có thể ẩn các chi tiết triển khai lớp, giảm các phụ thuộc thời gian biên dịch và dễ dàng bảo trì mã code của bạn."
                },
                {
                    "author": "Dev Alex",
                    "title": " CRTP",
                    "param": "chap-12-3",
                    "level": "beginner",
                    "code": "# CRTP\n**Curiously Recurring Template Pattern (CRTP)**\n\nCuriously Recurring Template Pattern (CRTP) là một đặc ngữ C++ liên quan đến khuôn mẫu lớp được lấy từ chuyên biệt hóa của chính nó. Mẫu này cho phép tạo đa hình tĩnh, khác với đa hình thời gian chạy thông thường dựa trên các hàm ảo và kế thừa.\n\nCRTP thường được sử dụng khi bạn muốn tùy chỉnh một số hành vi nhất định trong lớp cơ sở mà không cần thêm chi phí gọi hàm ảo. Nói tóm lại, CRTP có thể được sử dụng để đạt được tính đa hình thời gian biên dịch mà không tốn chi phí hiệu suất thời gian chạy.\n\nĐây là một ví dụ minh họa CRTP:\n\n```cpp\n\ntemplate <typename Derived>\nclass Base {\npublic:\n    void interface() {\n        static_cast<Derived*>(this)->implementation();\n    }\n\n    void implementation() {\n        std::cout << \"Default implementation in Base\" << std::endl;\n    }\n};\n\nclass Derived1 : public Base<Derived1> {\npublic:\n    void implementation() {\n        std::cout << \"Custom implementation in Derived1\" << std::endl;\n    }\n};\n\nclass Derived2 : public Base<Derived2> {\n    // Không triển khai tùy chỉnh, vì vậy Base::implementation sẽ được sử dụng.\n};\n\nint main() {\n    Derived1 d1;\n    d1.interface();  // Đầu ra: \"Custom implementation in Derived1\"\n\n    Derived2 d2;\n    d2.interface();  // Đầu ra: \"Default implementation in Base\"\n\n    return 0;\n}\n\n```\nTrong ví dụ này, lớp Base là một khuôn mẫu nhận một tham số kiểu duy nhất. Derived1 và Derived2 được lấy từ chuyên biệt hóa Base tương ứng của chúng. CRTP được sử dụng để cho phép triển khai tùy chỉnh hàm implementation() trong các lớp dẫn xuất trong khi cung cấp hành vi mặc định trong lớp Base. Hàm interface() trong lớp Base là khuôn mẫu cho hành vi của lớp dẫn xuất và gọi hàm implementation() tương ứng dựa trên kiểu tĩnh.\n\nMẫu này cho phép bạn ghi đè một số hành vi nhất định trong các lớp dẫn xuất bằng chức năng bổ sung, đồng thời tránh được chi phí hoạt động của các lệnh gọi hàm ảo và do đó, đạt được mức độ hiệu quả cao hơn trong thời gian chạy."
                },
                {
                    "author": "Dev Alex",
                    "title": " Non-Copyable",
                    "param": "chap-12-4",
                    "level": "beginner",
                    "code": "# Non-Copyable\nĐặc ngữ non-copyable (không sao chép) là một mẫu thiết kế C++ ngăn các đối tượng bị sao chép hoặc gán. Nó thường được áp dụng cho các lớp quản lý tài nguyên, như xử lý tệp hoặc ổ cắm mạng, nơi sao chép đối tượng có thể gây ra sự cố như rò rỉ tài nguyên hoặc xóa hai lần.\n\nĐể làm cho một lớp không thể sao chép được, bạn cần xóa hàm tạo bản sao và toán tử gán bản sao. Điều này có thể được thực hiện rõ ràng trong phần khai báo lớp, giúp các lập trình viên khác hiểu rõ rằng việc sao chép là không được phép.\n\nĐây là một ví dụ về cách áp dụng đặc ngữ không thể sao chép cho một lớp:\n\n```cpp\n\nclass NonCopyable {\npublic:\n  NonCopyable() = default;\n  ~NonCopyable() = default;\n\n  // Xóa hàm tạo bản sao\n  NonCopyable(const NonCopyable&) = delete;\n\n  // Xóa toán tử gán bản sao\n  NonCopyable& operator=(const NonCopyable&) = delete;\n};\n\n```\nĐể sử dụng đặc ngữ này, chỉ cần kế thừa từ lớp NonCopyable:\n\n```cpp\n\nclass MyClass : private NonCopyable {\n  // MyClass hiện không thể sao chép được\n};\n\n```\nĐiều này đảm bảo rằng mọi nỗ lực sao chép hoặc gán các đối tượng của MyClass sẽ dẫn đến lỗi biên dịch, do đó ngăn chặn hành vi không mong muốn."
                },
                {
                    "author": "Dev Alex",
                    "title": " Đặc ngữ Erase-remove",
                    "param": "chap-12-5",
                    "level": "beginner",
                    "code": "# Đặc ngữ Erase-remove\nĐặc ngữ erase-remove là một kỹ thuật C++ phổ biến để loại bỏ hiệu quả các phần tử khỏi bộ lưu trữ, đặc biệt là từ bộ lưu trữ chuỗi tiêu chuẩn như std::vector, std::list và std::deque. Nó tận dụng các thuật toán thư viện tiêu chuẩn std::remove (hoặc std::remove_if) và hàm thành viên erase().\n\nĐặc ngữ bao gồm hai bước:\n- std::remove (hoặc std::remove_if) di chuyển các phần tử cần xóa về cuối bộ lưu trữ và trả về một trình vòng lặp trỏ đến phần tử đầu tiên cần xóa.\n- container.erase() xóa các phần tử khỏi bộ lưu trữ bằng cách sử dụng trình vòng lặp thu được ở bước trước.\nĐây là một ví dụ:\n\n```cpp\n\n#include <algorithm>\n#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> numbers = {1, 3, 2, 4, 3, 5, 3};\n    \n    // Xóa tất cả các lần xuất hiện của 3 khỏi vecto.\n    numbers.erase(std::remove(numbers.begin(), numbers.end(), 3), numbers.end());\n\n    for (int number : numbers) {\n        std::cout << number << \" \";\n    }\n\n    return 0;\n}\n\n```\nĐầu ra:\n\n```cpp\n\n1 2 4 5\n\n```\nTrong ví dụ này, chúng tôi đã sử dụng thuật toán std::remove để xóa tất cả các lần xuất hiện của số 3 khỏi std::vector<int> numbers. Sau khi loại bỏ, vecto chỉ chứa 1, 2, 4 và 5, như đầu ra hiển thị."
                },
                {
                    "author": "Dev Alex",
                    "title": " Copy và Swap",
                    "param": "chap-12-6",
                    "level": "beginner",
                    "code": "# Copy và Swap\nCopy-swap là một đặc ngữ C++ tận dụng hàm tạo sao chép và hàm hoán đổi để tạo toán tử gán. Nó tuân theo một mô hình đơn giản nhưng mạnh mẽ: tạo một bản sao tạm thời của đối tượng bên phải và hoán đổi nội dung của nó với đối tượng bên trái.\n\nDưới đây là một bản tóm tắt ngắn gọn:\n- **Copy**: Tạo một bản sao cục bộ của đối tượng bên tay phải. Bước này tận dụng hàm tạo sao chép, cung cấp sự an toàn ngoại lệ và tái sử dụng mã code.\n- **Swap**: Hoán đổi nội dung của đối tượng bên trái với bản sao tạm thời. Bước này thường liên quan đến việc hoán đổi các con trỏ hoặc tài nguyên bên trong mà không cần sao chép lại toàn bộ nội dung.\n- **Destruction**: Phá hủy bản sao tạm thời. Điều này xảy ra khi thoát khỏi toán tử gán.\nĐây là một ví dụ mã code cho một lớp String đơn giản:\n\n```cpp\n\nclass String {\n    // ... phần còn lại của lớp ...\n\n    String(const String& other);\n    \n    void swap(String& other) {\n        using std::swap; // để tra cứu phụ thuộc vào đối số (ADL)\n        swap(size_, other.size_);\n        swap(buffer_, other.buffer_);\n    }\n\n    String& operator=(String other) {\n        swap(other);\n        return *this;\n    }\n};\n\n```\nSử dụng đặc ngữ copy-swap:\n- Đối tượng bên phải được sao chép khi được truyền giá trị cho toán tử gán.\n- Nội dung của đối tượng bên trái được hoán đổi với bản sao tạm thời.\n- Bản sao tạm thời bị hủy, giải phóng mọi tài nguyên mà đối tượng bên trái nắm giữ trước đó.\nCách tiếp cận này đơn giản hóa việc triển khai và cung cấp sự an toàn ngoại lệ mạnh mẽ, đồng thời sử dụng lại mã code hàm tạo bản sao và mã code hàm hủy."
                },
                {
                    "author": "Dev Alex",
                    "title": " Đặc ngữ Copy-Write",
                    "param": "chap-12-7",
                    "level": "beginner",
                    "code": "# Đặc ngữ Copy-Write\nĐặc ngữ Copy-Write, đôi khi được gọi là đặc ngữ Copy-on-Write (CoW) hoặc \"lazy copying\", là một kỹ thuật được sử dụng trong lập trình để giảm thiểu chi phí sao chép các đối tượng lớn. Nó giúp giảm số lượng thao tác sao chép thực tế bằng cách sử dụng các tham chiếu được chia sẻ tới các đối tượng và chỉ sao chép dữ liệu khi cần sửa đổi.\n\nHãy hiểu điều này với một ví dụ đơn giản:\n\n```cpp\n\n#include <iostream>\n#include <memory>\n\nclass MyString {\npublic:\n    MyString(const std::string &str) : data(std::make_shared<std::string>(str)) {}\n\n    // Sử dụng cùng một dữ liệu được chia sẻ để sao chép.\n    MyString(const MyString &other) : data(other.data) { \n        std::cout << \"Copied using the Copy-Write idiom.\" << std::endl;\n    }\n\n    // Chỉ tạo một bản sao nếu muốn sửa đổi dữ liệu.\n    void write(const std::string &str) {\n        // Kiểm tra xem có nhiều hơn một tham chiếu không.\n        if(!data.unique()) {\n            data = std::make_shared<std::string>(*data);\n            std::cout << \"Copy is actually made for writing.\" << std::endl;\n        }\n        *data = str;\n    }\n\nprivate:\n    std::shared_ptr<std::string> data;\n};\n\nint main() {\n    MyString str1(\"Hello\");\n    MyString str2 = str1; // Không có thao tác sao chép, chỉ chia sẻ tài liệu tham khảo.\n\n    str1.write(\"Hello, World!\"); // Đây là nơi xảy ra sự trùng lặp thực tế.\n    return 0;\n}\n\n```\nTrong ví dụ này, chúng ta có một lớp MyString mô phỏng đặc ngữ Copy-Write. Khi một đối tượng MyString được tạo, nó sẽ tạo một shared_ptr trỏ đến một chuỗi. Khi một đối tượng MyString được sao chép, nó không thực hiện bất kỳ thao tác sao chép thực tế nào mà chỉ tăng số lượng tham chiếu của đối tượng được chia sẻ. Cuối cùng, khi hàm write được gọi, nó sẽ kiểm tra xem có nhiều hơn một tham chiếu đến dữ liệu hay không và nếu có, nó thực sự tạo một bản sao mới và cập nhật tham chiếu đó. Bằng cách này, có thể tránh được các bản sao không cần thiết cho đến khi chúng thực sự cần thiết để sửa đổi."
                }
            ]
        },
        {
            "title": "Chương 14 Các chuẩn phiên bản",
            "param": "chap-13-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " Chuẩn C++",
                    "param": "chap-13-0",
                    "level": "beginner",
                    "code": "# Chuẩn C++\nCác chuẩn C ++ là một bộ quy tắc và nguyên tắc xác định các tính năng, cú pháp và ngữ nghĩa của ngôn ngữ. Tổ chức Tiêu chuẩn hóa Quốc tế (ISO) chịu trách nhiệm duy trì và cập nhật các chuẩn C++. Mục đích chính của các chuẩn là đảm bảo tính nhất quán, hiệu quả và khả năng bảo trì trên nhiều nền tảng và trình biên dịch.\n\nDưới đây là một bản tóm tắt ngắn gọn về các chuẩn C++ khác nhau được phát hành cho đến nay:\n- **C++98/C++03:** Phiên bản chuẩn hóa đầu tiên của C++, đã giới thiệu nhiều tính năng như mẫu, ngoại lệ và Thư viện template chuẩn (STL). C++03 là một bản cập nhật nhỏ cho C++98 với một số sửa lỗi và cải thiện hiệu suất.\n- **C++11:** Một bản nâng cấp lớn cho ngôn ngữ C, giới thiệu các tính năng như:\n  - Biểu thức lambda:\n    \n```cpp\n\n    auto sum = [](int a, int b) -> int { return a + b; };\n    \n```\n  - Các vòng lặp dựa trên phạm vi:\n    \n```cpp\n\n    std::vector<int> numbers = {1, 2, 3, 4};\n    for (int num : numbers) {\n        std::cout << num << std::endl;\n    }\n    \n```\n  - Con trỏ thông minh như std::shared_ptr và std::unique_ptr.\n- **C++14:** Một bản cập nhật nhỏ cho C++11, bổ sung các tính năng như:\n  - Biểu thức lambda chung:\n    \n```cpp\n\n    auto generic_sum = [](auto a, auto b) { return a + b; };\n    \n```\n  - Chữ nhị phân:\n    \n```cpp\n\n    int binary_number = 0b1010;\n    \n```\n- **C++17:** Một bản cập nhật lớn khác giới thiệu các tính năng như:\n  - if và switch với bộ khởi tạo:\n    \n```cpp\n\n    if (auto it = my_map.find(key); it != my_map.end()) {\n        // sử dụng 'it' ở đây\n    }\n    \n```\n  - Các ràng buộc có cấu trúc:\n    \n```cpp\n\n    std::map<std::string, int> my_map = {{\"A\", 1}, {\"B\", 2}};\n    for (const auto& [key, value] : my_map) {\n        // sử dụng 'key' và 'value' tại đây\n    }\n    \n```\n- **C++20:** Bản cập nhật lớn mới nhất cho ngôn ngữ này, với các tính năng như:\n  - Khái niệm:\n    \n```cpp\n\n    template<typename T>\n    concept Addable = requires(T a, T b) {\n        { a + b } -> std::same_as<T>;\n    };\n    \n```\n  - Phạm vi:\n    \n```cpp\n\n    std::vector<int> numbers = {1, 2, 3, 4};\n    auto doubled = numbers |     std::views::transform([](int n) { return n * 2; });\n    \n```\n  - Coroutine và hơn thế nữa.\nHãy nhớ rằng để sử dụng các tính năng ngôn ngữ này, bạn có thể cần định cấu hình trình biên dịch của mình để sử dụng phiên bản chuẩn C++ cụ thể. Ví dụ: với GCC hoặc Clang, bạn có thể sử dụng cờ -std=c++11, -std=c++14, -std=c++17 hoặc -std=c++20."
                },
                {
                    "author": "Dev Alex",
                    "title": " C++11 và C++14",
                    "param": "chap-13-1",
                    "level": "beginner",
                    "code": "# C++11 và C++14\n**C++11:** Chuẩn C++11, còn được gọi là C++0x, được phát hành chính thức vào tháng 9 năm 2011. Nó giới thiệu một số tính năng và cải tiến ngôn ngữ mới, bao gồm:\n- **Tự động:** Cho phép trình biên dịch suy ra loại biến dựa trên biểu thức khởi tạo của nó.\n  \n```cpp\n\n  auto integer = 42; // số nguyên có kiểu int\n  auto floating = 3.14; // số thực là loại kép\n  \n```\n- **Vòng lặp dựa trên phạm vi:** Cung cấp ngữ nghĩa giống như foreach để lặp qua vùng chứa hoặc mảng.\n  \n```cpp\n\n  std::vector<int> numbers {1, 2, 3, 4};\n  for (int number : numbers) {\n      std::cout << number << std::endl;\n  }\n  \n```\n- **Hàm Lambda:** Các hàm ẩn danh cho phép tạo các đối tượng hàm dễ dàng hơn.\n  \n```cpp\n\n  auto add = [](int a, int b) -> int { return a + b; };\n  int sum = add(42, 13); // tổng bằng 55\n  \n```\n- **nullptr:** Một từ khóa mới để biểu thị các con trỏ null, an toàn hơn so với sử dụng chữ '0' hoặc \"NULL\".\n  \n```cpp\n\n  int *ptr = nullptr;\n  \n```\n- **Thư viện hỗ trợ luồng:** Cung cấp một cách chuẩn để làm việc với các luồng và đồng bộ hóa truy cập dữ liệu giữa các luồng.\n  \n```cpp\n\n  std::thread t([]() { std::cout << \"Hello from another thread\\n\"; });\n  t.join();\n  \n```\n**C++14:** Chuẩn C++14 được phát hành chính thức vào tháng 12 năm 2014 dưới dạng một phần mở rộng nhỏ so với C++11, tập trung nhiều hơn vào các tính năng ngôn ngữ tinh chỉnh và khắc phục sự cố. Một số tính năng mới được giới thiệu:\n- **Lambda chung:** Cho phép khai báo các tham số hàm lambda với trình giữ chỗ loại 'tự động'.\n  \n```cpp\n\n  auto add = [](auto a, auto b) { return a + b; };\n  auto sum_i = add(42, 13); // Vẫn hoạt động với số nguyên\n  auto sum_f = add(3.14, 2.72); // Bây giờ cũng hoạt động với số kép\n  \n```\n- **Chữ nhị phân:** Cho phép bạn nhập số nguyên dưới dạng chữ nhị phân để dễ đọc hơn.\n  \n```cpp\n\n  int b = 0b110101; // Giá trị thập phân là 53\n  \n```\n- **decltype(auto):** Suy ra loại biến để khớp với loại của biểu thức mà nó được khởi tạo.\n  \n```cpp\n\n  auto func = [](auto a, auto b) { return a * b; };\n  decltype(auto) result = func(5, 3.14); // decltype(auto) suy ra thành \"số kép\"\n  \n```\n- **Mẫu biến:** Cho phép bạn xác định các biến với tham số mẫu.\n  \n```cpp\n\n  template <typename T>\n  constexpr T pi = T(3.1415926535897932385);\n  float r = pi<float>; // Khởi tạo dưới dạng float\n  double d = pi<double>; // Khởi tạo dưới dạng double\n  \n```"
                },
                {
                    "author": "Dev Alex",
                    "title": " C++17",
                    "param": "chap-13-2",
                    "level": "beginner",
                    "code": "# C++17\nC++17, còn được gọi là C++1z, là phiên bản của ngôn ngữ lập trình C++ được xuất bản vào tháng 12 năm 2017. Phiên bản này được xây dựng dựa trên tiêu chuẩn trước đó, C++14, đồng thời bổ sung nhiều tính năng và cải tiến mới để cải thiện khả năng diễn đạt, hiệu suất và khả năng sử dụng của ngôn ngữ.\n\n## Các tính năng chính:\n- If-init-statement: Giới thiệu một cú pháp mới để viết các điều kiện với phạm vi bên trong các câu lệnh if và switch.\n\n```cpp\n\nif(auto it = map.find(key); it != map.end())\n{\n    // Use it\n}\n\n```\n- Khai báo ràng buộc có cấu trúc: Đơn giản hóa quá trình giải nén một bộ, cặp hoặc các loại tổng hợp khác.\n\n```cpp\n\nmap<string, int> data;\nauto [iter, success] = data.emplace(\"example\", 42);\n\n```\n- Biến inline: Bật từ khóa inlike cho các biến và cho phép định nghĩa duy nhất các biến tĩnh toàn cục và lớp trong file header.\n\n```cpp\n\ninline int globalVar = 0;\n\n```\n- Biểu thức fold: Giới thiệu biểu thức fold cho các mẫu biến đổi.\n\n```cpp\n\ntemplate <typename... Ts>\nauto sum(Ts... ts)\n{\n    return (ts + ...);\n}\n\n```\n- Câu lệnh constexpr if: Cho phép trình biên dịch có điều kiện trong thời gian biên dịch.\n\n```cpp\n\ntemplate <typename T>\nauto get_value(T t)\n{\n    if constexpr (std::is_pointer_v<T>)\n    {\n        return *t;\n    }\n    else\n    {\n        return t;\n    }\n}\n\n```\n- Cải thiện biểu thức lambda: Cho phép lambda chụp một đối tượng mà không thay đổi kiểu hoặc hằng số của nó.\n\n```cpp\n\nauto func = [x = std::move(obj)] { /* use x */ };\n\n```\n- Thư viện hệ thống tệp tiêu chuẩn: std::filesystem như một cách được tiêu chuẩn hóa để thao tác với đường dẫn, thư mục và tệp.\n- Các bổ sung Thư viện tiêu chuẩn mới: <string_view> (tham chiếu chuỗi không sở hữu), <any> (union phân biệt type-safe), <optional> (bao bọc xung quanh giá trị tùy chọn), <variant> (kiểu tổng type-safe) và <memory_resource> (thư viện dành cho bộ cấp phát đa hình).\n- Thuật toán song song: Thêm hỗ trợ để thực thi song song các thuật toán Thư viện chuẩn.\nTrên đây là một bản tóm tắt ngắn gọn về các tính năng chính của C++17; nó bao gồm nhiều tính năng hơn và cập nhật thư viện. Để biết danh sách đầy đủ, bạn có thể tham khảo **danh sách đầy đủ các tính năng và thay đổi của C++17**."
                },
                {
                    "author": "Dev Alex",
                    "title": " C++20",
                    "param": "chap-13-3",
                    "level": "beginner",
                    "code": "# C++20\nC++20 là tiêu chuẩn mới nhất của ngôn ngữ lập trình C++, mang lại những cải tiến đáng kể và các tính năng mới cho ngôn ngữ này. Phiên bản này nhằm tạo điều kiện thuận lợi cho các phương pháp phát triển phần mềm tốt hơn và cho phép các nhà phát triển viết mã code hiệu quả hơn, dễ đọc và dễ bảo trì hơn.\n\nDưới đây là một số tính năng chính được giới thiệu trong C++20:\n\n## Khái niệm\nCác khái niệm là một cách để thực thi các yêu cầu cụ thể đối với các tham số mẫu, cho phép bạn viết mã code rõ ràng và dễ hiểu hơn. Chúng cải thiện các thông báo lỗi khi sử dụng mẫu và đảm bảo rằng các tham số mẫu đáp ứng các tiêu chí cụ thể.\n\n```cpp\n\ntemplate <typename T>\nconcept Addable = requires (T a, T b) {\n    { a + b } -> std::same_as<T>;\n};\n\ntemplate <Addable T>\nT add(T a, T b) {\n    return a + b;\n}\n\n```\n\n## Phạm vi\nPhạm vi cung cấp một cách mới để làm việc với các chuỗi giá trị, nâng cao sức mạnh và tính biểu cảm của thuật toán Thư viện tiêu chuẩn. Các thuật toán dựa trên phạm vi giúp làm việc với các chuỗi dễ dàng và thuận tiện hơn.\n\n```cpp\n\n#include <algorithm>\n#include <iostream>\n#include <ranges>\n#include <vector>\n\nint main() {\n    std::vector<int> numbers = { 1, 2, 3, 4, 5 };\n\n    auto even_numbers = numbers | std::views::filter([](int n) { return n % 2 == 0; });\n\n    for (int n : even_numbers) {\n        std::cout << n << ' ';\n    }\n}\n\n```\n\n## Coroutine\nCoroutines là một cách mới để viết mã code đồng thời và không đồng bộ với khả năng đọc được cải thiện. Chúng cho phép các hàm bị treo và tiếp tục, cho phép bạn viết mã không chặn, hiệu quả hơn.\n\n```cpp\n\n#include <coroutine>\n#include <iostream>\n#include <future>\n\nstd::future<int> async_value(int value) {\n    co_await std::chrono::seconds(1);\n    co_return value * 2;\n}\n\nint main() {\n    auto result = async_value(42);\n    std::cout << \"Result: \" << result.get() << std::endl;\n}\n\n```\n\n## Từ khóa `constexpr` và `consteval`\nCả constexpr và consteval đều liên quan đến đánh giá thời gian biên dịch. Các hàm được đánh dấu bằng constexpr có thể được thực thi tại thời điểm biên dịch hoặc thời gian chạy, trong khi các hàm được đánh dấu bằng consteval chỉ có thể được thực thi tại thời điểm biên dịch.\n\n```cpp\n\nconstexpr int add(int a, int b) {\n    return a + b;\n}\n\nconsteval int square(int x) {\n    return x * x;\n}\n\nint main() {\n    constexpr int result1 = add(3, 4);   // được đánh giá tại thời điểm biên dịch\n    int result2 = add(5, 6);             // được đánh giá trong thời gian chạy\n    constexpr int result3 = square(7);   // được đánh giá tại thời điểm biên dịch\n}\n\n```\nĐây chỉ là một số điểm nổi bật của tiêu chuẩn C++20. Nó cũng bao gồm nhiều tính năng và cải tiến khác, như liên kết có cấu trúc, lambda cải tiến và các thành phần thư viện tiêu chuẩn mới. Nhìn chung, C++20 giúp các nhà phát triển viết mã code rõ ràng, hiệu quả và biểu cảm dễ dàng hơn."
                },
                {
                    "author": "Dev Alex",
                    "title": " C++ Chuẩn mới nhất: C++20",
                    "param": "chap-13-4",
                    "level": "beginner",
                    "code": "# C++ Chuẩn mới nhất: C++20\nC++20 là chuẩn mới nhất của ngôn ngữ lập trình C++, được xuất bản chính thức vào tháng 12 năm 2020. Tiêu chuẩn này giới thiệu nhiều tính năng, cải tiến và cải tiến mới so với các chuẩn trước đó. Dưới đây là tóm tắt ngắn gọn về một số tính năng chính trong C++20.\n- **Khái niệm:** Các khái niệm cung cấp một cách để chỉ định các ràng buộc đối với các tham số mẫu, đảm bảo rằng chúng đáp ứng một tập hợp các yêu cầu cụ thể. Điều này cho phép thông báo lỗi thời gian biên dịch tốt hơn và khả năng đọc mã code.\n  \n  Ví dụ:\n  \n```cpp\n\n  template<typename T>\n  concept Printable = requires(T x) {\n      {std::cout << x};\n  };\n\n  template<Printable T>\n  void print(const T& x) {\n      std::cout << x << '\\n';\n  }\n  \n```\n- **Phạm vi:** Phạm vi được xây dựng dựa trên khái niệm trình lặp và cung cấp một khung có thể sử dụng và kết hợp nhiều hơn để xử lý các chuỗi giá trị. Chúng đơn giản hóa cách các thuật toán có thể được áp dụng cho các tập hợp dữ liệu.\n\n  Ví dụ:\n  \n```cpp\n\n  #include <iostream>\n  #include <vector>\n  #include <ranges>\n\n  int main() {\n      std::vector<int> numbers{1, 2, 3, 4, 5};\n      auto even_view = numbers | std::views::filter([](int n) { return n % 2 == 0; });\n\n      for (int n : even_view) {\n          std::cout << n << ' ';\n      }\n  }\n  \n```\n- **Coroutine:** Coroutine cung cấp một cách để phân chia các hàm phức tạp, chạy dài thành các phần nhỏ hơn, dễ quản lý hơn, cho phép chúng bị treo và tiếp tục tại các điểm cụ thể.\n\n  Ví dụ:\n  \n```cpp\n\n  #include <iostream>\n  #include <coroutine>\n\n  std::generator<int> generator() {\n      for (int i = 0; i < 5; ++i)\n          co_yield i;\n  }\n\n  int main() {\n      for (int value : generator())\n          std::cout << value << ' ';\n  }\n  \n```\n- **Lambdas với tham số mẫu:** C++20 cho phép sử dụng auto làm tham số lambda, cho phép lambdas chung với tham số mẫu.\n\n  Ví dụ:\n  \n```cpp\n\n  auto sum = [](auto a, auto b) {\n      return a + b;\n  };\n\n  int res1 = sum(1, 2);           // int\n  double res2 = sum(1.0, 2.0);    // double\n  \n```\n- **Các cải tiến của constexpr:** hỗ trợ constexpr được mở rộng với các tính năng bổ sung, chẳng hạn như phân bổ động constexpr, khối try-catch constexpr và lambdas constexpr.\n\n  Ví dụ:\n  \n```cpp\n\n  struct Point {\n      constexpr Point(int x, int y): x_{x}, y_{y} {}\n      int x_, y_;\n  };\n\n  constexpr auto create_points() {\n      Point points[3]{};\n\n      for (int i = 0; i < 3; ++i) {\n          points[i] = Point{i, i * i};\n      }\n\n      return points;\n  }\n\n  constexpr auto points = create_points();\n  \n```\nCó nhiều tính năng khác trong C++20, chẳng hạn như cải tiến thư viện tiêu chuẩn mới, std::format, cải tiến lập trình thời gian biên dịch, v.v. Đây chỉ là một vài điểm nổi bật thể hiện tính linh hoạt và sức mạnh của tiêu chuẩn mới nhất của C++."
                },
                {
                    "author": "Dev Alex",
                    "title": " C++0x",
                    "param": "chap-13-5",
                    "level": "beginner",
                    "code": "# C++0x\ncpp0x đề cập đến name làm việc cho C++11, trước đây được gọi là C++0x trước khi phát hành chính thức. C++11 là bản sửa đổi chính của tiêu chuẩn ngôn ngữ C++, được xuất bản vào năm 2011 và mang lại một số tính năng và cải tiến mới cho ngôn ngữ này.\n\nMột số tính năng đáng chú ý trong C++11 bao gồm:\n- Từ khóa **auto** để suy luận kiểu tự động.\n\n```cpp\n\nauto i = 42; // i là một int\nauto s = \"hello\"; // s là một const char*\n\n```\n- **Vòng lặp for dựa trên phạm vi** để lặp lại dễ dàng hơn trên các bộ lưu trữ.\n\n```cpp\n\nstd::vector<int> vec = {1, 2, 3};\nfor (int i : vec) {\n    std::cout << i << std::endl;\n}\n\n```\n- Các **hàm lambda** để tạo các hàm ẩn danh.\n\n```cpp\n\nauto add = [](int a, int b) { return a + b; };\nint result = add(3, 4); // kết quả 7\n\n```\n- **nullptr** để biểu thị các giá trị con trỏ null, thay vì sử dụng NULL.\n\n```cpp\n\nint* p = nullptr;\n\n```\n- **Rvalue tham chiếu và di chuyển ngữ nghĩa** để tối ưu hóa việc xử lý các đối tượng tạm thời.\n\n```cpp\n\nstd::string str1 = \"hello\";\nstd::string str2 = std::move(str1); // di chuyển nội dung của str1 sang str2\n\n```\n- **Khuôn mẫu variadic** để tạo các mẫu có số lượng đối số thay đổi.\n\n```cpp\n\ntemplate <typename... Args>\nvoid printArgs(Args... args) {\n    // thân hàm\n}\n\n```\n- **Assertion tĩnh** cho xác nhận thời gian biên dịch.\n\n```cpp\n\nstatic_assert(sizeof(int) == 4, \"This code requires int to be 4 bytes.\");\n\n```\n- **Hỗ trợ luồng** cho lập trình đa luồng.\n\n```cpp\n\n#include <thread>\n\nvoid my_function() {\n    // thân hàm luồng\n}\n\nint main() {\n    std::thread t(my_function);\n    t.join();\n    return 0;\n}\n\n```\nĐây chỉ là một vài ví dụ về nhiều tính năng mới được giới thiệu trong C++11. Để có danh sách đầy đủ, bạn có thể tham khảo **tài liệu C++11**."
                }
            ]
        },
        {
            "title": "Chương 15 Bộ gỡ lỗi",
            "param": "chap-14-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " Trình gỡ lỗi",
                    "param": "chap-14-0",
                    "level": "beginner",
                    "code": "# Trình gỡ lỗi\nTrình gỡ lỗi là công cụ cần thiết cho bất kỳ lập trình viên C++ nào, vì chúng giúp phát hiện, chẩn đoán và sửa lỗi trong mã code. Chúng phục vụ như một nguồn tài nguyên vô giá trong việc xác định và hiểu các lỗi tiềm ẩn trong chương trình.\n\n## Các loại trình gỡ lỗi\nCó một số trình gỡ lỗi có sẵn để sử dụng với C++:\n- **GDB (Trình gỡ lỗi GNU):** Đây là trình gỡ lỗi C++ được sử dụng rộng rãi nhất trong môi trường Linux. Nó có thể gỡ lỗi nhiều ngôn ngữ, bao gồm cả C và C++.\n\n  Ví dụ sử dụng:\n  \n```cpp\n\n  g++ -g main.cpp -o main    # compile the code with debug info\n  gdb ./main                 # start gdb session\n  b main                     # set a breakpoint at the start of the main function\n  run                        # run the program\n  next                       # step to the next line\n  \n```\n- **LLDB:** Đây là trình gỡ lỗi được phát triển bởi LLVM. Nó hỗ trợ nhiều ngôn ngữ và phổ biến đối với các nhà phát triển macOS và iOS.\n\n  Ví dụ sử dụng:\n  \n```cpp\n\n  clang++ -g main.cpp -o main # compile the code with debug info\n  lldb ./main                 # start lldb session\n  breakpoint set --name main  # set a breakpoint at the start of the main function\n  run                         # run the program\n  next                        # step to the next line\n  \n```\n- **Trình gỡ lỗi Microsoft Visual Studio:** Trình gỡ lỗi này được tích hợp trong Visual Studio và thường được sử dụng trong giao diện đồ họa trên các hệ thống Windows.\n\n  Ví dụ sử dụng:\n  \n```cpp\n\n  Open your Visual Studio project and go to Debug > Start Debugging. Then use the step over (F10), step into (F11), or continue (F5) commands to navigate through the code.\n  \n```\n- **Intel Debugger (IDB):** Trình gỡ lỗi này là một phần của bộ phát triển song song của Intel và phổ biến cho các ứng dụng hiệu suất cao.\n- **TotalView Debugger:** Được phát triển bởi Rogue Wave Software, TotalView Debugger là một trình gỡ lỗi thương mại được thiết kế cho các ứng dụng doanh nghiệp, hiệu suất cao và song song.\n\nMỗi trình gỡ lỗi đều có những ưu điểm và tính năng độc đáo, vì vậy điều cần thiết là chọn một trình gỡ lỗi phù hợp nhất với nhu cầu của bạn và hoạt động tốt với môi trường phát triển của bạn."
                },
                {
                    "author": "Dev Alex",
                    "title": " Thông báo trình gỡ lỗi",
                    "param": "chap-14-1",
                    "level": "beginner",
                    "code": "# Thông báo trình gỡ lỗi\nThông báo của trình gỡ lỗi là các thông báo hoặc cảnh báo do trình gỡ lỗi cung cấp để giúp bạn xác định các sự cố hoặc lỗi trong mã C++ của mình. Các thông báo này có thể là cảnh báo hoặc thông báo lỗi và có thể cung cấp thông tin hữu ích về trạng thái chương trình của bạn và các sự cố cụ thể gặp phải trong quá trình gỡ lỗi.\n\n## Các loại thông báo trình gỡ lỗi\n- **Thông báo lỗi:** Thông báo cho bạn về các sự cố trong mã code ngăn chương trình chạy hoặc biên dịch chính xác. Các thông báo này thường bao gồm thông tin về tệp và số dòng phát hiện lỗi, theo sau là mô tả về sự cố.\n\n  Ví dụ:\n  \n```cpp\n\n  test.cpp: In function 'int main()':\n  test.cpp:6:5: error: 'cout' was not declared in this scope\n       cout << \"Hello World!\";\n       ^\n```\n  \n```cpp\n\n- **Thông báo cảnh báo:** Thông báo cho bạn về các sự cố tiềm ẩn hoặc các hoạt động lập trình rủi ro có thể không nhất thiết gây ra lỗi nhưng có thể dẫn đến các sự cố sau này. Giống như thông báo lỗi, thông báo cảnh báo thường bao gồm thông tin về tệp và số dòng nơi tìm thấy sự cố, cùng với mô tả sự cố.\n\n  Ví dụ:\n  \n```\n  test.cpp: In function 'int main()':\n  test.cpp:6:17: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]\n       if (a < size)\n                ^\n  \n```cpp\n\n- **Thông báo thông tin:** Cung cấp thông tin chung về việc thực hiện chương trình, chẳng hạn như điểm ngắt, điểm theo dõi và giá trị biến. Các thông báo này cũng có thể tiết lộ trạng thái hiện tại của chương trình, bao gồm ngăn xếp cuộc gọi và danh sách các luồng đang hoạt động.\n\n  Ví dụ (giả sử bạn đang sử dụng GDB làm trình gỡ lỗi):\n  \n```\n  (gdb) break main\n  Breakpoint 1 at 0x40055f: file test.cpp, line 5.\n  (gdb) run\n  Starting program: /path/to/test\n  Breakpoint 1, main () at test.cpp:5\n  5       int a = 5;\n  \n```cpp\n\n\n## Ví dụ mã code\nĐể sử dụng thông báo trình gỡ lỗi, bạn cần sử dụng trình gỡ lỗi, chẳng hạn như GDB hoặc Trình gỡ lỗi Visual Studio và bao gồm các cờ cụ thể trong quá trình biên dịch.\n\nVí dụ sử dụng GDB:\n\n```\n// test.cpp\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int num1 = 10;\n    int num2 = 0;\n    int result = num1 / num2;\n\n    cout << \"Result: \" << result << endl;\n\n    return 0;\n}\n\n```cpp\n\n\n```\n$ g++ -g -o test test.cpp  // Biên dịch với cờ -g để bao hàm thông tin gỡ lỗi information\n$ gdb ./test               // Chạy trình gỡ lỗi GDB\n(gdb) run                  // Thực thi chương trình bên trong GDB\n\n```cpp\n\nTại điểm này, trình gỡ lỗi sẽ hiển thị thông báo lỗi được kích hoạt bởi phép chia cho 0:\n\n```\nProgram received signal SIGFPE, Arithmetic exception.\n0x00005555555546fb in main () at test.cpp:7\n7       int result = num1 / num2;\n\n```cpp\n\nGiờ đây, bạn có thể thực hiện các thay đổi phù hợp để khắc phục sự cố trong mã code C++ của mình."
                },
                {
                    "author": "Dev Alex",
                    "title": " Ký hiệu trình gỡ lỗi",
                    "param": "chap-14-2",
                    "level": "beginner",
                    "code": "# Ký hiệu trình gỡ lỗi\nCác ký hiệu trình gỡ lỗi là thông tin bổ sung được nhúng trong mã nhị phân của chương trình đã biên dịch, giúp trình gỡ lỗi hiểu cấu trúc, mã nguồn và các biểu diễn biến tại một điểm cụ thể trong quá trình thực thi.\n\nCó hai kiểu ký hiệu gỡ lỗi chung:\n- **Các ký hiệu gỡ lỗi nội bộ:** Các ký hiệu này nằm trong chính mã nhị phân đã biên dịch. Khi sử dụng các ký hiệu gỡ lỗi nội bộ, cần lưu ý rằng kích thước của mã nhị phân tăng lên, điều này có thể không mong muốn đối với môi trường sản xuất (production environment).\n- **Ký hiệu gỡ lỗi bên ngoài:** Các ký hiệu gỡ lỗi được lưu trong các tệp riêng biệt ngoài mã nhị phân, thường có phần mở rộng tệp như .pdb (Cơ sở dữ liệu chương trình) trong Windows hoặc .dSYM (Thông tin ký hiệu DWARF) trong macOS.\n\n## Tạo ký hiệu trình gỡ lỗi\nĐể tạo các ký hiệu trình gỡ lỗi trong C++, bạn cần chỉ định các tùy chọn cụ thể trong quá trình biên dịch. Chúng tôi sẽ sử dụng trình biên dịch g++ làm ví dụ.\n\n### Ký hiệu gỡ lỗi nội bộ (g ++)\nĐể tạo bản dựng gỡ lỗi với các biểu tượng gỡ lỗi bên trong, hãy sử dụng cờ -g:\n\n```\ng++ -g -o my_program my_program.cpp\n\n```cpp\n\nLệnh này biên dịch my_program.cpp thành tệp thực thi có tên my_program với các ký hiệu gỡ lỗi bên trong.\n\n### Ký hiệu gỡ lỗi bên ngoài (g ++)\nTrong trường hợp bạn muốn tạo một tệp riêng chứa các biểu tượng gỡ lỗi, bạn có thể sử dụng cờ -gsplit-dwarf:\n\n```\ng++ -g -gsplit-dwarf -o my_program my_program.cpp\n\n```cpp\n\nLệnh này biên dịch my_program.cpp thành tệp thực thi có tên my_program và tạo một tệp riêng có tên my_program.dwo chứa các ký hiệu gỡ lỗi.\n\nKhi chia sẻ tệp nhị phân đã biên dịch của bạn cho người dùng cuối, bạn có thể xóa các ký hiệu gỡ lỗi bằng cách sử dụng lệnh strip:\n\n```\nstrip --strip-debug my_program\n\n```cpp\n\nLệnh này loại bỏ các biểu tượng gỡ lỗi nội bộ, dẫn đến kích thước nhị phân nhỏ hơn trong khi vẫn giữ tệp .dwo cho mục đích gỡ lỗi khi cần.\n\nHãy nhớ rằng tính khả dụng và cú pháp của các tùy chọn này có thể khác nhau giữa các trình biên dịch và nền tảng khác nhau. Tham khảo tài liệu của trình biên dịch để đảm bảo sử dụng đúng các tùy chọn gỡ lỗi."
                },
                {
                    "author": "Dev Alex",
                    "title": " WinDbg",
                    "param": "chap-14-3",
                    "level": "beginner",
                    "code": "# WinDbg\nWinDbg là trình sửa lỗi mạnh mẽ dành cho các ứng dụng Windows, được bao gồm trong Microsoft Windows SDK. Nó cung cấp một bộ tính năng phong phú để giúp bạn phân tích và gỡ lỗi các chương trình phức tạp, chế độ truy cập hoàn chỉnh và không hạn chế vào phần cứng bên dưới (kernel mode) và mã code chế độ người dùng (user-mode). Với giao diện đồ họa thân thiện với người dùng, WinDbg có thể giúp phân tích các tệp kết xuất sự cố, thiết lập các điểm ngắt và từng bước thực thi mã code.\n\n## Bắt đầu\nĐể bắt đầu sử dụng WinDbg, trước tiên bạn cần cài đặt nó. Bạn có thể tải xuống **Windows SDK** và cài đặt nó để nhận WinDbg.\n\n## Tải xuống ký hiệu\nWinDbg dựa vào các tệp ký hiệu (*.pdb) để cung cấp thêm thông tin hữu ích về cấu trúc, hàm và biến bên trong của chương trình. Để tải ký hiệu đúng cách, bạn có thể cần định cấu hình đường dẫn ký hiệu:\n\n```\n!sym noisy\n.sympath SRV*C:\\symbols*http://msdl.microsoft.com/download/symbols\n.reload /f\n\n```cpp\n\n\n## Mở tệp thực thi và tệp kết xuất sự cố\nĐể gỡ lỗi một tệp thực thi bằng WinDbg, hãy đi tới File > Open Executable..., sau đó định vị và mở chương trình đích. Để phân tích kết xuất sự cố, thay vào đó, hãy sử dụng File > Open Crash Dump...\n\n## Lệnh cơ bản\nMột số lệnh phổ biến bạn có thể sử dụng trong WinDbg:\n- g: Thực hiện chương trình cho đến điểm dừng hoặc ngoại lệ tiếp theo\n- bp <address>: Đặt điểm dừng tại một địa chỉ nhất định\n- bl: Liệt kê tất cả các điểm dừng\n- bd <breakpoint_id>: Vô hiệu hóa một điểm dừng\n- be <breakpoint_id>: Bật điểm dừng\n- bc <breakpoint_id>: Xóa một điểm dừng\n- t: Hướng dẫn một bước thông qua (dấu vết)\n- p: Bước qua hướng dẫn (tiến hành)\n- k: Hiển thị ngăn xếp cuộc gọi\n- dd: Hiển thị nội dung bộ nhớ theo đơn vị 4 byte (từ double)\n- da: Hiển thị nội dung bộ nhớ dưới dạng chuỗi ASCII\n- !analyze -v: Phân tích trạng thái chương trình và cung cấp thông tin chi tiết\n\n## Ví dụ sử dụng\nGỡ lỗi một chương trình đơn giản:\n- Mở tệp thực thi trong WinDbg\n- Đặt điểm dừng bằng cách sử dụng bp <address>\n- Chạy chương trình bằng g\n- Khi điểm ngắt được nhấn, hãy sử dụng t hoặc p để chuyển qua mã code\n- Hãy thử k để xem ngăn xếp cuộc gọi hoặc dd, da để kiểm tra bộ nhớ\n- Xóa điểm ngắt và tiếp tục gỡ lỗi bằng các lệnh khác nếu cần\n\nHãy nhớ rằng WinDbg có vô số lệnh và chức năng, vì vậy điều cần thiết là phải làm quen với **tài liệu** và khám phá vô số tài nguyên sẵn có dành riêng cho các tác vụ gỡ lỗi của bạn."
                },
                {
                    "author": "Dev Alex",
                    "title": " GDB: Trình gỡ lỗi GNU",
                    "param": "chap-14-4",
                    "level": "beginner",
                    "code": "# GDB: Trình gỡ lỗi GNU\nGDB, hay Trình gỡ lỗi dự án GNU, là một trình gỡ lỗi dòng lệnh mạnh được sử dụng chủ yếu cho C, C++ và các ngôn ngữ khác. Nó có thể giúp bạn tìm lỗi thời gian chạy, kiểm tra trạng thái thực thi của chương trình và điều khiển luồng để phát hiện và sửa lỗi một cách dễ dàng.\n\n## Bắt đầu với GDB\nĐể bắt đầu sử dụng GDB, trước tiên bạn cần biên dịch mã code của mình bằng cờ -g, bao gồm thông tin gỡ lỗi trong tệp thực thi:\n\n```\ng++ -g myfile.cpp -o myfile\n\n```cpp\n\nBây giờ, bạn có thể tải chương trình đã biên dịch của mình vào GDB:\n\n```\ngdb myfile\n\n```cpp\n\n\n## Các lệnh GDB cơ bản\nDưới đây là một số lệnh GDB phổ biến mà bạn sẽ thấy hữu ích khi gỡ lỗi:\n- run: Bắt đầu chương trình của bạn.\n- break [function/line number]: Đặt điểm dừng tại hàm hoặc dòng đã chỉ định.\n- continue: Tiếp tục thực hiện chương trình sau khi dừng tại breakpoint.\n- next: Thực thi dòng mã tiếp theo, bước qua các lệnh gọi hàm.\n- step: Thực thi dòng mã code tiếp theo, nhập các lời gọi hàm.\n- print [expression]: Đánh giá một biểu thức trong ngữ cảnh hiện tại và hiển thị giá trị của nó.\n- backtrace: Hiển thị ngăn xếp cuộc gọi hiện tại.\n- frame [frame-number]: Chuyển sang một khung ngăn xếp khác.\n- quit: Thoát khỏi GDB.\n\n## Ví dụ sử dụng\nGiả sử bạn có một tệp cpp đơn giản có tên là example.cpp:\n\n```\n#include <iostream>\n\nvoid my_function(int i) {\n  std::cout << \"In my_function with i = \" << i << std::endl;\n}\n\nint main() {\n  for (int i = 0; i < 5; ++i) {\n    my_function(i);\n  }\n  return 0;\n}\n\n```cpp\n\nĐầu tiên, biên dịch mã code với các biểu tượng gỡ lỗi:\n\n```\ng++ -g example.cpp -o example\n\n```cpp\n\nBắt đầu GDB và tải chương trình example:\n\n```\ngdb example\n\n```cpp\n\nĐặt điểm ngắt trong hàm my_function và chạy chương trình:\n\n```\n(gdb) break my_function\n(gdb) run\n\n```cpp\n\nSau khi dừng tại điểm ngắt, hãy sử dụng next, print và continue kiểm tra trạng thái của chương trình:\n\n```\n(gdb) next\n(gdb) print i\n(gdb) continue\n\n```cpp\n\nCuối cùng, thoát GDB bằng lệnh quit.\n\nĐây chỉ là một bản tóm tắt ngắn gọn về GDB; bạn có thể tìm thêm chi tiết trong **hướng dẫn GDB chính thức**."
                }
            ]
        },
        {
            "title": "Chương 16 Bộ biên dịch",
            "param": "chap-15-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " Trình biên dịch",
                    "param": "chap-15-0",
                    "level": "beginner",
                    "code": "# Trình biên dịch\nTrình biên dịch là một chương trình máy tính dịch mã code nguồn được viết bằng một ngôn ngữ lập trình sang một ngôn ngữ khác, thường là mã code máy hoặc mã code hợp ngữ, có thể được thực thi trực tiếp bởi bộ xử lý của máy tính. Trong ngữ cảnh của C++, các trình biên dịch lấy mã nguồn C++ đã viết của bạn và chuyển đổi nó thành một chương trình thực thi được.\n\n## Trình biên dịch C++ phổ biến\nCó một số trình biên dịch C++ phổ biến hiện có, đây là danh sách ngắn một số trình biên dịch phổ biến:\n- **Tập hợp trình biên dịch GNU (GCC):** Được phát triển bởi Dự án GNU, GCC là trình biên dịch nguồn mở hỗ trợ nhiều ngôn ngữ lập trình, bao gồm C++.\n- **Clang:** Là một phần của dự án LLVM, Clang là một trình biên dịch nguồn mở khác hỗ trợ C++ và được biết đến với thời gian biên dịch nhanh và chẩn đoán mở rộng.\n- **Microsoft Visual C++ (MSVC):** MSVC là trình biên dịch thương mại do Microsoft cung cấp như một phần của Visual Studio và được sử dụng rộng rãi trên nền tảng Windows.\n- **Trình biên dịch Intel C++ (ICC):** ICC là trình biên dịch thương mại do Intel cung cấp và được biết đến với khả năng tối ưu hóa mã cho bộ xử lý Intel mới nhất.\n\n## Ví dụ về trình biên dịch C++ đơn giản\nGiả sử bạn có một chương trình C++ đơn giản được lưu trong một tệp có tên hello.cpp:\n\n```\n#include <iostream>\n\nint main() {\n  std::cout << \"Hello, World!\" << std::endl;\n  return 0;\n}\n\n```cpp\n\nBạn có thể biên dịch chương trình này bằng trình biên dịch GCC bằng cách thực hiện lệnh sau trong dòng lệnh/thiết bị đầu cuối:\n\n```\ng++ hello.cpp -o hello\n\n```cpp\n\nThao tác này sẽ tạo ra một tệp thực thi có tên hello (hoặc hello.exe trên Windows) mà bạn có thể chạy để xem kết quả đầu ra “Hello, World!“.\n\n## Chú ý\nKhi tìm hiểu về trình biên dịch, điều cần thiết là phải biết rằng chúng hoạt động chặt chẽ với trình liên kết và thư viện chuẩn. Trình liên kết đảm nhiệm việc kết hợp các tệp đối tượng và thư viện đã biên dịch thành một tệp thực thi duy nhất, trong khi thư viện chuẩn cung cấp các triển khai cho các chức năng phổ biến được sử dụng trong mã code của bạn."
                },
                {
                    "author": "Dev Alex",
                    "title": " Các giai đoạn biên dịch trong C++",
                    "param": "chap-15-1",
                    "level": "beginner",
                    "code": "# Các giai đoạn biên dịch trong C++\nQuá trình biên dịch trong C++ có thể được chia thành bốn giai đoạn chính: Tiền xử lý, Trình biên dịch, Hợp ngữ và Liên kết. Mỗi giai đoạn thực hiện một nhiệm vụ cụ thể, cuối cùng là chuyển đổi mã code nguồn thành chương trình thực thi.\n\n## Tiền xử lý\nGiai đoạn đầu tiên là tiền xử lý mã nguồn. Bộ tiền xử lý sửa đổi mã nguồn trước quá trình biên dịch thực tế. Chúng xử lý các lệnh bắt đầu bằng ký hiệu # (giá trị băm), như #include, #define và #if. Trong giai đoạn này, các tệp tiêu đề đi kèm được mở rộng, các macro được thay thế và các câu lệnh biên dịch có điều kiện được xử lý.\n\nVí dụ mã code:\n\n```\n#include <iostream>\n#define PI 3.14\n\nint main() {\n    std::cout << \"The value of PI is: \" << PI << std::endl;\n    return 0;\n}\n\n```cpp\n\n\n## Trình biên dịch\nGiai đoạn thứ hai là quá trình biên dịch thực sự của mã nguồn đã được xử lý trước. Trình biên dịch dịch mã nguồn đã sửa đổi thành một biểu diễn trung gian, thường dành riêng cho cấu trúc bộ xử lý đích. Bước này cũng liên quan đến việc thực hiện kiểm tra cú pháp, phân tích ngữ nghĩa và tạo thông báo lỗi cho bất kỳ sự cố nào gặp phải trong mã nguồn.\n\nVí dụ mã code:\n\n```\nint main() {\n    int a = 10;\n    int b = 20;\n    int sum = a + b;\n    return 0;\n}\n\n```cpp\n\n\n## Hợp ngữ\nGiai đoạn thứ ba là chuyển đổi biểu diễn trung gian của trình biên dịch thành hợp ngữ. Giai đoạn này tạo mã hợp ngữ bằng cách sử dụng thuật nhớ và cú pháp dành riêng cho kiến trúc bộ xử lý đích. Các trình hợp ngữ sau đó chuyển đổi mã code hợp ngữ này thành mã code đối tượng (mã code máy).\n\nVí dụ mã code (x86 hợp ngữ):\n\n```\nmov eax, 10\nmov ebx, 20\nadd eax, ebx\n\n```cpp\n\n\n## Liên kết\nGiai đoạn cuối cùng là liên kết mã đối tượng với các thư viện cần thiết và các tệp đối tượng khác. Trong giai đoạn này, trình liên kết hợp nhất nhiều tệp đối tượng và thư viện, giải quyết các tham chiếu bên ngoài từ các mô-đun hoặc thư viện khác, phân bổ địa chỉ bộ nhớ cho các hàm và biến, đồng thời tạo tệp thực thi có thể chạy trên nền tảng đích.\n\nVí dụ mã code (liên kết các đối tượng và thư viện):\n\n```\n$ g++ main.o -o main -lm\n\n```cpp\n\nTóm lại, quá trình biên dịch trong C++ bao gồm bốn giai đoạn chính: tiền xử lý, biên dịch, hợp ngữ và liên kết. Mỗi giai đoạn đóng một vai trò quan trọng trong việc chuyển đổi mã nguồn thành một chương trình thực thi được."
                },
                {
                    "author": "Dev Alex",
                    "title": " Các tính năng của trình biên dịch C++",
                    "param": "chap-15-2",
                    "level": "beginner",
                    "code": "# Các tính năng của trình biên dịch C++\nCác trình biên dịch C++ khác nhau có các tính năng khác nhau. Một số tính năng phổ biến nhất của trình biên dịch C++ là:\n- **Tối ưu hóa:** Trình biên dịch có thể tối ưu hóa mã code để cải thiện hiệu suất của chương trình. Ví dụ: chúng có thể loại bỏ mã thừa, hàm nội tuyến và thực hiện hủy vòng lặp.\n- **Gỡ lỗi:** Trình biên dịch có thể tạo thông tin gỡ lỗi có thể được sử dụng để gỡ lỗi chương trình.\n- **Cảnh báo:** Trình biên dịch có thể tạo cảnh báo cho mã đáng ngờ có thể gây ra lỗi.\n\nMột số trình biên dịch C++ phổ biến nhất là:\n- **Bộ thu thập trình biên dịch GNU (GCC):** GCC là trình biên dịch mã nguồn mở và miễn phí hỗ trợ nhiều ngôn ngữ lập trình, bao gồm cả C++.\n- **Clang:** Clang là trình biên dịch C++ nằm trong dự án LLVM. Nó được thiết kế để tương thích với GCC.\n- **Microsoft Visual C++:** Microsoft Visual C++ là trình biên dịch C++ là một phần của Microsoft Visual Studio IDE.\n- **Trình biên dịch Intel C++:** Trình biên dịch Intel C++ là trình biên dịch C++ nằm trong bộ Intel Parallel Studio XE.\nBạn nên xem qua tài liệu về trình biên dịch của mình để tìm hiểu thêm về các tính năng của nó."
                }
            ]
        },
        {
            "title": "Chương 17 Xây dựng hệ thống",
            "param": "chap-16-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " Xây dựng hệ thống trong C++",
                    "param": "chap-16-0",
                    "level": "beginner",
                    "code": "# Xây dựng hệ thống trong C++\nHệ thống xây dựng là một tập hợp các công cụ và tiện ích giúp tự động hóa quá trình biên dịch, liên kết và thực thi các tệp mã nguồn trong một dự án. Mục tiêu chính của hệ thống xây dựng là quản lý sự phức tạp của quá trình biên dịch và cuối cùng tạo ra một bản dựng (tệp thực thi hoặc tệp nhị phân). Trong C++ (cpp), một số hệ thống xây dựng phổ biến là:\n- **GNU Make:** Đây là một hệ thống xây dựng phổ biến sử dụng Makefile để xác định quy trình xây dựng. Nó kiểm tra các phần phụ thuộc và thời gian được ghi lại của các tệp nguồn để xác định tệp nào cần được biên dịch và liên kết.\n\n  Ví dụ mã code:\n  \n```\n  # Makefile\n  CXX = g++\n  CPPFLAGS = -Wall -std=c++11\n  TARGET = HelloWorld\n\n  all: $(TARGET)\n\n  $(TARGET): main.cpp\n      $(CXX) $(CPPFLAGS)main.cpp -o $(TARGET)\n\n  clean:\n      rm $(TARGET)\n  \n```cpp\n\n- **CMake:** Đây là một hệ thống xây dựng đa nền tảng tập trung vào việc xác định các phụ thuộc của dự án và quản lý môi trường xây dựng. CMake tạo các tệp build (như Makefiles) cho các nền tảng khác nhau và cho phép nhà phát triển viết mã nguồn một lần, sau đó biên dịch nó cho các nền tảng đích khác nhau.\n\n  Ví dụ mã code:\n  \n```\n  # CMakeLists.txt\n  cmake_minimum_required(VERSION 3.10)\n  project(HelloWorld)\n\n  set(CMAKE_CXX_STANDARD 11)\n\n  add_executable(HelloWorld main.cpp)\n  \n```cpp\n\n- **Autotools:** Còn được gọi là Hệ thống xây dựng GNU, bao gồm các công cụ GNU Autoconf, Automake và Libtool cho phép các nhà phát triển tạo phần mềm di động trên các hệ thống dựa trên Unix khác nhau. Đối với dự án C++, bạn sẽ cần tạo các tệp configure.ac, Makefile.am với các quy tắc cụ thể, sau đó chạy các lệnh sau trong thiết bị đầu cuối để xây dựng dự án:\n  \n```\n  autoreconf --install\n  ./configure\n  make\n  make install\n  \n```cpp\n\n- **SCons:** Hệ thống xây dựng này sử dụng Python để xây dựng tập lệnh, làm cho nó cụ thể hơn GNU Make. Nó cũng có thể xây dựng đồng thời cho nhiều nền tảng và cấu hình.\n\n  Ví dụ mã code:\n  \n```\n  # SConstruct\n  env = Environment()\n  env.Program(target=\"HelloWorld\", source=[\"main.cpp\"])\n  \n```cpp\n\n- **Ninja:** Một hệ thống xây dựng nhỏ và tập trung lấy danh sách các mục tiêu được chỉ định trong tệp văn bản mà con người có thể đọc được và xây dựng chúng nhanh nhất có thể.\n\n  Ví dụ mã code:\n  \n```\n  # build.ninja\n  rule cc\n    command = g++ -c $in -o $out\n\n  rule link\n    command = g++ $in -o $out\n\n  build main.o: cc main.cpp\n  build HelloWorld: link main.o\n    default HelloWorld\n  \n```cpp\n\nĐây là một số hệ thống xây dựng phổ biến trong C++, mỗi hệ thống có cú pháp và khả năng riêng. Mặc dù Make được sử dụng rộng rãi nhưng CMake là một hệ thống xây dựng đa nền tảng tạo các tệp xây dựng cho các hệ thống xây dựng khác như Make hoặc Ninja. Autotools phù hợp để tạo phần mềm di động, SCons tận dụng Python cho các tập lệnh xây dựng của nó và Ninja tập trung vào thời gian xây dựng nhanh."
                },
                {
                    "author": "Dev Alex",
                    "title": " CMake",
                    "param": "chap-16-1",
                    "level": "beginner",
                    "code": "# CMake\nCMake là một hệ thống xây dựng đa nền tảng mạnh mẽ giúp tạo các tệp xây dựng, Makefile hoặc không gian làm việc cho các nền tảng và trình biên dịch khác nhau. Không giống như các hệ thống xây dựng khác, CMake không thực sự xây dựng dự án, nó chỉ tạo các tệp cần thiết cho các công cụ xây dựng. CMake được sử dụng rộng rãi, đặc biệt là trong các dự án C++, vì tính linh hoạt và dễ sử dụng của nó.\n\n## CMakeLists.txt\nCMake sử dụng tệp có tên CMakeLists.txt để xác định cài đặt, tệp nguồn, thư viện và các cấu hình khác. Một CMakeLists.txt điển hình cho một dự án đơn giản sẽ như sau:\n\n```\ncmake_minimum_required(VERSION 3.0)\n\nproject(MyProject)\n\nset(SRC_DIR \"${CMAKE_CURRENT_LIST_DIR}/src\")\nset(SOURCES \"${SRC_DIR}/main.cpp\" \"${SRC_DIR}/file1.cpp\" \"${SRC_DIR}/file2.cpp\")\n\nadd_executable(${PROJECT_NAME} ${SOURCES})\n\ntarget_include_directories(${PROJECT_NAME} PRIVATE \"${CMAKE_CURRENT_LIST_DIR}/include\")\n\nset_target_properties(${PROJECT_NAME} PROPERTIES\n    CXX_STANDARD 14\n    CXX_STANDARD_REQUIRED ON\n    CXX_EXTENSIONS OFF\n)\n\n```cpp\n\n\n## Xây dựng với CMake\nĐây là một ví dụ về quy trình xây dựng đơn giản bằng CMake:\n- Tạo một thư mục mới cho bản dựng.\n  \n```\n  mkdir build\n  cd build\n  \n```cpp\n\n- Tạo tệp xây dựng bằng CMake.\n  \n```\n  cmake ..\n  \n```cpp\n\nTrong ví dụ này, .. cho biết thư mục mẹ chứa CMakeLists.txt. Các tệp bản dựng sẽ được tạo trong thư mục build.\n- Xây dựng dự án bằng các tệp xây dựng được tạo.\n  \n```\n  make\n  \n```cpp\n\nHoặc, trên Windows với Visual Studio, bạn có thể sử dụng:\n\n```\nmsbuild MyProject.sln\n\n```cpp\n\nCMake giúp dễ dàng quản lý các dự án lớn, xác định cấu hình bản dựng tùy chỉnh và làm việc với nhiều trình biên dịch và hệ điều hành khác nhau. Làm cho nó trở thành một công cụ được lựa chọn rộng rãi để quản lý các hệ thống xây dựng trong các dự án C++."
                },
                {
                    "author": "Dev Alex",
                    "title": " Makefile",
                    "param": "chap-16-2",
                    "level": "beginner",
                    "code": "# Makefile\nMakefile là một tệp cấu hình được sử dụng bởi tiện ích make để tự động hóa quá trình biên dịch và liên kết mã code trong một dự án C++. Nó bao gồm một tập hợp các quy tắc và phần phụ thuộc giúp xây dựng tệp thực thi đích hoặc thư viện từ các tệp mã nguồn.\n\nMakefiles giúp các nhà phát triển tiết kiệm thời gian, giảm lỗi và đảm bảo tính nhất quán trong quá trình xây dựng. Họ đạt được điều này bằng cách chỉ định các phụ thuộc giữa các tệp nguồn khác nhau và cung cấp các lệnh tạo tệp đầu ra (chẳng hạn như tệp đối tượng và tệp thực thi) từ tệp đầu vào (chẳng hạn như mã nguồn và tiêu đề).\n\n## Cấu trúc của một Makefile\nMột Makefile điển hình có cấu trúc như sau:\n- **Biến:** Xác định các biến để lưu trữ các giá trị thường được sử dụng, chẳng hạn như cờ trình biên dịch, thư mục hoặc tên đích.\n- **Quy tắc:** Xác định cách tạo tệp đầu ra từ tệp đầu vào bằng cách sử dụng một bộ lệnh. Mỗi quy tắc có một đích, một tập hợp các điều kiện tiên quyết và một công thức.\n- **Các đích giả:** Các đích không đại diện cho các tệp thực tế trong dự án nhưng phục vụ như một cách để nhóm các quy tắc có liên quan và gọi chúng bằng một lệnh duy nhất.\n\n## Ví dụ\nHãy xem xét một dự án C++ cơ bản với cấu trúc thư mục sau:\n\n```\nproject/\n|-- include/\n|   |-- header.h\n|-- src/\n|   |-- main.cpp\n|-- Makefile\n\n```cpp\n\nMột Makefile đơn giản cho dự án này có thể như sau:\n\n```\n# Variables\nCXX = g++\nCXXFLAGS = -Wall -Iinclude\nSRC = src/main.cpp\nOBJ = main.o\nEXE = my_program\n\n# Rules\n$(EXE): $(OBJ)\n\t$(CXX) $(CXXFLAGS) -o $(EXE) $(OBJ)\n\n$(OBJ): $(SRC)\n\t$(CXX) $(CXXFLAGS) -c $(SRC)\n\n# Phony targets\n.PHONY: clean\nclean:\n\trm -f $(OBJ) $(EXE)\n\n```cpp\n\nVới Makefile này, bạn chỉ cần chạy make trong terminal để xây dựng dự án và make clean để xóa các tệp đầu ra. Makefile chỉ định các phụ thuộc giữa mã nguồn, tệp đối tượng và tệp thực thi cuối cùng, cũng như các lệnh để biên dịch và liên kết chúng.\n\n## Tóm tắt\nMakefiles cung cấp một cách hiệu quả để tự động hóa việc xây dựng các dự án C++ bằng cách sử dụng tiện ích make. Chúng mô tả các phụ thuộc và lệnh cần thiết để tạo tệp đầu ra từ mã nguồn, tiết kiệm thời gian và đảm bảo tính nhất quán trong quá trình xây dựng."
                },
                {
                    "author": "Dev Alex",
                    "title": " Ninja",
                    "param": "chap-16-3",
                    "level": "beginner",
                    "code": "# Ninja\nNinja là một hệ thống xây dựng nhỏ tập trung vào tốc độ. Nó được thiết kế để xử lý các dự án lớn bằng cách tạo các tệp xây dựng thực hiện khối lượng công việc tối thiểu cần thiết để xây dựng mã code. Điều này dẫn đến thời gian xây dựng nhanh hơn, đặc biệt đối với các cơ sở mã lớn. Ninja thường được sử dụng cùng với các hệ thống xây dựng khác như CMake, hệ thống này có thể tạo các tệp xây dựng Ninja cho bạn.\n\nCác tệp bản dựng ninja thường được đặt tên là build.ninja và chứa các quy tắc, câu lệnh xây dựng và khai báo biến. Đây là một ví dụ đơn giản về tệp xây dựng Ninja cho dự án C++:\n\n```\n# Variable declarations\ncxx = g++\ncflags = -Wall -Wextra -std=c++17\n\n# Rule for compiling the C++ files\nrule cxx_compile\n  command = $cxx $cflags -c $in -o $out\n\n# Build statements for the source files\nbuild main.o: cxx_compile main.cpp\nbuild foo.o: cxx_compile foo.cpp\n\n# Rule for linking the object files\nrule link\n  command = $cxx $in -o $out\n\n# Build statement for the final executable\nbuild my_program: link main.o foo.o\n\n```cpp\n\nĐể xây dựng dự án bằng tệp build.ninja này, chỉ cần chạy ninja trong thiết bị đầu cuối:\n\n```\n$ ninja\n\n```cpp\n\nThao tác này sẽ xây dựng tệp thực thi my_program bằng cách trước tiên biên dịch các tệp main.cpp và foo.cpp thành các tệp đối tượng, sau đó liên kết chúng lại với nhau."
                }
            ]
        },
        {
            "title": "Chương 18 Đóng gói",
            "param": "chap-17-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " Trình quản lý gói",
                    "param": "chap-17-0",
                    "level": "beginner",
                    "code": "# Trình quản lý gói\nTrình quản lý gói là công cụ tự động hóa quy trình cài đặt, nâng cấp và quản lý phần mềm (thư viện, khung và các thành phần phụ thuộc khác) cho một ngôn ngữ lập trình, chẳng hạn như C++.\n\nMột số trình quản lý gói phổ biến được sử dụng trong hệ sinh thái C++ bao gồm:\n- Conan\n- vcpkg\n- Mạng lưu trữ C++ (cppan)\n\n## Conan\n**Conan** là trình quản lý gói đa nền tảng, phi tập trung hóa, mã nguồn mở dành cho các nhà phát triển C và C++. Nó đơn giản hóa việc quản lý các phụ thuộc và sử dụng lại mã code, mang lại lợi ích cho các dự án phát triển đa nền tảng.\n\nVí dụ cài đặt thư viện bằng Conan:\n\n```\nconan install poco/1.9.4@\n\n```cpp\n\n\n## vcpkg\n**vcpkg** là trình quản lý gói đa nền tảng được tạo bởi Microsoft. Đây là một hệ thống quản lý thư viện mã nguồn mở dành cho các nhà phát triển C++ để xây dựng và quản lý các dự án của họ.\n\nVí dụ, cài đặt gói bằng vcpkg:\n\n```\n./vcpkg install boost:x64-windows\n\n```cpp\n\n\n## Mạng lưu trữ C++ (cppan)\n**cppan** là trình quản lý gói và kho lưu trữ phần mềm dành cho các nhà phát triển C++, giúp đơn giản hóa quá trình quản lý và phân phối các thư viện và công cụ C++. Nó hiện là một phần của **build2**, một chuỗi công cụ xây dựng cung cấp trình quản lý gói.\n\nMột ví dụ về tệp cppan.yml:\n\n```\n#\n# cppan.yml\n#\n\nproject:\n  api_version: 1\n\n  depend:\n    - pvt.cppan.demo.sqlite3\n    - pvt.cppan.demo.xz_utils.lzma\n\n```cpp\n\nVới các trình quản lý gói này, bạn có thể hợp lý hóa quy trình phát triển của mình và dễ dàng quản lý các phần phụ thuộc trong các dự án C++ của mình. Ngoài ra, bạn có thể dễ dàng sử dụng lại mã code trong các dự án của mình để cải thiện chất lượng code và tăng tốc độ phát triển."
                },
                {
                    "author": "Dev Alex",
                    "title": " vcpkg",
                    "param": "chap-17-1",
                    "level": "beginner",
                    "code": "# vcpkg\nvcpkg là trình quản lý gói mã nguồn mở, đa nền tảng cho các thư viện C và C++. Được phát triển bởi Microsoft, nó đơn giản hóa quá trình thu thập và xây dựng các thư viện nguồn mở cho các dự án của bạn. vcpkg hỗ trợ nhiều nền tảng khác nhau bao gồm Windows, Linux và macOS, cho phép bạn dễ dàng quản lý và tích hợp các thư viện bên ngoài vào các dự án của mình.\n\n## Cài đặt\nĐể cài đặt vcpkg, hãy làm theo các bước sau:\n- Sao chép kho lưu trữ:\n  \n```\n  git clone https://github.com/Microsoft/vcpkg.git\n  \n```cpp\n\n- Thay đổi thư mục vcpkg và chạy tập lệnh bootstrap:\n  - Trên Windows:\n    \n```\n    .\\bootstrap-vcpkg.bat\n    \n```cpp\n\n  - Trên Linux/macOS:\n    \n```\n    ./bootstrap-vcpkg.sh\n    \n```cpp\n\n- (Tùy chọn) Thêm tệp thực thi vcpkg vào biến môi trường PATH của bạn để dễ dàng truy cập.\n\n## Sử dụng cơ bản\nDưới đây là một số ví dụ cơ bản về việc sử dụng vcpkg:\n- Tìm kiếm một gói:\n  \n```\n  vcpkg search <package_name>\n  \n```cpp\n\n- Cài đặt một gói:\n  \n```\n  vcpkg install <package_name>\n  \n```cpp\n\n- Loại bỏ một gói:\n  \n```\n  vcpkg remove <package_name>\n  \n```cpp\n\n- Liệt kê các gói đã cài đặt:\n  \n```\n  vcpkg list\n  \n```cpp\n\n- Tích hợp vcpkg với Visual Studio (chỉ dành cho Windows):\n  \n```\n  vcpkg integrate install\n  \n```cpp\n\nĐể có tài liệu bổ sung và cách sử dụng nâng cao, bạn có thể tham khảo **kho lưu trữ GitHub chính thức**."
                },
                {
                    "author": "Dev Alex",
                    "title": " Spack",
                    "param": "chap-17-2",
                    "level": "beginner",
                    "code": "# Spack\n**Spack** là trình quản lý gói linh hoạt được thiết kế để hỗ trợ nhiều phiên bản, cấu hình, nền tảng và trình biên dịch. Nó đặc biệt hữu ích trong môi trường Điện toán hiệu năng cao (HPC) và cho những người cần kiểm soát tốt ngăn xếp phần mềm của họ. Spack là một lựa chọn phổ biến trong điện toán khoa học do hỗ trợ cho nhiều nền tảng khác nhau như Linux, macOS và nhiều siêu máy tính. Nó được thiết kế để tự động tìm kiếm và cài đặt các phụ thuộc, giúp dễ dàng xây dựng phần mềm phức tạp.\n\n## Các tính năng chính\n- **Hỗ trợ nhiều phiên bản:** Spack cho phép cài đặt nhiều phiên bản gói, cho phép người dùng làm việc với các cấu hình khác nhau tùy theo nhu cầu của họ.\n- **Hỗ trợ trình biên dịch:** Spack hỗ trợ nhiều trình biên dịch, bao gồm GCC, Clang, Intel, PGI và các trình biên dịch khác, cho phép người dùng chọn chuỗi công cụ tốt nhất cho ứng dụng của họ.\n- **Hỗ trợ nền tảng:** Spack có thể chạy trên Linux, macOS và nhiều siêu máy tính khác nhau và thậm chí nó có thể nhắm mục tiêu nhiều kiến trúc trong một gói duy nhất.\n- **Phần phụ thuộc:** Spack đảm nhận phần phụ thuộc, cung cấp cài đặt và quản lý tự động các gói cần thiết.\n\n## Sử dụng cơ bản\n- Để cài đặt Spack, hãy sao chép kho lưu trữ Git của nó và thiết lập môi trường của bạn:\n  \n```\n  git clone https://github.com/spack/spack.git\n  cd spack\n  . share/spack/setup-env.sh\n  \n```cpp\n\n- Cài đặt gói bằng Spack:\n  \n```\n  spack install <package-name>\n  \n```cpp\n\n  Ví dụ: để cài đặt hdf5:\n  \n```\n  spack install hdf5\n  \n```cpp\n\n- Tải một gói trong môi trường của bạn:\n  \n```\n  spack load <package-name>\n  \n```cpp\n\n  Ví dụ: để tải hdf5:\n  \n```\n  spack load hdf5\n  \n```cpp\n\n- Liệt kê các gói đã cài đặt:\n  \n```\n  spack find\n  \n```cpp\n\n- Gỡ cài đặt một gói:\n  \n```\n  spack uninstall <package-name>\n  \n```cpp\n\nĐể sử dụng nâng cao hơn, chẳng hạn như cài đặt các phiên bản cụ thể hoặc sử dụng các trình biên dịch khác nhau, hãy tham khảo **tài liệu Spack**."
                },
                {
                    "author": "Dev Alex",
                    "title": " Conan",
                    "param": "chap-17-3",
                    "level": "beginner",
                    "code": "# Conan\n**Conan** là trình quản lý gói phổ biến dành cho ngôn ngữ C và C++ và được thiết kế đa nền tảng, có thể mở rộng và dễ sử dụng. Nó cho phép các nhà phát triển khai báo, quản lý và tìm nạp các phụ thuộc trong khi tự động hóa quá trình xây dựng. Conan hỗ trợ nhiều hệ thống xây dựng khác nhau, chẳng hạn như CMake, Visual Studio, MSBuild, v.v.\n\n## Cài đặt\nĐể cài đặt Conan, bạn có thể sử dụng pip, trình quản lý gói Python:\n\n```\npip install conan\n\n```cpp\n\n\n## Sử dụng cơ bản\n- Tạo tệp conanfile.txt trong thư mục gốc dự án của bạn, chỉ định các phụ thuộc bạn cần cho dự án của mình:\n\n```\n[requires]\nboost/1.75.0\n\n[generators]\ncmake\n\n```cpp\n\n- Chạy lệnh conan install để tìm nạp và xây dựng các phụ thuộc cần thiết:\n\n```\nmkdir build && cd build\nconan install ..\n\n```cpp\n\n- Bây giờ hãy xây dựng dự án của bạn bằng hệ thống xây dựng của bạn, ví dụ CMake:\n\n```\ncmake .. -DCMAKE_BUILD_TYPE=Release\ncmake --build .\n\n```cpp\n\n\n## Tạo gói\nĐể tạo một gói trong Conan, bạn cần viết tệp conanfile.py với thông tin gói và hướng dẫn xây dựng.\n\nĐây là một ví dụ:\n\n```\nfrom conans import ConanFile, CMake\n\nclass MyLibraryConan(ConanFile):\n    name = \"MyLibrary\"\n    version = \"0.1\"\n    license = \"MIT\"\n    url = \"https://github.com/username/mylibrary\"\n    description = \"A simple example library\"\n    settings = \"os\", \"compiler\", \"build_type\", \"arch\"\n    generators = \"cmake\"\n\n    def build(self):\n        cmake = CMake(self)\n        cmake.configure(source_folder=\"src\")\n        cmake.build()\n\n    def package(self):\n        self.copy(\"*.hpp\", dst=\"include\", src=\"src/include\")\n        self.copy(\"*.lib\", dst=\"lib\", keep_path=False)\n        self.copy(\"*.dll\", dst=\"bin\", keep_path=False)\n        self.copy(\"*.so\", dst=\"lib\", keep_path=False)\n        self.copy(\"*.a\", dst=\"lib\", keep_path=False)\n\n    def package_info(self):\n        self.cpp_info.libs = [\"MyLibrary\"]\n\n```cpp\n\nVới thiết lập đó, bạn có thể tạo một gói bằng cách chạy:\n\n```\nconan create . username/channel\n\n```cpp\n\nĐiều này sẽ biên dịch gói và lưu trữ nó trong bộ đệm Conan của bạn. Bây giờ bạn có thể sử dụng gói này làm phụ thuộc trong các dự án khác."
                },
                {
                    "author": "Dev Alex",
                    "title": " NuGet",
                    "param": "chap-17-4",
                    "level": "beginner",
                    "code": "# NuGet\n**NuGet** là trình quản lý gói được Microsoft hỗ trợ cho .NET framework, chủ yếu được sử dụng trong C# và các ngôn ngữ .NET khác, nhưng cũng hỗ trợ các dự án C++ với PackageReference. Nó cho phép bạn dễ dàng thêm, cập nhật và quản lý các phụ thuộc trong dự án của mình.\n\n## Cài đặt\nBạn có thể sử dụng NuGet dưới dạng công cụ dòng lệnh hoặc được tích hợp trong IDE ưa thích của mình như Visual Studio hoặc Visual Studio Code. Nếu bạn đang sử dụng Visual Studio, thì nó đã được cài đặt sẵn. Đối với các trình soạn thảo khác, bạn có thể cần tải xuống công cụ dòng lệnh nuget.exe.\n\n## Sử dụng\nBạn có thể sử dụng NuGet để quản lý các phụ thuộc C++ của mình bằng cách sử dụng định dạng PackageReference trong tệp vcxproj:\n- Công cụ > Trình quản lý gói NuGet > Quản lý gói NuGet cho giải pháp…\n- Nguồn gói phải được đặt thành “nuget.org”\n- Chọn tab Projects\n- Sử dụng hộp tìm kiếm để tìm các gói\nVí dụ: để cài đặt gói có tên “PackageName” cho tất cả các cấu hình:\n\n```\n<Project>\n  <ItemGroup>\n    <PackageReference Include=\"PackageName\" Version=\"1.0.0\" />\n  </ItemGroup>\n  ...\n</Project>\n\n```cpp\n\n\n## Dòng lệnh NuGet\nBạn cũng có thể sử dụng công cụ dòng lệnh nuget.exe cho các tình huống nâng cao hơn hoặc cho các nhu cầu cụ thể.\n\nĐây là một ví dụ về cách cài đặt gói bằng dòng lệnh:\n\n```\nnuget install PackageName\n\n```cpp\n\nVà cập nhật một gói:\n\n```\nnuget update PackageName\n\n```cpp\n\nĐể biết thêm thông tin và ví dụ chi tiết về cách sử dụng NuGet trong dự án của bạn, vui lòng tham khảo **tài liệu chính thức**."
                }
            ]
        },
        {
            "title": "Chương 19 Làm việc với thư viện",
            "param": "chap-18-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " Làm việc với Thư viện trong C++",
                    "param": "chap-18-0",
                    "level": "beginner",
                    "code": "# Làm việc với Thư viện trong C++\nKhi làm việc với C++, bạn có thể cần sử dụng các thư viện bên ngoài để hỗ trợ các tác vụ khác nhau. Thư viện là các đoạn mã code được biên dịch trước có thể được sử dụng lại trong chương trình của bạn để thực hiện một tác vụ cụ thể hoặc cung cấp một chức năng nhất định. Trong C++, thư viện có thể là thư viện tĩnh (.lib) hoặc thư viện động (.dll trong Windows, .so trong Unix/Linux).\n\n## 1. Thư viện tĩnh\nCác thư viện tĩnh được tích hợp vào chương trình của bạn trong thời gian biên dịch. Chúng được liên kết với mã code của bạn, tạo ra một tệp thực thi lớn hơn, nhưng nó không yêu cầu bất kỳ tệp bên ngoài nào trong thời gian chạy.\n\nĐể tạo một thư viện tĩnh, bạn cần biên dịch các tệp nguồn của mình thành các tệp đối tượng, sau đó nhóm chúng vào một kho lưu trữ. Bạn có thể sử dụng các lệnh sau:\n\n```\ng++ -c sourcefile.cpp -o objectfile.o\nar rcs libmystaticlibrary.a objectfile.o\n\n```cpp\n\nĐể sử dụng thư viện tĩnh, bạn cần đưa các tệp tiêu đề vào mã nguồn của mình, sau đó liên kết thư viện trong quá trình biên dịch:\n\n```\ng++ main.cpp -o myprogram -L/path/to/your/library/ -lmystaticlibrary\n\n```cpp\n\nThay thế /path/to/your/library/ bằng đường dẫn chứa tệp libmystaticlibrary.a của bạn.\n\n## 2. Thư viện động\nCác thư viện động được tải trong thời gian chạy, điều đó có nghĩa là tệp thực thi của bạn chỉ chứa các tham chiếu đến các thư viện này. Các thư viện cần phải có sẵn trên hệ thống mà chương trình của bạn đang chạy.\n\nĐể tạo thư viện động, bạn cần biên dịch tệp nguồn của mình thành tệp đối tượng, sau đó tạo thư viện dùng chung:\n\n```\ng++ -c -fPIC sourcefile.cpp -o objectfile.o\ng++ -shared -o libmydynamiclibrary.so objectfile.o\n\n```cpp\n\nĐể sử dụng thư viện động, hãy đưa các tệp tiêu đề của thư viện vào mã nguồn của bạn rồi liên kết thư viện trong quá trình biên dịch:\n\n```\ng++ main.cpp -o myprogram -L/path/to/your/library/ -lmydynamiclibrary\n\n```cpp\n\nThay thế /path/to/your/library/ bằng đường dẫn chứa tệp libmydynamiclibrary.so của bạn.\n\n**LƯU Ý:** Khi sử dụng thư viện động, hãy đảm bảo rằng thư viện nằm trong đường dẫn tìm kiếm thư viện dùng chung của hệ thống. Bạn có thể cần cập nhật biến môi trường LD_LIBRARY_PATH trên hệ thống Unix/Linux hoặc biến PATH trên Windows.\n\nTóm lại, việc sử dụng các thư viện trong C++ liên quan đến việc tạo hoặc lấy một thư viện (tĩnh hoặc động), bao gồm các tệp tiêu đề của thư viện trong mã nguồn của bạn và liên kết thư viện trong quá trình biên dịch. Hãy nhận biết sự khác biệt giữa các thư viện tĩnh và động và chọn cách tiếp cận phù hợp với nhu cầu của bạn."
                },
                {
                    "author": "Dev Alex",
                    "title": " Chỉ thị bao hàm (include) trong C++",
                    "param": "chap-18-1",
                    "level": "beginner",
                    "code": "# Chỉ thị bao hàm (include) trong C++\nTrong lập trình C++, bao hàm đề cập đến việc kết hợp các thư viện bên ngoài, tệp tiêu đề hoặc tệp mã code khác vào chương trình của bạn. Quá trình này cho phép các nhà phát triển truy cập các hàm, lớp và khai báo biến dựng sẵn có thể được sử dụng trong mã code của riêng họ. Có hai loại bao hàm trong C++:\n- Chỉ thị bao hàm tiêu đề\n- Chỉ thị bao hàm nguồn\n\n## Chỉ thị bao hàm tiêu đề\nChỉ thị bao hàm tiêu đề liên quan đến việc thêm các tệp tiêu đề bằng cách sử dụng chỉ thị tiền xử lý #include. Các tệp tiêu đề thường được sử dụng để cung cấp các nguyên mẫu hàm, khai báo lớp và định nghĩa hằng số có thể được chia sẻ trên nhiều tệp nguồn. Có hai cách để bao hàm các tệp tiêu đề trong chương trình của bạn:\n- Dấu ngoặc nhọn <>: Được sử dụng để thêm các tiêu đề thư viện chuẩn, như iostream, vector hoặc algorithm.\n\nVí dụ:\n\n```\n#include <iostream>\n#include <vector>\n\n```cpp\n\n- Dấu ngoặc kép \"\": Được sử dụng để thêm tiêu đề do người dùng xác định hoặc tiêu đề do thư viện bên thứ ba cung cấp.\n\nVí dụ:\n\n```\n#include \"myHeader.h\"\n#include \"thirdPartyLibrary.h\"\n\n```cpp\n\n\n## Chỉ thị bao hàm nguồn\nChỉ thị bao hàm nguồn đề cập đến việc đưa trực tiếp nội dung của tệp nguồn vào một tệp nguồn khác. Cách tiếp cận này thường không được khuyến nghị vì nó có thể dẫn đến nhiều định nghĩa và tăng thời gian biên dịch nhưng đôi khi nó có thể hữu ích cho một số tác vụ nhất định (ví dụ: mẫu hoặc chương trình nhỏ đơn giản). Để thêm tệp nguồn, bạn có thể sử dụng chỉ thị #include với dấu ngoặc kép, giống như với tệp tiêu đề:\n\nVí dụ:\n\n```\n#include \"mySourceFile.cpp\"\n\n```cpp\n\nHãy nhớ rằng việc sử dụng tính năng bao hàm nguồn cho các dự án lớn hoặc trong các tình huống không cần thiết có thể dẫn đến các sự cố không mong muốn và nên tránh."
                },
                {
                    "author": "Dev Alex",
                    "title": " Giấy phép trong C++",
                    "param": "chap-18-2",
                    "level": "beginner",
                    "code": "# Giấy phép trong C++\nGiấy phép là một khía cạnh quan trọng khi làm việc với các thư viện trong C++ vì nó xác định các quyền và hạn chế về cách bạn có thể sử dụng, sửa đổi và phân phối một thư viện nhất định. Có nhiều loại cấp phép khác nhau được áp dụng cho các thư viện mã nguồn mở. Dưới đây là tổng quan ngắn gọn về ba giấy phép phổ biến:\n\n## Giấy phép MIT\nGiấy phép MIT là giấy phép đơn giản cho phép người dùng làm bất cứ điều gì họ muốn với mã code phần mềm. Họ chỉ cần thêm bản quyền gốc, thông báo giấy phép và một từ chối bảo hành trong các bản sao của họ.\n\nVí dụ: Việc đưa Giấy phép MIT vào dự án của bạn có thể được thực hiện bằng cách chỉ cần thêm tệp giấy phép và thông báo ở đầu tệp mã nguồn của bạn như sau:\n\n```\n/* Copyright (C) [year] [author]\n * SPDX-License-Identifier:    MIT\n */\n\n```cpp\n\n\n## Giấy phép phần mềm GNU (GPL)\nGPL là giấy phép copyleft cấp cho người dùng quyền sử dụng, nghiên cứu, chia sẻ và sửa đổi mã code phần mềm. Tuy nhiên, bất kỳ thay đổi nào được thực hiện đối với mã hoặc bất kỳ phần mềm nào sử dụng mã được cấp phép GPL cũng phải được phân phối theo giấy phép GPL.\n\nVí dụ: Để bao gồm giấy phép GPL trong dự án của bạn, hãy bao hàm tệp COPYING với toàn bộ văn bản giấy phép và đặt thông báo trong tệp mã nguồn của bạn như sau:\n\n```\n/* Copyright (C) [year] [author]\n * SPDX-License-Identifier:    GPL-3.0-or-later\n */\n\n```cpp\n\n\n## Giấy phép Apache 2.0\nGiấy phép Apache là giấy phép tương tự như MIT và cho phép người dùng thực hiện hầu như mọi thứ với mã code phần mềm. Sự khác biệt chính là nó yêu cầu mọi thay đổi đối với mã phải được ghi lại và nó cung cấp các điều khoản cụ thể để bảo vệ bằng sáng chế.\n\nVí dụ: Để bao hàm Giấy phép Apache trong dự án của bạn, hãy thêm tệp LICENSE với  bộ văn bản giấy phép. Thêm thông báo vào tệp mã nguồn của bạn như sau:\n\n```\n/* Copyright (C) [year] [author]\n * SPDX-License-Identifier:    Apache-2.0\n */\n\n```cpp\n\nXin lưu ý rằng đây là những bản tóm tắt ngắn gọn về các giấy phép và có nhiều giấy phép khác có sẵn để sử dụng trong các dự án phần mềm. Khi sử dụng các thư viện của bên thứ ba, điều quan trọng là phải hiểu và tuân thủ các điều khoản trong giấy phép tương ứng của họ để tránh các rắc rối pháp lý."
                }
            ]
        },
        {
            "title": "Chương 20 Thư viện mở rộng",
            "param": "chap-19-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " Tăng hiệu năng thư viện C++",
                    "param": "chap-19-0",
                    "level": "beginner",
                    "code": "# Tăng hiệu năng thư viện C++\nBoost (tăng hiệu năng) là tập hợp các thư viện C++ chất lượng cao và được sử dụng rộng rãi, được thiết kế để giúp các nhà phát triển viết mã di động và hiệu quả. Chúng là mô-đun và có thể được đưa vào dự án của bạn khi cần. Các thư viện Boost cung cấp nhiều chức năng khác nhau, bao gồm hỗ trợ song song, đa luồng, quản lý bộ nhớ, thao tác chuỗi và cấu trúc dữ liệu nâng cao.\n\n## Thành phần đáng chú ý\nDưới đây là danh sách một số thư viện Boost phổ biến:\n- **Boost.Asio:** Cung cấp các dịch vụ mạng và I/O cấp thấp.\n- **Boost.Bimap:** Cấu trúc dữ liệu bản đồ hai chiều.\n- **Boost.Filesystem:** Cung cấp các hoạt động của hệ thống tệp di động.\n- **Boost.Graph:** Triển khai các thuật toán đồ thị và cấu trúc dữ liệu khác nhau.\n- **Boost.Multithreading:** Cung cấp các công cụ đa luồng, đồng bộ hóa và quản lý luồng.\n\n## Cách sử dụng\n- Đầu tiên, tải xuống và cài đặt các thư viện Boost theo tài liệu.\n- Sau khi cài đặt, hãy bao hàm các tiêu đề cần thiết trong mã code C++ của bạn và bắt đầu sử dụng tiện ích Boost.\n\nĐây là một ví dụ sử dụng boost::filesystem (LƯU Ý: Boost.Filesystem hiện là một phần của thư viện chuẩn C++17):\n\n```\n#include <iostream>\n#include <boost/filesystem.hpp>\n\nint main() {\n    boost::filesystem::path path(\"directory_path\");\n  \n    if (boost::filesystem::exists(path)) {\n        std::cout << \"Path: \" << path << \" exists!\" << std::endl;\n      \n        if (boost::filesystem::is_directory(path)) {\n            std::cout << \"Path: \" << path << \" is a directory.\" << std::endl;\n        } else if (boost::filesystem::is_regular_file(path)) {\n            std::cout << \"Path: \" << path << \" is a regular file.\" << std::endl;\n        }\n    } else {\n        std::cout << \"Path: \" << path << \" does not exist!\" << std::endl;\n    }\n\n    return 0;\n}\n\n```cpp\n\nĐể có hướng dẫn chi tiết hơn, hãy tham khảo **tài liệu Boost chính thức**."
                },
                {
                    "author": "Dev Alex",
                    "title": " OpenCV",
                    "param": "chap-19-1",
                    "level": "beginner",
                    "code": "# OpenCV\n**OpenCV (Open Source Computer Vision Library)** là một thư viện phần mềm thị giác máy tính và học máy mã nguồn mở. Nó được xây dựng để cung cấp cơ sở hạ tầng chung cho các ứng dụng thị giác máy tính và đẩy nhanh việc sử dụng nhận thức máy móc trong các sản phẩm thương mại. OpenCV chứa hơn 2.500 thuật toán được tối ưu hóa cho thị giác máy tính thời gian thực và được sử dụng tích cực bởi một cộng đồng lớn gồm các lập trình viên, nhà nghiên cứu và các ngành công nghiệp trên toàn thế giới.\n\nThư viện có các giao diện cho C++, Python, Java và MATLAB/Octave và được sử dụng rộng rãi trong các lĩnh vực thị giác máy tính khác nhau, chẳng hạn như:\n- Xử lý hình ảnh 2D và 3D\n- Nhận dạng khuôn mặt và phát hiện khuôn mặt\n- Phát hiện và nhận dạng đối tượng\n- Học máy\n\nĐây là một ví dụ đơn giản sử dụng OpenCV trong C++ để đọc và hiển thị một hình ảnh:\n\nĐiều kiện tiên quyết: Cài đặt OpenCV cho C++ trên hệ thống của bạn (ví dụ: bằng cách làm theo hướng dẫn cài đặt chính thức).\n\n```\n#include <opencv2/opencv.hpp>\n#include <opencv2/highgui/highgui.hpp>\n#include <iostream>\n\nint main(int argc, char** argv) {\n    if(argc != 2) {\n        std::cout << \"Usage: display_image ImageToLoadAndDisplay\" << std::endl;\n        return -1;\n    }\n\n    cv::Mat image;\n    image = cv::imread(argv[1], cv::IMREAD_COLOR);\n\n    if(!image.data) {\n        std::cout << \"Could not open or find the image\" << std::endl;\n        return -1;\n    }\n\n    cv::namedWindow(\"Display window\", cv::WINDOW_AUTOSIZE);\n    cv::imshow(\"Display window\", image);\n    cv::waitKey(0);\n\n    return 0;\n}\n\n```cpp\n\nVí dụ này đọc một hình ảnh từ đường dẫn đầu vào đã cho (argv[1]) và hiển thị nó trong một cửa sổ. Hàm cv::imread() được sử dụng để đọc hình ảnh và hàm cv::imshow() hiển thị hình ảnh đó trong cửa sổ đã tạo.\n\nNhớ biên dịch mã code, liên kết các thư viện cần thiết:\n\n```\ng++ -o display_image display_image.cpp `pkg-config --cflags --libs opencv4`\n\n```cpp\n\nVà chạy tệp thực thi với đường dẫn hình ảnh làm đối số:\n\n```\n./display_image path/to/image.jpg\n\n```cpp\n\nĐể biết thêm các ví dụ nâng cao và tài liệu chi tiết về cách sử dụng OpenCV, vui lòng truy cập tài liệu OpenCV chính thức."
                },
                {
                    "author": "Dev Alex",
                    "title": " Ranges v3",
                    "param": "chap-19-10",
                    "level": "beginner",
                    "code": "# Ranges v3\nRanges v3 là một thư viện C++ được thiết kế để hoạt động với các phạm vi giá trị, thay vì các giá trị riêng lẻ. Nó cung cấp một tập hợp các tiện ích và thuật toán để thao tác và chuyển đổi các phạm vi giá trị một cách hiệu quả và biểu cảm. Thư viện được lấy cảm hứng từ khái niệm Range được đề xuất để đưa vào thư viện chuẩn C++ cho C++20.\n\n## Tổng quan\nRanges v3 bao gồm ba thành phần chính:\n- **Bộ điều hợp phạm vi:** Đây là các thuật toán có thể kết hợp để chuyển đổi một phạm vi thành một phạm vi mới. Chúng giúp tạo các chế độ xem lười biếng trên dữ liệu mà không thực sự sửa đổi nó.\n- **Bộ điều hợp hành động:** Đây là những thuật toán sửa đổi phạm vi tại chỗ. Ví dụ: sắp xếp hoặc lọc trực tiếp các phần tử trong vùng chứa.\n- **Bộ điều hợp hành động:** Đây là những thuật toán sửa đổi phạm vi tại chỗ. Ví dụ: sắp xếp hoặc lọc trực tiếp các phần tử trong vùng chứa.\n\n## Ví dụ mã code\nDưới đây là một số ví dụ về mã sử dụng thư viện Ranges v3:\n\n### Bao hàm thư viện\nTrước tiên, bạn cần bao hàm các tệp tiêu đề thích hợp từ thư viện. Để sử dụng toàn bộ thư viện Ranges v3, bạn chỉ cần thêm tệp tiêu đề range/v3/all.hpp:\n\n```\n#include <range/v3/all.hpp>\n\n```cpp\n\n\n### Sử dụng bộ điều hợp phạm vi\nBạn có thể sử dụng bộ điều hợp phạm vi để thao tác và chuyển đổi phạm vi. Ví dụ: bạn có thể sử dụng bộ điều hợp view::filter và view::transform để tạo một dải ô mới chỉ chứa các số chẵn rồi bình phương chúng:\n\n```\n#include <iostream>\n#include <range/v3/all.hpp>\n\nusing namespace ranges;\n\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5, 6};\n\n    // Tạo một phạm vi mới chỉ chứa các số chẵn, rồi bình phương chúng.\n    auto even_squares = numbers | view::filter([](int n) { return n % 2 == 0; })\n                                 | view::transform([](int n) { return n * n; });\n\n    // In phạm vi even_squares.\n    for (auto n : even_squares) {\n        std::cout << n << ' ';\n    }\n    // Đầu ra: 4 16 36\n\n    return 0;\n}\n\n```cpp\n\n\n### Sử dụng bộ điều hợp hành động\nBộ điều hợp hành động được sử dụng để sửa đổi phạm vi tại chỗ. Ví dụ: bạn có thể sử dụng bộ điều hợp action::sort và action::unique để sắp xếp và xóa các phần tử trùng lặp khỏi bộ lưu trữ:\n\n```\n#include <iostream>\n#include <range/v3/all.hpp>\n\nusing namespace ranges;\n\nint main() {\n    std::vector<int> numbers = {5, 3, 1, 4, 4, 2, 2};\n\n    // Sắp xếp các số và loại bỏ các số trùng lặp.\n    numbers |= action::sort | action::unique;\n\n    // In vecto số đã sửa đổi.\n    for (auto n : numbers) {\n        std::cout << n << ' ';\n    }\n    // Đầu ra: 1 2 3 4 5\n\n    return 0;\n}\n\n```cpp\n\nRanges v3 cung cấp nhiều loại bộ điều hợp và hành động để làm việc với các phạm vi theo cách biểu cảm và hiệu quả hơn. Bạn có thể khám phá thêm trong **tài liệu chính thức**."
                },
                {
                    "author": "Dev Alex",
                    "title": " Poco",
                    "param": "chap-19-2",
                    "level": "beginner",
                    "code": "# Poco\nPoco (còn được gọi là Thư viện POCO C++) là một tập hợp các thư viện lớp nguồn mở, giúp đơn giản hóa việc tạo phần mềm tập trung vào mạng, di động và có thể bảo trì trong C++.\n\n## Tổng quan\nThư viện Poco cung cấp chức năng cho nhiều lĩnh vực khác nhau, chẳng hạn như:\n- Kết nối mạng: HTTP, FTP, SMTP, POP3 và các giao thức internet khác\n- Xử lý tệp: Các lớp FileSystem, Path, File và Directory\n- Xử lý XML: Phân tích cú pháp XML và thao tác DOM\n- Ghi nhật ký: Trình ghi nhật ký, cấp độ, kênh, mẫu, v.v.\n- Thao tác dữ liệu: Stream, ByteBuffer, Buffer, v.v.\n- Đa luồng và đồng bộ hóa: Luồng, Mutex, Sự kiện và Điều kiện\n\n## Mã code ví dụ\nĐây là một ví dụ minh họa một máy khách HTTP sử dụng thư viện Poco:\n\n```\n#include <Poco/Net/HTTPClientSession.h>\n#include <Poco/Net/HTTPRequest.h>\n#include <Poco/Net/HTTPResponse.h>\n#include <Poco/Net/HTTPMessage.h>\n#include <Poco/StreamCopier.h>\n#include <iostream>\n#include <string>\n\nusing namespace Poco::Net;\nusing namespace Poco;\nusing namespace std;\n\nint main()\n{\n  try\n  {\n    // Chuẩn bị yêu cầu\n    URI uri(\"http://example.com\");\n    HTTPClientSession session(uri.getHost(), uri.getPort());\n\n    HTTPRequest request(HTTPRequest::HTTP_GET, uri.getPath(), HTTPMessage::HTTP_1_1);\n    request.setContentType(\"application/json\");\n\n    session.sendRequest(request);\n\n    // Xử lý phản hồi\n    HTTPResponse response;\n    istream& responseStream = session.receiveResponse(response);\n    if (response.getStatus() == HTTPResponse::HTTP_OK)\n    {\n      // Thành công\n      StreamCopier::copyToString(responseStream, responseBody);\n      cout << \"Response: \" << responseBody << endl;\n    }\n    else\n    {\n      // Lỗi\n      cout << \"Error: \" << response.getStatus() << \" \" << response.getReason() << endl;\n    }\n  }\n  catch(const Exception& e)\n  {\n    cerr << \"Error: \" << e.displayText() << endl;\n    return -1;\n  }\n\n  return 0;\n}\n\n```cpp\n\nTrong ví dụ trên, Poco được sử dụng để gửi yêu cầu HTTP GET và xử lý phản hồi. Nó quản lý các tác vụ như kết nối với máy chủ, xử lý ngoại lệ và quản lý tiêu đề HTTP.\n- **Official Docs for Poco Library**"
                },
                {
                    "author": "Dev Alex",
                    "title": " Bộ đệm giao thức (protobuf)",
                    "param": "chap-19-3",
                    "level": "beginner",
                    "code": "# Bộ đệm giao thức (protobuf)\nBộ đệm giao thức, hay protobuf, là định dạng tuần tự hóa dữ liệu trung lập với ngôn ngữ và nền tảng do Google phát triển. Nó được sử dụng để tuần tự hóa dữ liệu có cấu trúc một cách hiệu quả để sử dụng trong các giao thức truyền thông, lưu trữ dữ liệu, v.v. Nó có thể mở rộng, vì nó cho phép bạn xác định cấu trúc dữ liệu tùy chỉnh của riêng mình được gọi là “thông báo” với các loại trường vô hướng và phức tạp khác nhau.\n\nDưới đây là một bản tóm tắt ngắn gọn về protobuf và cách sử dụng nó trong C++:\n- **Xác định tệp `.proto` của bạn:** Tạo tệp .proto xác định cấu trúc thông báo của bạn.\n\nVí dụ:\n\n```\nsyntax = \"proto3\";\n\nmessage Person {\n    string name = 1;\n    int32 age = 2;\n    string email = 3;\n}\n\n```cpp\n\n- ***Biên dịch tệp `.proto`:** Bạn cần biên dịch tệp .proto của mình để tạo các lớp C++ cho tuần tự hóa và giải tuần tự hóa.\n\n  Ví dụ:\n  \n```\n  protoc --cpp_out=. person.proto\n  \n```cpp\n\n  Thao tác này sẽ tạo ra hai tệp: person.pb.cc và person.pb.h chứa các định nghĩa lớp C++.\n- **Đưa thư viện protobuf và các tệp được tạo vào mã code C++ của bạn:** Bạn sẽ cần đưa thư viện protobuf và các tệp được tạo vào mã code C++ chính của mình.\n\n  Ví dụ:\n  \n```\n  #include <iostream>\n  #include <fstream>\n  #include \"person.pb.h\"\n\n  int main () {\n      GOOGLE_PROTOBUF_VERIFY_VERSION; // Xác minh rằng tiêu đề thư viện protobuf phù hợp với phiên bản thư viện\n\n      // Tuần tự hóa một thông báo Person\n      Person person;\n      person.set_name(\"Sam\");\n      person.set_age(35);\n      person.set_email(\"sam@example.com\");\n\n      // Lưu dữ liệu vào một tập tin\n      std::ofstream output(\"person.bin\", ios::binary);\n      person.SerializeToOstream(&output);\n      output.close();\n\n      // Giải tuần tự hóa thông báo từ tập tin\n      Person input_person;\n      std::ifstream input(\"person.bin\", ios::binary);\n      input_person.ParseFromIstream(&input);\n      input.close();\n\n      // In thông báo đã giải tuần tự hóa\n      std::cout << \"Name: \" << input_person.name() << std::endl;\n      std::cout << \"Age: \" << input_person.age() << std::endl;\n      std::cout << \"Email: \" << input_person.email() << std::endl;\n\n      google::protobuf::ShutdownProtobufLibrary();\n\n      return 0;\n  }\n  \n```cpp\n\n- **Biên dịch và liên kết mã code C++ của bạn:** Cuối cùng, biên dịch mã code C++ của bạn và liên kết nó với thư viện protobuf.\n\n  Ví dụ:\n  \n```\n  g++ -std=c++11 -o main main.cpp person.pb.cc -lprotobuf\n  \n```cpp\n\nĐể biết thêm thông tin và ví dụ, bạn có thể tham khảo **hướng dẫn chính thức của protobuf C++**."
                },
                {
                    "author": "Dev Alex",
                    "title": " gRPC",
                    "param": "chap-19-4",
                    "level": "beginner",
                    "code": "# gRPC\ngRPC (Các cuộc gọi thủ tục từ xa gRPC) là một khung công tác gọi thủ tục từ xa (RPC) mã nguồn mở chạy trên nhiều ngôn ngữ lập trình khác nhau, bao gồm cả C++. gRPC được thiết kế để có hiệu suất cao, hiệu quả và có thể mở rộng, khiến nó trở nên lý tưởng cho kiến trúc vi dịch vụ và các ứng dụng khác có yêu cầu hiệu suất cao.\n\ngRPC sử dụng định dạng tuần tự hóa Bộ đệm giao thức (Protobuf) để trao đổi thông báo và định nghĩa phương thức. Bộ đệm giao thức cho phép tuần tự hóa hiệu quả hơn và nhỏ hơn so với các định dạng khác như JSON hoặc XML.\n\n## Bộ đệm giao thức\nTrong gRPC, bạn bắt đầu bằng cách xác định định nghĩa dịch vụ và cấu trúc thông báo trong tệp .proto. Bạn có thể xác định cấu trúc dữ liệu và giao diện dịch vụ bằng định dạng nhị phân nhỏ gọn, trung lập về ngôn ngữ, trung lập về nền tảng.\n\nĐây là một ví dụ về giao diện của nó:\n\n```\nsyntax = \"proto3\";\n\npackage example;\n\n// Định nghĩa dịch vụ gRPC\nservice Greeter {\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n\n// Định nghĩa thông báo yêu cầu\nmessage HelloRequest {\n  string name = 1;\n}\n\n// Định nghĩa thông báo trả lời\nmessage HelloReply {\n  string message = 1;\n}\n\n```cpp\n\nSau khi xác định tệp .proto, bạn sử dụng trình biên dịch protoc để tạo mã code C++ tương ứng cho ứng dụng của mình.\n\n## Máy chủ gRPC C++\nĐể tạo máy chủ gRPC trong C++, trước tiên bạn cần triển khai giao diện dịch vụ do trình biên dịch protoc tạo ra. Đây là một triển khai ví dụ cho dịch vụ Greeter:\n\n```\n#include <grpcpp/grpcpp.h>\n#include \"example.grpc.pb.h\"\n\nusing grpc::Server;\nusing grpc::ServerBuilder;\nusing grpc::ServerContext;\nusing grpc::Status;\nusing example::HelloRequest;\nusing example::HelloReply;\nusing example::Greeter;\n\nclass GreeterServiceImpl final : public Greeter::Service {\n  Status SayHello(ServerContext* context, const HelloRequest* request, HelloReply* reply) override {\n    std::string prefix(\"Hello \");\n    reply->set_message(prefix + request->name());\n    return Status::OK;\n  }\n};\n\nvoid RunServer() {\n  std::string server_address(\"0.0.0.0:50051\");\n  GreeterServiceImpl service;\n\n  ServerBuilder builder;\n  builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());\n  builder.RegisterService(&service);\n\n  std::unique_ptr<Server> server(builder.BuildAndStart());\n  std::cout << \"Server listening on \" << server_address << std::endl;\n  server->Wait();\n}\n\nint main(int argc, char** argv) {\n  RunServer();\n  return 0;\n}\n\n```cpp\n\n\n## Máy khách gRPC C++\nTương tự, để tạo ứng dụng khách gRPC C++, bạn sử dụng mã code được tạo từ trình biên dịch protoc và kết nối với máy chủ:\n\n```\n#include <grpcpp/grpcpp.h>\n#include \"example.grpc.pb.h\"\n\nusing grpc::Channel;\nusing grpc::ClientContext;\nusing grpc::Status;\nusing example::HelloRequest;\nusing example::HelloReply;\nusing example::Greeter;\n\nclass GreeterClient {\n public:\n  GreeterClient(std::shared_ptr<Channel> channel) : stub_(Greeter::NewStub(channel)) {}\n\n  std::string SayHello(const std::string& user) {\n    HelloRequest request;\n    request.set_name(user);\n\n    HelloReply reply;\n    ClientContext context;\n\n    Status status = stub_->SayHello(&context, request, &reply);\n\n    if (status.ok()) {\n      return reply.message();\n    } else {\n      std::cout << \"RPC failed\" << std::endl;\n      return \"RPC failed\";\n    }\n  }\n\n private:\n  std::unique_ptr<Greeter::Stub> stub_;\n};\n\nint main(int argc, char** argv) {\n  GreeterClient greeter(grpc::CreateChannel(\"localhost:50051\", grpc::InsecureChannelCredentials()));\n  std::string user(\"world\");\n  std::string reply = greeter.SayHello(user);\n  std::cout << \"Greeter received: \" << reply << std::endl;\n\n  return 0;\n}\n\n```cpp\n\nĐây là một ví dụ cơ bản thể hiện giao tiếp máy khách-máy chủ bằng gRPC trong C++. Các tính năng nâng cao hơn như phát trực tuyến hai chiều, xử lý lỗi và xác thực cũng có thể được sử dụng trong gRPC. Để biết thêm thông tin, bạn có thể tham khảo **tài liệu gRPC C++**."
                },
                {
                    "author": "Dev Alex",
                    "title": " TenorFlow",
                    "param": "chap-19-5",
                    "level": "beginner",
                    "code": "# TenorFlow\nTensorFlow là một thư viện học máy nguồn mở được phát triển bởi các nhà nghiên cứu và kỹ sư từ nhóm Google Brain. Nó được thiết kế để xây dựng, đào tạo và triển khai các mô hình học sâu. TensorFlow cung cấp một bộ công cụ cho ML, học sâu và tính toán số bằng biểu đồ luồng dữ liệu. TensorFlow có thể xử lý tính toán trên GPU và TPU, giúp tăng tốc thời gian đào tạo và đảm bảo triển khai mô hình hiệu quả.\n\n## Cài đặt\nBạn có thể cài đặt TensorFlow bằng trình quản lý gói Python pip:\n\n```\npip install tensorflow\n\n```cpp\n\n\n## Sử dụng cơ bản\nĐây là một ví dụ đơn giản về cách tạo và huấn luyện mạng nơ-ron với TensorFlow:\n\n```\nimport tensorflow as tf\nfrom tensorflow import keras\n\n# Load dataset\nmnist = keras.datasets.mnist\n(train_images, train_labels), (test_images, test_labels) = mnist.load_data()\n\n# Preprocess data\ntrain_images = train_images / 255.0\ntest_images = test_images / 255.0\n\n# Define model\nmodel = keras.Sequential([\n    keras.layers.Flatten(input_shape=(28, 28)),\n    keras.layers.Dense(128, activation='relu'),\n    keras.layers.Dense(10, activation='softmax')\n])\n\n# Compile model\nmodel.compile(optimizer='adam',\n              loss='sparse_categorical_crossentropy',\n              metrics=['accuracy'])\n\n# Train model\nmodel.fit(train_images, train_labels, epochs=5)\n\n# Evaluate model\ntest_loss, test_acc = model.evaluate(test_images, test_labels, verbose=2)\nprint('\\nTest accuracy:', test_acc)\n\n```cpp\n\nMã code này tải tập dữ liệu MNIST, xử lý trước dữ liệu, tạo một mạng nơ-ron đơn giản, biên dịch, huấn luyện và đánh giá hiệu suất của nó trên tập kiểm tra.\n\nĐể sử dụng nâng cao hơn, TensorFlow cung cấp một số API như tf.data, tf.keras và tf.estimator cho phép các pipeline nhập dữ liệu linh hoạt và hiệu quả, soạn thảo và huấn luyện các kiến trúc mạng nơ-ron phức tạp cũng như quản lý đào tạo phân tán quy mô lớn.\n\nBạn có thể truy cập trang web chính thức của TensorFlow (**https://www.tensorflow. org/**) và kho lưu trữ GitHub của họ (**https://github.com/tensorflow/tensorflow**) để biết thêm thông tin, hướng dẫn và tài nguyên."
                },
                {
                    "author": "Dev Alex",
                    "title": " Pybind11",
                    "param": "chap-19-6",
                    "level": "beginner",
                    "code": "# Pybind11\nPybind11 là một thư viện chỉ có tiêu đề gọn nhẹ tích hợp liền mạch mã C++ với Python, cho phép người dùng dễ dàng đưa mã code C++11 vào hệ sinh thái Python. Điều này đạt được bằng cách cung cấp các liên kết Python có thể tương tác với các hàm và lớp được viết bằng C++. Nó cung cấp một API tương tự như thư viện Boost.Python nhưng yêu cầu ít mã hơn, do đó mang lại hiệu suất tốt hơn.\n\nPybind11 giúp tạo các phần mở rộng thư viện, đưa mã code C++ hiệu suất cao vào các chương trình Python và sử dụng tính linh hoạt của Python để phát triển nhanh chóng trong khi vẫn hưởng lợi từ hiệu quả của C++.\n\n## Ví dụ mã code\nDưới đây là một số ví dụ về Pybind11 để hiểu rõ hơn về khái niệm này:\n- Hiển thị hàm C++ cho Python:\n  \n```\n  #include <pybind11/pybind11.h>\n\n  int add(int a, int b) {\n      return a + b;\n  }\n\n  PYBIND11_MODULE(example, m) {\n      m.def(\"add\", &add, \"A function that adds two numbers\");\n  }\n  \n```cpp\n\nChạy ví dụ trên sẽ tạo một mô-đun Python có tên là ví dụ, chứa một hàm duy nhất là add. Bạn có thể sử dụng hàm mới này trong Python như sau:\n\n```\nimport example\n\nresult = example.add(1, 2)\nprint(result)  # Output: 3\n\n```cpp\n\n- Hiển thị một lớp C++ với Python:\n  \n```\n  #include <pybind11/pybind11.h>\n\n  namespace py = pybind11;\n\n  class MyTestClass {\n  public:\n      MyTestClass(const std::string &name) : name_(name) { }\n\n      const std::string &name() const { return name_; }\n      void setName(const std::string &name) { name_ = name; }\n\n  private:\n      std::string name_;\n  };\n\n  PYBIND11_MODULE(example, m) {\n      py::class_<MyTestClass>(m, \"MyTestClass\")\n          .def(py::init<const std::string &>())\n          .def(\"name\", &MyTestClass::name)\n          .def(\"setName\", &MyTestClass::setName);\n  }\n  \n```cpp\n\nSau khi biên dịch mã code và nhập nó vào Python, bạn có thể tạo các phiên bản MyTestClass và gọi các phương thức name() và setName(string) của chúng:\n\n```\nimport example\n\nobj = example.MyTestClass(\"some_name\")\nprint(obj.name())  # Output: some_name\n\nobj.setName(\"new_name\")\nprint(obj.name())  # Output: new_name\n\n```cpp\n"
                },
                {
                    "author": "Dev Alex",
                    "title": " Spdlog",
                    "param": "chap-19-7",
                    "level": "beginner",
                    "code": "# Spdlog\nspdlog là thư viện ghi nhật ký C++ nhanh, chỉ có tiêu đề. Nó cung cấp một cách đơn giản và hiệu quả để thêm nhật ký chẩn đoán vào ứng dụng C++ của bạn.\n\n## Tính năng:\n- Chỉ tiêu đề, không cần xây dựng hoặc liên kết thư viện\n- Có khả năng cấu hình cao, bao gồm hỗ trợ cho các phần ghi nhật ký tùy chỉnh (ví dụ: ghi vào tệp hoặc cơ sở dữ liệu)\n- Chế độ ghi nhật ký không đồng bộ và đồng bộ\n- Kiểm tra chuỗi định dạng dựa trên tiền xử lý để bắt lỗi tại thời điểm biên dịch\n- Dễ dàng mở rộng với các trình định dạng, phần chìm và cấp độ tùy chỉnh\n\n## Ví dụ sử dụng:\nBao gồm tiêu đề spdlog, tạo một đối tượng logger và sử dụng nó để ghi các thông báo:\n\n```\n#include \"spdlog/spdlog.h\"\n\nint main() {\n    // Tạo một logger với tên \"example_logger\"\n    auto logger = spdlog::stdout_color_mt(\"example_logger\");\n\n    // Thông báo nhật ký với các mức độ nghiêm trọng khác nhau\n    logger->info(\"Welcome to spdlog!\");\n    logger->warn(\"Warning message\");\n    logger->error(\"Error message\");\n\n    return 0;\n}\n\n```cpp\n\n\n## Ví dụ về tệp chìm tùy chỉnh:\nĐây là một ví dụ về cách tạo trình ghi nhật ký với tệp chìm tùy chỉnh ghi vào tệp văn bản:\n\n```\n#include \"spdlog/spdlog.h\"\n#include \"spdlog/sinks/basic_file_sink.h\"\n\nint main() {\n    // Tạo một tệp chìm để ghi nhật ký vào \"logs.txt\"\n    auto file_sink = std::make_shared<spdlog::sinks::basic_file_sink_mt>(\"logs.txt\");\n\n    // Tạo logger với tệp chìm và tên \"example_logger\"\n    auto logger = std::make_shared<spdlog::logger>(\"example_logger\", file_sink);\n\n    // Đăng ký bộ ghi\n    spdlog::register_logger(logger);\n\n    // Thông báo log\n    logger->info(\"Welcome to spdlog!\");\n    logger->warn(\"Warning message\");\n    logger->error(\"Error message\");\n\n    return 0;\n}\n\n```cpp\n\nĐể biết thêm ví dụ và tài liệu chi tiết, hãy truy cập **kho lưu trữ spdlog GitHub**."
                },
                {
                    "author": "Dev Alex",
                    "title": " OpenCL",
                    "param": "chap-19-8",
                    "level": "beginner",
                    "code": "# OpenCL\nOpenCL (Open Computing Language) là một framework để viết các chương trình cho phép bạn thực thi mã code trên các nền tảng không đồng nhất bao gồm CPU, GPU và các bộ xử lý khác. Nó chủ yếu được sử dụng để lập trình song song và nó có thể được sử dụng để cải thiện hiệu suất của các ứng dụng khác nhau, bao gồm chơi game, kết xuất hình ảnh và video cũng như tính toán khoa học.\n\n## Tổng quan\nOpenCL cung cấp một giao diện lập trình được tiêu chuẩn hóa, cho phép bạn nhắm mục tiêu các thiết bị khác nhau, chẳng hạn như card đồ họa từ các nhà cung cấp khác nhau. Bạn có thể lập trình bằng C với OpenCL C hoặc C++ với ngôn ngữ hạt nhân OpenCL C++, dựa trên ISO C99 và C++14 tương ứng, với các phần mở rộng, tích hợp sẵn và các tính năng cụ thể để khai thác tính song song của thiết bị.\n\n## Ý chính\n- Platform: Tập hợp các thiết bị và tính năng phần mềm do nhà cung cấp cung cấp.\n- Thiết bị: Đơn vị xử lý có thể thực thi mã OpenCL, ví dụ: CPU hoặc GPU.\n- Hàng đợi lệnh: Một chuỗi các lệnh sẽ được thực thi trên thiết bị.\n- Kernel: Một chức năng song song được thực thi trên các thiết bị OpenCL.\n- Bộ đệm: Một đối tượng bộ nhớ lưu trữ một lượng dữ liệu cụ thể (ví dụ: một mảng số nguyên hoặc số thực) mà cả máy chủ và thiết bị đều có thể truy cập được.\n\n## Mã code mẫu\nĐây là một ví dụ mã code OpenCL đơn giản minh họa cách triển khai phép cộng vecto:\n\n```\n#include <CL/cl.h>\n#include <iostream>\n#include <vector>\n\nconst char *kernelSource = \"__kernel void vector_add(__global int *A, __global int *B, __global int *C, const int N){\"\n                            \"  int i = get_global_id(0);\"\n                            \"  if(i < N){\"\n                            \"    C[i] = A[i] + B[i];\"\n                            \"  }\"\n                            \"}\";\n\nint main(){\n    // Khởi tạo vectơ dữ liệu\n    std::vector<int> A = {1, 2, 3};\n    std::vector<int> B = {4, 5, 6};\n    std::vector<int> C(A.size());\n\n    // Thiết lập môi trường, thiết bị và bối cảnh OpenCL\n    // ... bỏ qua cho ngắn gọn ...\n\n    // Tạo bộ nhớ đệm cho A, B và C\n    // ... bỏ qua cho ngắn gọn ...\n\n    // Tạo kernel từ nguồn và đặt đối số kernel\n    // ... bỏ qua cho ngắn gọn ...\n\n    //Thực thi kernel bằng hàng đợi lệnh và đọc bộ đệm đầu ra\n    // ... bỏ qua cho ngắn gọn ...\n\n    // Kết quả đầu ra\n    for (size_t i = 0; i < A.size(); ++i) {\n        std::cout << A[i] << \" + \" << B[i] << \" = \" << C[i] << std::endl;\n    }\n    return 0;\n}\n\n```cpp\n\nĐoạn mã code này thể hiện cấu trúc cơ bản của chương trình OpenCL trong C++. Có các chi tiết bổ sung cần thiết để thiết lập môi trường, thiết bị và ngữ cảnh, cũng như tạo bộ nhớ đệm, nhân và hàng đợi lệnh. Bạn có thể tìm thấy các ví dụ đầy đủ và nhiều thông tin hơn trong **Hướng dẫn Lập trình OpenCL chính thức**."
                },
                {
                    "author": "Dev Alex",
                    "title": " fmt",
                    "param": "chap-19-9",
                    "level": "beginner",
                    "code": "# fmt\nfmt là một thư viện định dạng C++ hiện đại cung cấp một cách dễ dàng và hiệu quả để định dạng văn bản và in nó ra các đầu ra khác nhau. Thư viện cung cấp mức độ tương thích cao với các tiêu chuẩn C++, làm cho nó phù hợp với nhiều ứng dụng và nền tảng khác nhau. fmt nhấn mạnh tính đơn giản, khả năng mở rộng và an toàn kiểu.\n\n## Tính năng\n- Hỗ trợ các đối số vị trí và được đặt tên để dễ đọc hơn trong các tác vụ định dạng phức tạp\n- Hỗ trợ cú pháp chuỗi định dạng tương tự như str.format() của Python\n- Cung cấp kiểm tra chuỗi định dạng thời gian biên dịch để đảm bảo an toàn cho loại\n- Tài liệu phong phú và API thân thiện với người dùng\n\n## Ví dụ sử dụng\nDưới đây là một số ví dụ về cách sử dụng thư viện fmt:\n\n### Sử dụng cơ bản\n\n```\n#include <fmt/core.h>\n\nint main() {\n    fmt::print(\"Hello, world!\\n\");\n    return 0;\n}\n\n```cpp\n\n\n### Định dạng với các đối số vị trí\n\n```\n#include <fmt/core.h>\n\nint main() {\n    fmt::print(\"The answer is {}.\\n\", 42);\n    fmt::print(\"{1}, {0}!\\n\", \"world\", \"Hello\");\n    return 0;\n}\n\n```cpp\n\n\n### Định dạng với các đối số được đặt tên\n\n```\n#include <fmt/core.h>\n\nint main() {\n    fmt::print(\"Hello, {name}!\\n\", fmt::arg(\"name\", \"world\"));\n    return 0;\n}\n\n```cpp\n\n\n### Sử dụng cú pháp chuỗi định dạng\n\n```\n#include <fmt/core.h>\n\nint main() {\n    fmt::print(\"{:<30}\", \"left-aligned\");\n    fmt::print(\"{:>30}\", \"right-aligned\");\n    fmt::print(\"{:^30}\", \"center-aligned\");\n    fmt::print(\"{:*^30}\", \"center-aligned\");\n\n    fmt::print(\"int: {0:d}; hex: {0:x}; oct: {0:o}; bin: {0:b}\", 42);\n    fmt::print(\"{:.2f}\", 3.1415926);\n    fmt::print(\"{:010.2f}\", 3.1415926);\n\n    return 0;\n}\n\n```cpp\n\nĐể biết thêm thông tin, bạn có thể tham khảo **tài liệu fmt chính thức**."
                }
            ]
        },
        {
            "title": "Chương 21 Framework",
            "param": "chap-20-0",
            "list": [
                {
                    "author": "Dev Alex",
                    "title": " Google Test (gtest)",
                    "param": "chap-20-0",
                    "level": "beginner",
                    "code": "# Google Test (gtest)\nGoogle Test, còn được gọi là gtest hoặc googletest, là một khung kiểm tra C++ do Google phát triển. Nó cung cấp API thân thiện với người dùng để viết các trường hợp thử nghiệm và được thiết kế để sử dụng trong nhiều ứng dụng, từ thử nghiệm đơn vị đơn giản đến thử nghiệm cấp hệ thống phức tạp.\n\n## Bắt đầu với Google Test\nĐể sử dụng Google Test trong dự án của bạn, hãy làm theo các bước sau:\n- Tải xuống mã nguồn từ **kho GoogleTest GitHub**.\n- Xây dựng và cài đặt Google Test trên hệ thống của bạn. Có thể tìm thấy hướng dẫn cho các nền tảng khác nhau trong tệp **README**.\n- Bao gồm các tiêu đề cần thiết và liên kết với thư viện Google Test trong dự án của bạn.\n\n## Viết bài kiểm tra với Google Test\nĐây là một ví dụ về cách viết một bài kiểm tra đơn giản bằng Google Test:\n- **Bao hàm các tiêu đề cần thiết**\n  \n```\n  #include \"gtest/gtest.h\"\n  \n```cpp\n\n- **Viết các hàm bạn muốn kiểm tra**\n\n  Giả sử chúng ta có một hàm đơn giản để kiểm tra:\n  \n```\n  int add(int a, int b) {\n    return a + b;\n  }\n  \n```cpp\n\n- **Viết các trường hợp thử nghiệm**\n\n  Để tạo một trường hợp thử nghiệm, hãy sử dụng macro TEST(), macro này nhận hai đối số: tên bộ thử nghiệm và tên trường hợp thử nghiệm.\n  \n```\n  // Kiểm tra hàm 'add'.\n  TEST(AdditionTest, PositiveNumbers) {\n    EXPECT_EQ(3, add(1, 2));\n    EXPECT_EQ(5, add(2, 3));\n  }\n\n  TEST(AdditionTest, NegativeNumbers) {\n    EXPECT_EQ(-3, add(-1, -2));\n    EXPECT_EQ(-5, add(-2, -3));\n  }\n  \n```cpp\n\n- **Viết hàm main()**\n\n  Để chạy thử nghiệm, hãy bao gồm hàm main() khởi tạo Google Test và chạy thử nghiệm.\n  \n```\n  int main(int argc, char **argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n  }\n  \n```cpp\n\n- **Biên dịch và chạy thử nghiệm**\n\n  Biên dịch chương trình thử nghiệm của bạn với thư viện Google Test và chạy tệp thực thi thử nghiệm.\n\n## Nhiều tính năng hơn\nGoogle Test cung cấp nhiều tính năng phạm vi mở rộng khiến việc kiểm tra trở nên dễ dàng hơn, chẳng hạn như:\n- **Thiết bị kiểm tra:** Thiết bị kiểm tra cho phép bạn sử dụng lại cùng một bộ đối tượng cho nhiều lần kiểm tra. Bạn có thể xác định thiết bị kiểm tra bằng cách tạo một lớp kế thừa từ ::testing::Test và viết các phương thức thiết lập, phân tích.\n- **Assertion (Kiểm tra một biểu thức có true hay không):** Google Test cung cấp nhiều macro assertion để giúp bạn xác minh hành vi của mã. Một số cái phổ biến bao gồm EXPECT_EQ, EXPECT_TRUE, EXPECT_FALSE, ASSERT_EQ, ASSERT_TRUE và ASSERT_FALSE.\n- **Thử nghiệm được tham số hóa:** Google Test hỗ trợ các thử nghiệm được tham số hóa, cho phép bạn dễ dàng chạy cùng một thử nghiệm với các đầu vào khác nhau.\n- **Death Test:** Google Test cho phép bạn viết các bài kiểm tra để xác minh xem mã code của bạn có kết thúc chính xác hay không với thông báo lỗi dự kiến.\n\nĐể biết thêm thông tin về Google Test và các tính năng của nó, hãy tham khảo tài liệu chính thức."
                },
                {
                    "author": "Dev Alex",
                    "title": " Khung Qt",
                    "param": "chap-20-1",
                    "level": "beginner",
                    "code": "# Khung Qt\nQt là một khung đa nền tảng, nguồn mở để tạo các ứng dụng hiệu suất cao với giao diện người dùng tương tác. Nó chủ yếu được sử dụng để phát triển các ứng dụng GUI nhưng cũng có thể được sử dụng để tạo các ứng dụng không phải GUI như công cụ bảng điều khiển và máy chủ.\n\nQt cung cấp nhiều thư viện C++ và tích hợp liền mạch với các IDE phổ biến, giúp các nhà phát triển dễ dàng tạo các ứng dụng giàu tính năng hơn. Nó cung cấp một môi trường phát triển toàn diện, bao gồm các công cụ để thiết kế, mã hóa, gỡ lỗi và lập hồ sơ ứng dụng.\n\n## Các tính năng chính\n- **Đa nền tảng:** Qt có thể tạo các ứng dụng chạy trên các nền tảng khác nhau (ví dụ: Windows, macOS, Linux, Android, iOS) mà không cần bất kỳ mã code dành riêng cho nền tảng nào.\n- **Thư viện mô-đun:** Qt bao gồm một số thư viện mô-đun, bao gồm QtCore (chức năng lõi non-GUI), QtGui (các lớp liên quan đến GUI), QtWidgets (tiện ích GUI) và QtNetwork (hỗ trợ mạng).\n- **Tín hiệu và Khe cắm:** Qt cung cấp một cơ chế duy nhất để xử lý các sự kiện được gọi là “tín hiệu và khe cắm”, cho phép giao tiếp giữa các đối tượng an toàn và linh hoạt.\n- **Tích hợp OpenGL:** Qt hỗ trợ kết xuất đồ họa 2D và 3D bằng OpenGL, làm cho nó phù hợp để phát triển trò chơi và các ứng dụng đồ họa khác.\n\n## Ví dụ mã code\nĐây là một ví dụ đơn giản về “Hello, World!” ứng dụng sử dụng Qt:\n\n```\n#include <QApplication>\n#include <QLabel>\n\nint main(int argc, char *argv[])\n{\n    QApplication app(argc, argv);\n\n    QLabel label(\"Hello, World!\");\n    label.show();\n\n    return app.exec();\n}\n\n```cpp\n\nTrong ví dụ này, chúng tôi bao hàm các tệp tiêu đề cần thiết, tạo các đối tượng QApplication và QLabel, hiển thị nhãn có dòng chữ “Hello, World!” thông báo, và thực thi ứng dụng.\n\nĐể biên dịch và chạy ví dụ này, bạn cần cài đặt thư viện Qt và định cấu hình môi trường phát triển của mình để sử dụng nó.\n\nĐể biết thêm thông tin và hướng dẫn về Qt, bạn có thể tham khảo **tài liệu chính thức về Qt**."
                },
                {
                    "author": "Dev Alex",
                    "title": " Catch2",
                    "param": "chap-20-2",
                    "level": "beginner",
                    "code": "# Catch2\nCatch2 là một khung thử nghiệm hiện đại, gốc C++ dành cho các bài thử nghiệm đơn vị, TDD và BDD. Đây là một thư viện tiêu đề đơn, nghĩa là bạn chỉ cần bao hàm một tệp tiêu đề (catch.hpp) để bắt đầu sử dụng nó. Catch2 nhanh, dễ sử dụng và hỗ trợ nhiều kiểu kiểm tra khác nhau.\n\n## Tính năng\n- **Tiêu đề đơn:** Chỉ cần #include \"catch.hpp\" và bắt đầu viết bài thử nghiệm.\n- **Các trường hợp thử nghiệm:** Khai báo các trường hợp thử nghiệm bằng cách sử dụng macro TEST_CASE.\n- **Phần:** Chia các trường hợp thử nghiệm thành các phần bằng cách sử dụng phần macro.\n- **BDD:** Thiết kế phát triển dựa trên hành vi được hỗ trợ với SCENARIO, GIVEN, WHEN, THEN.\n- **Trình so khớp:** Sử dụng trình so khớp tích hợp phong phú để kiểm tra biểu thức thành true hơn.\n- **Khám phá thử nghiệm:** Catch2 tự động phát hiện các phần và trường hợp thử nghiệm của bạn.\n\n## Ví dụ mã code\n\n### Trường hợp thử nghiệm cơ bản\n\n```\n#define CATCH_CONFIG_MAIN  // Yêu cầu Catch cung cấp hàm main()\n#include \"catch.hpp\"\n\nint add(int a, int b) {\n    return a + b;\n}\n\nTEST_CASE(\"Addition\") {\n    REQUIRE(add(2, 3) == 5);\n}\n\n```cpp\n\n\n### Phần\n\n```\nTEST_CASE(\"Sections example\") {\n    int a = 1;\n\n    SECTION(\"incrementing a\") {\n        a++;\n        REQUIRE(a == 2);\n    }\n\n    SECTION(\"decrementing a\") {\n        a--;\n        REQUIRE(a == 0);\n    }\n}\n\n```cpp\n\n\n### Thiết kế BDD\n\n```\nSCENARIO(\"vector can be sized and resized\", \"[vector]\") {\n    std::vector<int> v;\n\n    GIVEN(\"A vector with some items\") {\n        v.push_back(1);\n        v.push_back(2);\n        v.push_back(3);\n\n        REQUIRE(v.size() == 3);\n\n        WHEN(\"the size is increased\") {\n            v.resize(5);\n\n            THEN(\"the size and contents change\") {\n                REQUIRE(v.size() == 5);\n                REQUIRE(v[3] == 0);\n                REQUIRE(v[4] == 0);\n            }\n        }\n        WHEN(\"the size is reduced\") {\n            v.resize(2);\n\n            THEN(\"the size changes but not the contents\") {\n                REQUIRE(v.size() == 2);\n                REQUIRE(v[0] == 1);\n                REQUIRE(v[1] == 2);\n            }\n        }\n    }\n}\n\n```cpp\n\n\n### Trình so khớp\n\n```\nTEST_CASE(\"Matchers example\") {\n    std::string str = \"Hello, world!\";\n\n    CHECK_THAT(str, Catch::Matchers::StartsWith(\"Hello\"));\n    CHECK_THAT(str, Catch::Matchers::EndsWith(\"world!\"));\n    CHECK_THAT(str, Catch::Matchers::Contains(\"lo, wo\"));\n}\n\n```cpp\n\nĐể biết thêm thông tin, hãy truy cập **kho lưu trữ Catch2 GitHub**."
                },
                {
                    "author": "Dev Alex",
                    "title": " Orbit Profiler",
                    "param": "chap-20-3",
                    "level": "beginner",
                    "code": "# Orbit Profiler\nOrbit Profiler là một trình lược tả hiệu năng cho các ứng dụng C++. Nó được thiết kế để cung cấp cho các nhà phát triển thông tin phản hồi theo thời gian thực về hiệu suất của ứng dụng của họ và giúp họ xác định các tắc nghẽn về hiệu suất. Nó hỗ trợ cả nền tảng Windows và Linux, lập hồ sơ cho cả quy trình cục bộ và từ xa.\n\n**Các tính năng chính của Orbit Profiler:**\n\n- Profiling trên lấy mẫu\n- Profiling trên thiết bị\n- Bộ thu thập ngăn xếp\n- Các phép đo dựa trên khung bằng cách sử dụng macro phạm vi\n\n## Sử dụng\n- Bao hàm OrbitProfiler.h: Trước tiên, bạn cần bao hàm tệp tiêu đề OrbitProfiler.h trong dự án của mình:\n  \n```\n  #include \"OrbitProfiler.h\"\n  \n```cpp\n\n- **Bắt đầu và dừng trình lược tả:** Sử dụng ORBET_START và ORBIT_STOP để bắt đầu và dừng trình lược tả.\n  \n```\n  ORBIT_START();\n  // Mã code ứng dụng của bạn ở đây\n  ORBIT_STOP();\n  \n```cpp\n\n- **Phạm vi đo lường:** Sử dụng macro ORBET_SCOPE để chú thích phạm vi của hàm bạn muốn đo lường:\n  \n```\n  void ExampleFunction() {\n    ORBIT_SCOPE(\"Example Function\");\n    // Nội dung hàm tại đây\n  }\n- **Trực quan hóa dữ liệu đã thu thập:** Orbit Profiler cung cấp Chế độ xem session hiển thị dữ liệu đã thu thập và cho phép bạn điều hướng qua dòng thời gian, phân tích dữ liệu và xác định các tắc nghẽn hiệu suất.\n\n## Ví dụ\nĐối với mục đích chứng mình, hãy xem xét ví dụ sau về một ứng dụng C++ đơn giản:\n\n```cpp\n\n#include \"OrbitProfiler.h\"\n\nvoid FunctionA() {\n  ORBIT_SCOPE(\"Function A\");\n  // Mã code hàm A ở đây\n}\n\nvoid FunctionB() {\n  ORBIT_SCOPE(\"Function B\");\n  // Mã code hàm B ở đâ\n}\n\nint main() {\n  ORBIT_START();\n\n  FunctionA();\n  FunctionB();\n\n  ORBIT_STOP();\n  return 0;\n}\n\n```\nBằng cách sử dụng Orbit Profiler, chúng ta có thể xác định chính xác các vấn đề về hiệu suất trong FunctionA và FunctionB và tối ưu hóa ứng dụng của chúng tôi cho phù hợp.\n\nĐể biết thêm thông tin, hãy tham khảo **kho lưu trữ GitHub chính thức của Orbit Profiler**."
                },
                {
                    "author": "Dev Alex",
                    "title": " PyTorch C++",
                    "param": "chap-20-4",
                    "level": "beginner",
                    "code": "# PyTorch C++\nPyTorch C++ là API C++ (Giao diện lập trình ứng dụng) cho PyTorch. Nó còn được gọi là LibTorch, là thư viện cung cấp gần như tất cả chức năng của PyTorch có thể truy cập thông qua ngôn ngữ C++. Mục tiêu chính của việc cung cấp API C++ là cho phép tích hợp hiệu suất cao với các nền tảng học sâu khác và cho phép hoạt động liền mạch trong các hệ thống cấp doanh nghiệp và sản xuất.\n\n## Cài đặt\nĐể sử dụng API PyTorch C++, bạn cần cài đặt bản phân phối LibTorch. Làm theo hướng dẫn trên **trang API PyTorch C++ chính thức** để cài đặt thư viện dựa trên nền tảng và yêu cầu của bạn.\n\n## Ví dụ: Tensors\n\n```cpp\n\n#include <iostream>\n#include <torch/torch.h>\n\nint main() {\n  // Tạo ma trận 3x3 với các số không.\n  torch::Tensor a = torch::zeros({3, 3});\n  std::cout << a << std::endl;\n\n  // Tạo ma trận 2x2 với hàng đơn vị và chuyển thành float.\n  torch::Tensor b = torch::ones({2, 2}).to(torch::kFloat);\n  std::cout << b << std::endl;\n\n  // Tạo một tensor ngẫu nhiên có kích thước 2x2 và chỉ định loại của nó.\n  torch::Tensor c = torch::randint(0, 10, {2, 2}, torch::kInt);\n  std::cout << c << std::endl;\n\n  // Thực hiện phép cộng từng phần tử.\n  auto sum = b + c.to(torch::kFloat);\n  std::cout << sum << std::endl;\n}\n\n```\n\n## Ví dụ: Tạo một mô-đun tùy chỉnh\n\n```cpp\n\n#include <iostream>\n#include <torch/torch.h>\n\n// Xác định một mô-đun tùy chỉnh.\nstruct Net : torch::nn::Module {\n  Net() {\n    fc1 = register_module(\"fc1\", torch::nn::Linear(784, 64));\n    fc2 = register_module(\"fc2\", torch::nn::Linear(64, 10));\n  }\n\n  torch::Tensor forward(torch::Tensor x) {\n    x = x.view({-1, 784});\n    x = torch::relu(fc1->forward(x));\n    x = torch::log_softmax(fc2->forward(x), 1);\n    return x;\n  }\n\n  torch::nn::Linear fc1{nullptr};\n  torch::nn::Linear fc2{nullptr};\n};\n\nint main() {\n  // Tạo một phiên bản của mô-đun tùy chỉnh.\n  Net net;\n\n  // Sử dụng mô-đun tùy chỉnh.\n  torch::Tensor input = torch::randn({2, 1, 28, 28});\n  torch::Tensor output = net.forward(input);\n  std::cout << output << std::endl;\n\n  return 0;\n}\n\n```\nTrong các ví dụ này, chúng tôi đã trình bày cách sử dụng các hoạt động tensor khác nhau và cách tạo mô-đun mạng nơ-ron tùy chỉnh bằng PyTorch C++. Để biết thêm thông tin chi tiết và hướng dẫn, hãy truy cập **tài liệu chính thức về C++ của PyTorch**."
                }
            ]
        }
    ],
    "code": "res_success"
}